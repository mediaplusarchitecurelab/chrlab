{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DirectGeometry } from './DirectGeometry.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { arrayMax } from '../utils.js';\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nvar _m1 = new Matrix4();\n\nvar _obj = new Object3D();\n\nvar _offset = new Vector3();\n\nvar _box = new Box3();\n\nvar _boxMorphTargets = new Box3();\n\nvar _vector = new Vector3();\n\nfunction BufferGeometry() {\n  Object.defineProperty(this, 'id', {\n    value: _bufferGeometryId += 2\n  });\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = 'BufferGeometry';\n  this.index = null;\n  this.attributes = {};\n  this.morphAttributes = {};\n  this.morphTargetsRelative = false;\n  this.groups = [];\n  this.boundingBox = null;\n  this.boundingSphere = null;\n  this.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n  this.userData = {};\n}\n\nBufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: BufferGeometry,\n  isBufferGeometry: true,\n  getIndex: function () {\n    return this.index;\n  },\n  setIndex: function (index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n  },\n  getAttribute: function (name) {\n    return this.attributes[name];\n  },\n  setAttribute: function (name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  },\n  deleteAttribute: function (name) {\n    delete this.attributes[name];\n    return this;\n  },\n  addGroup: function (start, count, materialIndex) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex !== undefined ? materialIndex : 0\n    });\n  },\n  clearGroups: function () {\n    this.groups = [];\n  },\n  setDrawRange: function (start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  },\n  applyMatrix4: function (matrix) {\n    var position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n\n    var normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n\n    var tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  rotateX: function (angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateY: function (angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateZ: function (angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  translate: function (x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  scale: function (x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  lookAt: function (vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  },\n  center: function () {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  },\n  setFromObject: function (object) {\n    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n    var geometry = object.geometry;\n\n    if (object.isPoints || object.isLine) {\n      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n      this.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n      }\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      if (geometry && geometry.isGeometry) {\n        this.fromGeometry(geometry);\n      }\n    }\n\n    return this;\n  },\n  setFromPoints: function (points) {\n    var position = [];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  },\n  updateFromObject: function (object) {\n    var geometry = object.geometry;\n\n    if (object.isMesh) {\n      var direct = geometry.__directGeometry;\n\n      if (geometry.elementsNeedUpdate === true) {\n        direct = undefined;\n        geometry.elementsNeedUpdate = false;\n      }\n\n      if (direct === undefined) {\n        return this.fromGeometry(geometry);\n      }\n\n      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\n      geometry.verticesNeedUpdate = false;\n      geometry.normalsNeedUpdate = false;\n      geometry.colorsNeedUpdate = false;\n      geometry.uvsNeedUpdate = false;\n      geometry.groupsNeedUpdate = false;\n      geometry = direct;\n    }\n\n    var attribute;\n\n    if (geometry.verticesNeedUpdate === true) {\n      attribute = this.attributes.position;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.vertices);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.verticesNeedUpdate = false;\n    }\n\n    if (geometry.normalsNeedUpdate === true) {\n      attribute = this.attributes.normal;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.normals);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.normalsNeedUpdate = false;\n    }\n\n    if (geometry.colorsNeedUpdate === true) {\n      attribute = this.attributes.color;\n\n      if (attribute !== undefined) {\n        attribute.copyColorsArray(geometry.colors);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.colorsNeedUpdate = false;\n    }\n\n    if (geometry.uvsNeedUpdate) {\n      attribute = this.attributes.uv;\n\n      if (attribute !== undefined) {\n        attribute.copyVector2sArray(geometry.uvs);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.uvsNeedUpdate = false;\n    }\n\n    if (geometry.lineDistancesNeedUpdate) {\n      attribute = this.attributes.lineDistance;\n\n      if (attribute !== undefined) {\n        attribute.copyArray(geometry.lineDistances);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.lineDistancesNeedUpdate = false;\n    }\n\n    if (geometry.groupsNeedUpdate) {\n      geometry.computeGroups(object.geometry);\n      this.groups = geometry.groups;\n      geometry.groupsNeedUpdate = false;\n    }\n\n    return this;\n  },\n  fromGeometry: function (geometry) {\n    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);\n    return this.fromDirectGeometry(geometry.__directGeometry);\n  },\n  fromDirectGeometry: function (geometry) {\n    var positions = new Float32Array(geometry.vertices.length * 3);\n    this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      var normals = new Float32Array(geometry.normals.length * 3);\n      this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      var colors = new Float32Array(geometry.colors.length * 3);\n      this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      var uvs = new Float32Array(geometry.uvs.length * 2);\n      this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    this.groups = geometry.groups; // morphs\n\n    for (var name in geometry.morphTargets) {\n      var array = [];\n      var morphTargets = geometry.morphTargets[name];\n\n      for (var i = 0, l = morphTargets.length; i < l; i++) {\n        var morphTarget = morphTargets[i];\n        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      this.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    var position = this.attributes.position;\n    var morphAttributesPosition = this.morphAttributes.position;\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n\n          _box.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n\n            this.boundingBox.expandByPoint(_vector);\n\n            _vector.addVectors(this.boundingBox.max, _box.max);\n\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  },\n  computeBoundingSphere: function () {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    var position = this.attributes.position;\n    var morphAttributesPosition = this.morphAttributes.position;\n\n    if (position) {\n      // first, find the center of the bounding sphere\n      var center = this.boundingSphere.center;\n\n      _box.setFromBufferAttribute(position); // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n\n            _box.expandByPoint(_vector);\n\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n      var maxRadiusSq = 0;\n\n      for (var i = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      } // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n          var morphTargetsRelative = this.morphTargetsRelative;\n\n          for (var j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n\n              _vector.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  },\n  computeFaceNormals: function () {// backwards compatibility\n  },\n  computeVertexNormals: function () {\n    var index = this.index;\n    var attributes = this.attributes;\n\n    if (attributes.position) {\n      var positions = attributes.position.array;\n\n      if (attributes.normal === undefined) {\n        this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));\n      } else {\n        // reset existing normals to zero\n        var array = attributes.normal.array;\n\n        for (var i = 0, il = array.length; i < il; i++) {\n          array[i] = 0;\n        }\n      }\n\n      var normals = attributes.normal.array;\n      var vA, vB, vC;\n      var pA = new Vector3(),\n          pB = new Vector3(),\n          pC = new Vector3();\n      var cb = new Vector3(),\n          ab = new Vector3(); // indexed elements\n\n      if (index) {\n        var indices = index.array;\n\n        for (var i = 0, il = index.count; i < il; i += 3) {\n          vA = indices[i + 0] * 3;\n          vB = indices[i + 1] * 3;\n          vC = indices[i + 2] * 3;\n          pA.fromArray(positions, vA);\n          pB.fromArray(positions, vB);\n          pC.fromArray(positions, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normals[vA] += cb.x;\n          normals[vA + 1] += cb.y;\n          normals[vA + 2] += cb.z;\n          normals[vB] += cb.x;\n          normals[vB + 1] += cb.y;\n          normals[vB + 2] += cb.z;\n          normals[vC] += cb.x;\n          normals[vC + 1] += cb.y;\n          normals[vC + 2] += cb.z;\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (var i = 0, il = positions.length; i < il; i += 9) {\n          pA.fromArray(positions, i);\n          pB.fromArray(positions, i + 3);\n          pC.fromArray(positions, i + 6);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normals[i] = cb.x;\n          normals[i + 1] = cb.y;\n          normals[i + 2] = cb.z;\n          normals[i + 3] = cb.x;\n          normals[i + 4] = cb.y;\n          normals[i + 5] = cb.z;\n          normals[i + 6] = cb.x;\n          normals[i + 7] = cb.y;\n          normals[i + 8] = cb.z;\n        }\n      }\n\n      this.normalizeNormals();\n      attributes.normal.needsUpdate = true;\n    }\n  },\n  merge: function (geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n    }\n\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      var attribute1 = attributes[key];\n      var attributeArray1 = attribute1.array;\n      var attribute2 = geometry.attributes[key];\n      var attributeArray2 = attribute2.array;\n      var attributeOffset = attribute2.itemSize * offset;\n      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      for (var i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  },\n  normalizeNormals: function () {\n    var normals = this.attributes.normal;\n\n    for (var i = 0, il = normals.count; i < il; i++) {\n      _vector.x = normals.getX(i);\n      _vector.y = normals.getY(i);\n      _vector.z = normals.getZ(i);\n\n      _vector.normalize();\n\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  },\n  toNonIndexed: function () {\n    function convertBufferAttribute(attribute, indices) {\n      var array = attribute.array;\n      var itemSize = attribute.itemSize;\n      var array2 = new array.constructor(indices.length * itemSize);\n      var index = 0,\n          index2 = 0;\n\n      for (var i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (var j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize);\n    } //\n\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\n      return this;\n    }\n\n    var geometry2 = new BufferGeometry();\n    var indices = this.index.array;\n    var attributes = this.attributes; // attributes\n\n    for (var name in attributes) {\n      var attribute = attributes[name];\n      var newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    } // morph attributes\n\n\n    var morphAttributes = this.morphAttributes;\n\n    for (name in morphAttributes) {\n      var morphArray = [];\n      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (var i = 0, il = morphAttribute.length; i < il; i++) {\n        var attribute = morphAttribute[i];\n        var newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes[name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n    var groups = this.groups;\n\n    for (var i = 0, l = groups.length; i < l; i++) {\n      var group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  },\n  toJSON: function () {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    data.data = {\n      attributes: {}\n    };\n    var index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      var attribute = attributes[key];\n      var attributeData = attribute.toJSON();\n      if (attribute.name !== '') attributeData.name = attribute.name;\n      data.data.attributes[key] = attributeData;\n    }\n\n    var morphAttributes = {};\n    var hasMorphAttributes = false;\n\n    for (var key in this.morphAttributes) {\n      var attributeArray = this.morphAttributes[key];\n      var array = [];\n\n      for (var i = 0, il = attributeArray.length; i < il; i++) {\n        var attribute = attributeArray[i];\n        var attributeData = attribute.toJSON();\n        if (attribute.name !== '') attributeData.name = attribute.name;\n        array.push(attributeData);\n      }\n\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    var groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    var boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  },\n  clone: function () {\n    /*\n     // Handle primitives\n    \t var parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t var values = [];\n    \t for ( var key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t var geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new BufferGeometry().copy(this);\n  },\n  copy: function (source) {\n    var name, i, l; // reset\n\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // index\n\n    var index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone());\n    } // attributes\n\n\n    var attributes = source.attributes;\n\n    for (name in attributes) {\n      var attribute = attributes[name];\n      this.setAttribute(name, attribute.clone());\n    } // morph attributes\n\n\n    var morphAttributes = source.morphAttributes;\n\n    for (name in morphAttributes) {\n      var array = [];\n      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone());\n      }\n\n      this.morphAttributes[name] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n    var groups = source.groups;\n\n    for (i = 0, l = groups.length; i < l; i++) {\n      var group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    } // bounding box\n\n\n    var boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    var boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // draw range\n\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count; // user data\n\n    this.userData = source.userData;\n    return this;\n  },\n  dispose: function () {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n});\nexport { BufferGeometry };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/core/BufferGeometry.js"],"names":["Vector3","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","DirectGeometry","Object3D","Matrix4","Matrix3","MathUtils","arrayMax","_bufferGeometryId","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","Object","defineProperty","value","uuid","generateUUID","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","prototype","assign","create","constructor","isBufferGeometry","getIndex","setIndex","Array","isArray","getAttribute","setAttribute","attribute","deleteAttribute","addGroup","materialIndex","push","undefined","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromObject","object","geometry","isPoints","isLine","positions","vertices","length","colors","copyVector3sArray","copyColorsArray","lineDistances","copyArray","clone","isMesh","isGeometry","fromGeometry","setFromPoints","points","i","l","point","updateFromObject","direct","__directGeometry","elementsNeedUpdate","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","normals","color","uv","copyVector2sArray","uvs","lineDistancesNeedUpdate","lineDistance","computeGroups","fromDirectGeometry","Float32Array","uvs2","morphTargets","array","morphTarget","data","skinIndices","copyVector4sArray","skinWeights","morphAttributesPosition","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","console","error","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeFaceNormals","computeVertexNormals","vA","vB","vC","pA","pB","pC","cb","ab","indices","fromArray","subVectors","cross","normalizeNormals","merge","offset","warn","key","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","itemSize","getX","getY","getZ","normalize","setXYZ","toNonIndexed","convertBufferAttribute","array2","index2","geometry2","newAttribute","morphArray","group","toJSON","metadata","version","generator","keys","parameters","slice","call","attributeData","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","copy","source","dispose","dispatchEvent"],"mappings":"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","sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DirectGeometry } from './DirectGeometry.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { arrayMax } from '../utils.js';\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nvar _m1 = new Matrix4();\nvar _obj = new Object3D();\nvar _offset = new Vector3();\nvar _box = new Box3();\nvar _boxMorphTargets = new Box3();\nvar _vector = new Vector3();\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\tthis.morphTargetsRelative = false;\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tsetAttribute: function ( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tdeleteAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tvar tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object.isMesh ) {\n\n\t\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tvar position = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\tdirect = undefined;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tvar attribute;\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tvar position = this.attributes.position;\n\t\tvar morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tvar position = this.attributes.position;\n\t\tvar morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tvar morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeOffset = attribute2.itemSize * offset;\n\t\t\tvar length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal;\n\n\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.x = normals.getX( i );\n\t\t\t_vector.y = normals.getY( i );\n\t\t\t_vector.z = normals.getZ( i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = this.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar morphArray = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = morphAttribute[ i ];\n\n\t\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tvar groups = this.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar attributeData = attribute.toJSON();\n\n\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\tdata.data.attributes[ key ] = attributeData;\n\n\t\t}\n\n\t\tvar morphAttributes = {};\n\t\tvar hasMorphAttributes = false;\n\n\t\tfor ( var key in this.morphAttributes ) {\n\n\t\t\tvar attributeArray = this.morphAttributes[ key ];\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = attributeArray[ i ];\n\n\t\t\t\tvar attributeData = attribute.toJSON();\n\n\t\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\t\tarray.push( attributeData );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar name, i, l;\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = source.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { BufferGeometry };\n"]},"metadata":{},"sourceType":"module"}