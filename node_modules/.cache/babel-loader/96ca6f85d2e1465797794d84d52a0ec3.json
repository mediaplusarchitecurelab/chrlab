{"ast":null,"code":"import * as THREE from 'three';\nimport * as dat from 'dat.gui';\nexport default (scene => {\n  const maxParticleCount = 1000;\n  const particleCount = 100;\n  const r = 800;\n  const rHalf = r / 2;\n  const effectController = {\n    showDots: true,\n    showLines: true,\n    minDistance: 150,\n    limitConnections: false,\n    maxConnections: 20,\n    particleCount: 200\n  };\n  const group = new THREE.Group();\n  const customContainer = document.getElementById('canvas-gui-container');\n  var particles;\n  var particlesData = [];\n  var positions, colors;\n  var pointCloud;\n  var particlePositions;\n  var linesMesh;\n  var gui = new dat.GUI({\n    autoPlace: false\n  }); // =========CONSTANT==========\n  // GUI\n\n  function initGUI() {\n    gui.add(effectController, \"showDots\").onChange(function (value) {\n      pointCloud.visible = value;\n    });\n    gui.add(effectController, \"showLines\").onChange(function (value) {\n      linesMesh.visible = value;\n    });\n    gui.add(effectController, \"minDistance\", 10, 300);\n    gui.add(effectController, \"limitConnections\");\n    gui.add(effectController, \"maxConnections\", 0, 30, 1);\n    customContainer.appendChild(gui.domElement);\n  } // =========EXCUTE==========\n\n\n  init();\n\n  function init() {\n    initGUI();\n    const helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxBufferGeometry(r, r, r)));\n    helper.material.color.setHex(0x101010);\n    helper.material.blending = THREE.AdditiveBlending;\n    helper.material.transparent = true;\n    group.add(helper);\n    scene.add(group);\n    const segments = maxParticleCount * maxParticleCount;\n    positions = new Float32Array(segments * 3);\n    colors = new Float32Array(segments * 3);\n    var pMaterial = new THREE.PointsMaterial({\n      color: 0xFFFFFF,\n      size: 3,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      sizeAttenuation: false\n    });\n    particles = new THREE.BufferGeometry();\n    particlePositions = new Float32Array(maxParticleCount * 3);\n\n    for (var i = 0; i < maxParticleCount; i++) {\n      var x = Math.random() * r - r / 2;\n      var y = Math.random() * r - r / 2;\n      var z = Math.random() * r - r / 2;\n      particlePositions[i * 3] = x;\n      particlePositions[i * 3 + 1] = y;\n      particlePositions[i * 3 + 2] = z; // add it to the geometry\n\n      particlesData.push({\n        velocity: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2),\n        numConnections: 0\n      });\n    }\n\n    particles.setDrawRange(0, particleCount);\n    particles.addAttribute('position', new THREE.BufferAttribute(particlePositions, 3).setDynamic(true)); // create the particle system\n\n    pointCloud = new THREE.Points(particles, pMaterial);\n    group.add(pointCloud);\n    const geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3).setDynamic(true));\n    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3).setDynamic(true));\n    geometry.computeBoundingSphere();\n    geometry.setDrawRange(0, 0);\n    const material = new THREE.LineBasicMaterial({\n      vertexColors: THREE.VertexColors,\n      blending: THREE.AdditiveBlending,\n      transparent: true\n    });\n    linesMesh = new THREE.LineSegments(geometry, material);\n    group.add(linesMesh);\n    /*\r\n    var geometry = new THREE.BufferGeometry();\r\n      // ============ATTRIBUTES MAP================\r\n    var positions = [];\r\n    var colors = [];\r\n      // ============VIRABLE VALUE================\r\n    let color = new THREE.Color();\r\n      let n = 1000, n2 = n / 2; // particles spread in the cube\r\n      for ( let i = 0; i < particles; i ++ ) {\r\n        let x = Math.random() * n - n2;\r\n        let y = Math.random() * n - n2;\r\n        let z = Math.random() * n - n2;\r\n        positions.push( x, y, z ); \r\n          // colors\r\n        let vx = ( x / n ) + 0.5;\r\n        let vy = ( y / n ) + 0.5;\r\n        let vz = ( z / n ) + 0.5;\r\n        color.setRGB( vx, vy, vz );\r\n        colors.push( color.r, color.g, color.b );\r\n     }\r\n    \r\n    geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\r\n    geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\r\n      geometry.computeBoundingSphere();\r\n      let material = new THREE.PointsMaterial({\r\n        size: 15, vertexColors: THREE.VertexColors }\r\n     );\r\n      let points = new THREE.Points( geometry, material );\r\n    scene.add( points );\r\n    */\n  }\n  /*    \r\n      function deformGeometry(geometry) {\r\n          for (let i=0; i<geometry.vertices.length; i+=2) {\r\n              const scalar = 1 + Math.random()*0.8;\r\n              geometry.vertices[i].multiplyScalar(scalar)\r\n          }\r\n  \r\n          return geometry;\r\n      }\r\n  */\n\n\n  function update(time) {\n    var vertexpos = 0;\n    var colorpos = 0;\n    var numConnected = 0;\n\n    for (var k = 0; k < particleCount; k++) {\n      particlesData[k].numConnections = 0;\n    }\n\n    for (var i = 0; i < particleCount; i++) {\n      // get the particle\n      var particleData = particlesData[i];\n      particlePositions[i * 3] += particleData.velocity.x;\n      particlePositions[i * 3 + 1] += particleData.velocity.y;\n      particlePositions[i * 3 + 2] += particleData.velocity.z;\n      if (particlePositions[i * 3 + 1] < -rHalf || particlePositions[i * 3 + 1] > rHalf) particleData.velocity.y = -particleData.velocity.y;\n      if (particlePositions[i * 3] < -rHalf || particlePositions[i * 3] > rHalf) particleData.velocity.x = -particleData.velocity.x;\n      if (particlePositions[i * 3 + 2] < -rHalf || particlePositions[i * 3 + 2] > rHalf) particleData.velocity.z = -particleData.velocity.z;\n      if (effectController.limitConnections && particleData.numConnections >= effectController.maxConnections) continue; // Check collision\n\n      for (var j = i + 1; j < particleCount; j++) {\n        var particleDataB = particlesData[j];\n        if (effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections) continue;\n        var dx = particlePositions[i * 3] - particlePositions[j * 3];\n        var dy = particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];\n        var dz = particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];\n        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n        if (dist < effectController.minDistance) {\n          particleData.numConnections++;\n          particleDataB.numConnections++;\n          var alpha = 1.0 - dist / effectController.minDistance;\n          positions[vertexpos++] = particlePositions[i * 3];\n          positions[vertexpos++] = particlePositions[i * 3 + 1];\n          positions[vertexpos++] = particlePositions[i * 3 + 2];\n          positions[vertexpos++] = particlePositions[j * 3];\n          positions[vertexpos++] = particlePositions[j * 3 + 1];\n          positions[vertexpos++] = particlePositions[j * 3 + 2];\n          colors[colorpos++] = alpha;\n          colors[colorpos++] = alpha;\n          colors[colorpos++] = alpha;\n          colors[colorpos++] = alpha;\n          colors[colorpos++] = alpha;\n          colors[colorpos++] = alpha;\n          numConnected++;\n        }\n      }\n    }\n\n    linesMesh.geometry.setDrawRange(0, numConnected * 2);\n    linesMesh.geometry.attributes.position.needsUpdate = true;\n    linesMesh.geometry.attributes.color.needsUpdate = true;\n    pointCloud.geometry.attributes.position.needsUpdate = true; //requestAnimationFrame( update );\n  }\n  /*\r\n  let positions = particles.geometry.attributes.position.array;\r\n  let scales = particles.geometry.attributes.scale.array;\r\n  //let colors = particles.geometry.attributes.color.array;\r\n    //let color = new THREE.Color();\r\n  let i = 0, j = 0;\r\n  for ( var ix = 0; ix < AMOUNTX; ix ++ ) {\r\n      for ( var iy = 0; iy < AMOUNTY; iy ++ ) {\r\n          // ========================= MOTION Y =========================\r\n          positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 150 ) +\r\n                          ( Math.sin( ( iy + count ) * 0.5 ) * 150 );\r\n          scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 5 +\r\n                          ( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 5;\r\n            //color.setHSL( i / numParticles / 2, 1.0, 0.5 );\r\n            //colors[ i ] = Math.sin(iy + count ); \r\n            i += 3;\r\n          j ++;\r\n      }\r\n  }\r\n  particles.geometry.attributes.position.needsUpdate = true;\r\n  particles.geometry.attributes.scale.needsUpdate = true;\r\n  particles.geometry.attributes.color.needsUpdate = true;\r\n  count += 0.05;\r\n  */\n\n\n  return {\n    update\n  };\n});","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/Artaskjs/threejs/SceneSubject.js"],"names":["THREE","dat","scene","maxParticleCount","particleCount","r","rHalf","effectController","showDots","showLines","minDistance","limitConnections","maxConnections","group","Group","customContainer","document","getElementById","particles","particlesData","positions","colors","pointCloud","particlePositions","linesMesh","gui","GUI","autoPlace","initGUI","add","onChange","value","visible","appendChild","domElement","init","helper","BoxHelper","Mesh","BoxBufferGeometry","material","color","setHex","blending","AdditiveBlending","transparent","segments","Float32Array","pMaterial","PointsMaterial","size","sizeAttenuation","BufferGeometry","i","x","Math","random","y","z","push","velocity","Vector3","numConnections","setDrawRange","addAttribute","BufferAttribute","setDynamic","Points","geometry","computeBoundingSphere","LineBasicMaterial","vertexColors","VertexColors","LineSegments","update","time","vertexpos","colorpos","numConnected","k","particleData","j","particleDataB","dx","dy","dz","dist","sqrt","alpha","attributes","position","needsUpdate"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\r\nimport * as dat from 'dat.gui';\r\n\r\nexport default scene => {\r\n    const maxParticleCount = 1000;\r\n    const particleCount = 100;\r\n    const r = 800;\r\n    const rHalf = r / 2;\r\n    const effectController = {\r\n                showDots: true,\r\n                showLines: true,\r\n                minDistance: 150,\r\n                limitConnections: false,\r\n                maxConnections: 20,\r\n                particleCount: 200\r\n        };\r\n    const group = new THREE.Group();\r\n    const customContainer = document.getElementById('canvas-gui-container');\r\n\r\n    var particles;\r\n    var particlesData = [];\r\n    var positions, colors;\r\n    var pointCloud;\r\n    var particlePositions;\r\n    var linesMesh;\r\n    var gui = new dat.GUI({ autoPlace: false }); \r\n\r\n    // =========CONSTANT==========\r\n    // GUI\r\n    function initGUI() {\r\n        gui.add( effectController, \"showDots\" ).onChange( function ( value ) {\r\n            pointCloud.visible = value;\r\n            } );\r\n        gui.add( effectController, \"showLines\" ).onChange( function ( value ) {\r\n            linesMesh.visible = value;\r\n            } );\r\n        gui.add( effectController, \"minDistance\", 10, 300 );\r\n        gui.add( effectController, \"limitConnections\" );\r\n        gui.add( effectController, \"maxConnections\", 0, 30, 1 );\r\n                    \r\n        customContainer.appendChild(gui.domElement);                \r\n    }\r\n\r\n    // =========EXCUTE==========\r\n    init();\r\n\r\n    function init() {\r\n        initGUI();\r\n\r\n        const helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxBufferGeometry( r, r, r ) ) );\r\n        helper.material.color.setHex( 0x101010 );\r\n        helper.material.blending = THREE.AdditiveBlending;\r\n        helper.material.transparent = true;\r\n        group.add( helper );\r\n        scene.add( group );\r\n\r\n        const segments = maxParticleCount * maxParticleCount;\r\n\r\n        positions = new Float32Array( segments * 3 );\r\n        colors = new Float32Array( segments * 3 );\r\n        var pMaterial = new THREE.PointsMaterial( {\r\n                    color: 0xFFFFFF,\r\n                    size: 3,\r\n                    blending: THREE.AdditiveBlending,\r\n                    transparent: true,\r\n                    sizeAttenuation: false\r\n                } );\r\n        particles = new THREE.BufferGeometry();\r\n        particlePositions = new Float32Array( maxParticleCount * 3 );\r\n\r\n        for ( var i = 0; i < maxParticleCount; i ++ ) {\r\n                    var x = Math.random() * r - r / 2;\r\n                    var y = Math.random() * r - r / 2;\r\n                    var z = Math.random() * r - r / 2;\r\n                    particlePositions[ i * 3 ] = x;\r\n                    particlePositions[ i * 3 + 1 ] = y;\r\n                    particlePositions[ i * 3 + 2 ] = z;\r\n                    // add it to the geometry\r\n                    particlesData.push( {\r\n                        velocity: new THREE.Vector3( - 1 + Math.random() * 2, - 1 + Math.random() * 2, - 1 + Math.random() * 2 ),\r\n                        numConnections: 0\r\n                    } );\r\n                }\r\n        \r\n        particles.setDrawRange( 0, particleCount );\r\n        particles.addAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setDynamic( true ) );\r\n        \r\n        // create the particle system\r\n        pointCloud = new THREE.Points( particles, pMaterial );\r\n        group.add( pointCloud );\r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setDynamic( true ) );\r\n        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setDynamic( true ) );\r\n        geometry.computeBoundingSphere();\r\n        geometry.setDrawRange( 0, 0 );\r\n        const material = new THREE.LineBasicMaterial( {\r\n                    vertexColors: THREE.VertexColors,\r\n                    blending: THREE.AdditiveBlending,\r\n                    transparent: true\r\n                } );\r\n        linesMesh = new THREE.LineSegments( geometry, material );\r\n        group.add( linesMesh );\r\n\r\n\r\n        /*\r\n        var geometry = new THREE.BufferGeometry();\r\n\r\n        // ============ATTRIBUTES MAP================\r\n        var positions = [];\r\n        var colors = [];\r\n\r\n        // ============VIRABLE VALUE================\r\n        let color = new THREE.Color();\r\n\r\n        let n = 1000, n2 = n / 2; // particles spread in the cube\r\n\r\n        for ( let i = 0; i < particles; i ++ ) {\r\n            let x = Math.random() * n - n2;\r\n            let y = Math.random() * n - n2;\r\n            let z = Math.random() * n - n2;\r\n            positions.push( x, y, z ); \r\n\r\n            // colors\r\n            let vx = ( x / n ) + 0.5;\r\n            let vy = ( y / n ) + 0.5;\r\n            let vz = ( z / n ) + 0.5;\r\n            color.setRGB( vx, vy, vz );\r\n            colors.push( color.r, color.g, color.b );\r\n         }\r\n        \r\n        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\r\n        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\r\n\r\n        geometry.computeBoundingSphere();\r\n\r\n        let material = new THREE.PointsMaterial({\r\n            size: 15, vertexColors: THREE.VertexColors }\r\n         );\r\n\r\n        let points = new THREE.Points( geometry, material );\r\n        scene.add( points );\r\n        */\r\n    }\r\n/*    \r\n    function deformGeometry(geometry) {\r\n        for (let i=0; i<geometry.vertices.length; i+=2) {\r\n            const scalar = 1 + Math.random()*0.8;\r\n            geometry.vertices[i].multiplyScalar(scalar)\r\n        }\r\n\r\n        return geometry;\r\n    }\r\n*/\r\n    function update(time) {\r\n        \r\n        var vertexpos = 0;\r\n                var colorpos = 0;\r\n                var numConnected = 0;\r\n                for ( var k = 0; k < particleCount; k ++ ) { particlesData[ k ].numConnections = 0; }\r\n                for ( var i = 0; i < particleCount; i ++ ) {\r\n                    // get the particle\r\n                    var particleData = particlesData[ i ];\r\n                    particlePositions[ i * 3 ] += particleData.velocity.x;\r\n                    particlePositions[ i * 3 + 1 ] += particleData.velocity.y;\r\n                    particlePositions[ i * 3 + 2 ] += particleData.velocity.z;\r\n                    if ( particlePositions[ i * 3 + 1 ] < - rHalf || particlePositions[ i * 3 + 1 ] > rHalf )\r\n                        particleData.velocity.y = - particleData.velocity.y;\r\n                    if ( particlePositions[ i * 3 ] < - rHalf || particlePositions[ i * 3 ] > rHalf )\r\n                        particleData.velocity.x = - particleData.velocity.x;\r\n                    if ( particlePositions[ i * 3 + 2 ] < - rHalf || particlePositions[ i * 3 + 2 ] > rHalf )\r\n                        particleData.velocity.z = - particleData.velocity.z;\r\n                    if ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )\r\n                        continue;\r\n                    // Check collision\r\n                    for ( var j = i + 1; j < particleCount; j ++ ) {\r\n                        var particleDataB = particlesData[ j ];\r\n                        if ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )\r\n                            continue;\r\n                        var dx = particlePositions[ i * 3 ] - particlePositions[ j * 3 ];\r\n                        var dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];\r\n                        var dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];\r\n                        var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );\r\n                        if ( dist < effectController.minDistance ) {\r\n                            particleData.numConnections ++;\r\n                            particleDataB.numConnections ++;\r\n                            var alpha = 1.0 - dist / effectController.minDistance;\r\n                            positions[ vertexpos ++ ] = particlePositions[ i * 3 ];\r\n                            positions[ vertexpos ++ ] = particlePositions[ i * 3 + 1 ];\r\n                            positions[ vertexpos ++ ] = particlePositions[ i * 3 + 2 ];\r\n                            positions[ vertexpos ++ ] = particlePositions[ j * 3 ];\r\n                            positions[ vertexpos ++ ] = particlePositions[ j * 3 + 1 ];\r\n                            positions[ vertexpos ++ ] = particlePositions[ j * 3 + 2 ];\r\n                            colors[ colorpos ++ ] = alpha;\r\n                            colors[ colorpos ++ ] = alpha;\r\n                            colors[ colorpos ++ ] = alpha;\r\n                            colors[ colorpos ++ ] = alpha;\r\n                            colors[ colorpos ++ ] = alpha;\r\n                            colors[ colorpos ++ ] = alpha;\r\n                            numConnected ++;\r\n                        }\r\n                    }\r\n                }\r\n                linesMesh.geometry.setDrawRange( 0, numConnected * 2 );\r\n                linesMesh.geometry.attributes.position.needsUpdate = true;\r\n                linesMesh.geometry.attributes.color.needsUpdate = true;\r\n                pointCloud.geometry.attributes.position.needsUpdate = true;\r\n                //requestAnimationFrame( update );\r\n            }\r\n\r\n        /*\r\n        let positions = particles.geometry.attributes.position.array;\r\n        let scales = particles.geometry.attributes.scale.array;\r\n        //let colors = particles.geometry.attributes.color.array;\r\n\r\n        //let color = new THREE.Color();\r\n        let i = 0, j = 0;\r\n        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {\r\n            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {\r\n                // ========================= MOTION Y =========================\r\n                positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 150 ) +\r\n                                ( Math.sin( ( iy + count ) * 0.5 ) * 150 );\r\n                scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 5 +\r\n                                ( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 5;\r\n\r\n                //color.setHSL( i / numParticles / 2, 1.0, 0.5 );\r\n\r\n                //colors[ i ] = Math.sin(iy + count ); \r\n\r\n                i += 3;\r\n                j ++;\r\n            }\r\n        }\r\n        particles.geometry.attributes.position.needsUpdate = true;\r\n        particles.geometry.attributes.scale.needsUpdate = true;\r\n        particles.geometry.attributes.color.needsUpdate = true;\r\n        count += 0.05;\r\n        */\r\n\r\n    return {\r\n        update\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}