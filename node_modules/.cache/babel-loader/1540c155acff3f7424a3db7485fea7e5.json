{"ast":null,"code":"import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction AnimationMixer(root) {\n  this._root = root;\n\n  this._initMemoryManager();\n\n  this._accuIndex = 0;\n  this.time = 0;\n  this.timeScale = 1.0;\n}\n\nAnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: AnimationMixer,\n  _bindAction: function (action, prototypeAction) {\n    var root = action._localRoot || this._root,\n        tracks = action._clip.tracks,\n        nTracks = tracks.length,\n        bindings = action._propertyBindings,\n        interpolants = action._interpolants,\n        rootUuid = root.uuid,\n        bindingsByRoot = this._bindingsByRootAndName,\n        bindingsByName = bindingsByRoot[rootUuid];\n\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n\n    for (var i = 0; i !== nTracks; ++i) {\n      var track = tracks[i],\n          trackName = track.name,\n          binding = bindingsByName[trackName];\n\n      if (binding !== undefined) {\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n\n          continue;\n        }\n\n        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n\n        this._addInactiveBinding(binding, rootUuid, trackName);\n\n        bindings[i] = binding;\n      }\n\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  },\n  _activateAction: function (action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n        var rootUuid = (action._localRoot || this._root).uuid,\n            clipUuid = action._clip.uuid,\n            actionsForClip = this._actionsByClip[clipUuid];\n\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n\n      var bindings = action._propertyBindings; // increment reference counts / sort out state\n\n      for (var i = 0, n = bindings.length; i !== n; ++i) {\n        var binding = bindings[i];\n\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n\n          binding.saveOriginalState();\n        }\n      }\n\n      this._lendAction(action);\n    }\n  },\n  _deactivateAction: function (action) {\n    if (this._isActiveAction(action)) {\n      var bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n      for (var i = 0, n = bindings.length; i !== n; ++i) {\n        var binding = bindings[i];\n\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n\n          this._takeBackBinding(binding);\n        }\n      }\n\n      this._takeBackAction(action);\n    }\n  },\n  // Memory manager\n  _initMemoryManager: function () {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n\n    this._nActiveActions = 0;\n    this._actionsByClip = {}; // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n\n    this._nActiveControlInterpolants = 0;\n    var scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n\n        get inUse() {\n          return scope._nActiveActions;\n        }\n\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n\n      }\n    };\n  },\n  // Memory management for AnimationAction objects\n  _isActiveAction: function (action) {\n    var index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  },\n  _addInactiveAction: function (action, clipUuid, rootUuid) {\n    var actions = this._actions,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      var knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  },\n  _removeInactiveAction: function (action) {\n    var actions = this._actions,\n        lastInactiveAction = actions[actions.length - 1],\n        cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    var clipUuid = action._clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[clipUuid],\n        knownActionsForClip = actionsForClip.knownActions,\n        lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n        byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    var actionByRoot = actionsForClip.actionByRoot,\n        rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n\n    this._removeInactiveBindingsForAction(action);\n  },\n  _removeInactiveBindingsForAction: function (action) {\n    var bindings = action._propertyBindings;\n\n    for (var i = 0, n = bindings.length; i !== n; ++i) {\n      var binding = bindings[i];\n\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  },\n  _lendAction: function (action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n    var actions = this._actions,\n        prevIndex = action._cacheIndex,\n        lastActiveIndex = this._nActiveActions++,\n        firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  },\n  _takeBackAction: function (action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n    var actions = this._actions,\n        prevIndex = action._cacheIndex,\n        firstInactiveIndex = --this._nActiveActions,\n        lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  },\n  // Memory management for PropertyMixer objects\n  _addInactiveBinding: function (binding, rootUuid, trackName) {\n    var bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[rootUuid],\n        bindings = this._bindings;\n\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  },\n  _removeInactiveBinding: function (binding) {\n    var bindings = this._bindings,\n        propBinding = binding.binding,\n        rootUuid = propBinding.rootNode.uuid,\n        trackName = propBinding.path,\n        bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[rootUuid],\n        lastInactiveBinding = bindings[bindings.length - 1],\n        cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  },\n  _lendBinding: function (binding) {\n    var bindings = this._bindings,\n        prevIndex = binding._cacheIndex,\n        lastActiveIndex = this._nActiveBindings++,\n        firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  },\n  _takeBackBinding: function (binding) {\n    var bindings = this._bindings,\n        prevIndex = binding._cacheIndex,\n        firstInactiveIndex = --this._nActiveBindings,\n        lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  },\n  // Memory management of Interpolants for weight and time scale\n  _lendControlInterpolant: function () {\n    var interpolants = this._controlInterpolants,\n        lastActiveIndex = this._nActiveControlInterpolants++,\n        interpolant = interpolants[lastActiveIndex];\n\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n\n    return interpolant;\n  },\n  _takeBackControlInterpolant: function (interpolant) {\n    var interpolants = this._controlInterpolants,\n        prevIndex = interpolant.__cacheIndex,\n        firstInactiveIndex = --this._nActiveControlInterpolants,\n        lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  },\n  _controlInterpolantsResultBuffer: new Float32Array(1),\n  // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n  clipAction: function (clip, optionalRoot) {\n    var root = optionalRoot || this._root,\n        rootUuid = root.uuid,\n        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n        clipUuid = clipObject !== null ? clipObject.uuid : clip,\n        actionsForClip = this._actionsByClip[clipUuid],\n        prototypeAction = null;\n\n    if (actionsForClip !== undefined) {\n      var existingAction = actionsForClip.actionByRoot[rootUuid];\n\n      if (existingAction !== undefined) {\n        return existingAction;\n      } // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n\n\n      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    } // clip must be known when specified via string\n\n\n    if (clipObject === null) return null; // allocate all resources required to run it\n\n    var newAction = new AnimationAction(this, clipObject, optionalRoot);\n\n    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n    return newAction;\n  },\n  // get an existing action\n  existingAction: function (clip, optionalRoot) {\n    var root = optionalRoot || this._root,\n        rootUuid = root.uuid,\n        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n        clipUuid = clipObject ? clipObject.uuid : clip,\n        actionsForClip = this._actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n\n    return null;\n  },\n  // deactivates all previously scheduled actions\n  stopAllAction: function () {\n    var actions = this._actions,\n        nActions = this._nActiveActions,\n        bindings = this._bindings,\n        nBindings = this._nActiveBindings;\n    this._nActiveActions = 0;\n    this._nActiveBindings = 0;\n\n    for (var i = 0; i !== nActions; ++i) {\n      actions[i].reset();\n    }\n\n    for (var i = 0; i !== nBindings; ++i) {\n      bindings[i].useCount = 0;\n    }\n\n    return this;\n  },\n  // advance the time and update apply the animation\n  update: function (deltaTime) {\n    deltaTime *= this.timeScale;\n    var actions = this._actions,\n        nActions = this._nActiveActions,\n        time = this.time += deltaTime,\n        timeDirection = Math.sign(deltaTime),\n        accuIndex = this._accuIndex ^= 1; // run active actions\n\n    for (var i = 0; i !== nActions; ++i) {\n      var action = actions[i];\n\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    } // update scene graph\n\n\n    var bindings = this._bindings,\n        nBindings = this._nActiveBindings;\n\n    for (var i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n\n    return this;\n  },\n  // Allows you to seek to a specific time in an animation.\n  setTime: function (timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n\n    for (var i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  },\n  // return this mixer's root target object\n  getRoot: function () {\n    return this._root;\n  },\n  // free all resources specific to a particular clip\n  uncacheClip: function (clip) {\n    var actions = this._actions,\n        clipUuid = clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n      var actionsToRemove = actionsForClip.knownActions;\n\n      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        var action = actionsToRemove[i];\n\n        this._deactivateAction(action);\n\n        var cacheIndex = action._cacheIndex,\n            lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n\n        this._removeInactiveBindingsForAction(action);\n      }\n\n      delete actionsByClip[clipUuid];\n    }\n  },\n  // free all resources specific to a particular root target object\n  uncacheRoot: function (root) {\n    var rootUuid = root.uuid,\n        actionsByClip = this._actionsByClip;\n\n    for (var clipUuid in actionsByClip) {\n      var actionByRoot = actionsByClip[clipUuid].actionByRoot,\n          action = actionByRoot[rootUuid];\n\n      if (action !== undefined) {\n        this._deactivateAction(action);\n\n        this._removeInactiveAction(action);\n      }\n    }\n\n    var bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName !== undefined) {\n      for (var trackName in bindingByName) {\n        var binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n\n        this._removeInactiveBinding(binding);\n      }\n    }\n  },\n  // remove a targeted clip from the cache\n  uncacheAction: function (clip, optionalRoot) {\n    var action = this.existingAction(clip, optionalRoot);\n\n    if (action !== null) {\n      this._deactivateAction(action);\n\n      this._removeInactiveAction(action);\n    }\n  }\n});\nexport { AnimationMixer };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/animation/AnimationMixer.js"],"names":["AnimationAction","EventDispatcher","LinearInterpolant","PropertyBinding","PropertyMixer","AnimationClip","AnimationMixer","root","_root","_initMemoryManager","_accuIndex","time","timeScale","prototype","Object","assign","create","constructor","_bindAction","action","prototypeAction","_localRoot","tracks","_clip","nTracks","length","bindings","_propertyBindings","interpolants","_interpolants","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","i","track","trackName","name","binding","_cacheIndex","referenceCount","_addInactiveBinding","path","parsedPath","ValueTypeName","getValueSize","resultBuffer","buffer","_activateAction","_isActiveAction","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","useCount","_lendBinding","saveOriginalState","_lendAction","_deactivateAction","restoreOriginalState","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","_byClipCacheIndex","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","keys","firstInactiveBinding","lastActiveBinding","_lendControlInterpolant","interpolant","Float32Array","_controlInterpolantsResultBuffer","__cacheIndex","_takeBackControlInterpolant","lastActiveInterpolant","clipAction","clip","optionalRoot","clipObject","findByName","existingAction","newAction","stopAllAction","nActions","nBindings","reset","update","deltaTime","timeDirection","Math","sign","accuIndex","_update","apply","setTime","timeInSeconds","getRoot","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction"],"mappings":"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","sourcesContent":["import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction AnimationMixer( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n}\n\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: AnimationMixer,\n\n\t_bindAction: function ( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function ( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function ( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function () {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction: function ( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function ( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function ( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function ( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function () {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function ( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function ( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function () {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function ( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime: function ( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( var i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function () {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function ( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function ( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { AnimationMixer };\n"]},"metadata":{},"sourceType":"module"}