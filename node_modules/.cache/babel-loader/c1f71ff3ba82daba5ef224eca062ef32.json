{"ast":null,"code":"/**\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { MathUtils } from '../math/MathUtils.js'; // LatheGeometry\n\nfunction LatheGeometry(points, segments, phiStart, phiLength) {\n  Geometry.call(this);\n  this.type = 'LatheGeometry';\n  this.parameters = {\n    points: points,\n    segments: segments,\n    phiStart: phiStart,\n    phiLength: phiLength\n  };\n  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));\n  this.mergeVertices();\n}\n\nLatheGeometry.prototype = Object.create(Geometry.prototype);\nLatheGeometry.prototype.constructor = LatheGeometry; // LatheBufferGeometry\n\nfunction LatheBufferGeometry(points, segments, phiStart, phiLength) {\n  BufferGeometry.call(this);\n  this.type = 'LatheBufferGeometry';\n  this.parameters = {\n    points: points,\n    segments: segments,\n    phiStart: phiStart,\n    phiLength: phiLength\n  };\n  segments = Math.floor(segments) || 12;\n  phiStart = phiStart || 0;\n  phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]\n\n  phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers\n\n  var indices = [];\n  var vertices = [];\n  var uvs = []; // helper variables\n\n  var base;\n  var inverseSegments = 1.0 / segments;\n  var vertex = new Vector3();\n  var uv = new Vector2();\n  var i, j; // generate vertices and uvs\n\n  for (i = 0; i <= segments; i++) {\n    var phi = phiStart + i * inverseSegments * phiLength;\n    var sin = Math.sin(phi);\n    var cos = Math.cos(phi);\n\n    for (j = 0; j <= points.length - 1; j++) {\n      // vertex\n      vertex.x = points[j].x * sin;\n      vertex.y = points[j].y;\n      vertex.z = points[j].x * cos;\n      vertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n      uv.x = i / segments;\n      uv.y = j / (points.length - 1);\n      uvs.push(uv.x, uv.y);\n    }\n  } // indices\n\n\n  for (i = 0; i < segments; i++) {\n    for (j = 0; j < points.length - 1; j++) {\n      base = j + i * points.length;\n      var a = base;\n      var b = base + points.length;\n      var c = base + points.length + 1;\n      var d = base + 1; // faces\n\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals\n\n  this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.\n  // because the corresponding vertices are identical (but still have different UVs).\n\n  if (phiLength === Math.PI * 2) {\n    var normals = this.attributes.normal.array;\n    var n1 = new Vector3();\n    var n2 = new Vector3();\n    var n = new Vector3(); // this is the buffer offset for the last line of vertices\n\n    base = segments * points.length * 3;\n\n    for (i = 0, j = 0; i < points.length; i++, j += 3) {\n      // select the normal of the vertex in the first line\n      n1.x = normals[j + 0];\n      n1.y = normals[j + 1];\n      n1.z = normals[j + 2]; // select the normal of the vertex in the last line\n\n      n2.x = normals[base + j + 0];\n      n2.y = normals[base + j + 1];\n      n2.z = normals[base + j + 2]; // average normals\n\n      n.addVectors(n1, n2).normalize(); // assign the new values to both normals\n\n      normals[j + 0] = normals[base + j + 0] = n.x;\n      normals[j + 1] = normals[base + j + 1] = n.y;\n      normals[j + 2] = normals[base + j + 2] = n.z;\n    }\n  }\n}\n\nLatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\nexport { LatheGeometry, LatheBufferGeometry };","map":{"version":3,"sources":["D:/chrlab/src/component/panelComponent/Canvas/threejs/src/geometries/LatheGeometry.js"],"names":["Geometry","Float32BufferAttribute","BufferGeometry","Vector3","Vector2","MathUtils","LatheGeometry","points","segments","phiStart","phiLength","call","type","parameters","fromBufferGeometry","LatheBufferGeometry","mergeVertices","prototype","Object","create","constructor","Math","floor","PI","clamp","indices","vertices","uvs","base","inverseSegments","vertex","uv","i","j","phi","sin","cos","length","x","y","z","push","a","b","c","d","setIndex","setAttribute","computeVertexNormals","normals","attributes","normal","array","n1","n2","n","addVectors","normalize"],"mappings":"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","sourcesContent":["/**\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\n// LatheGeometry\n\nfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n}\n\nLatheGeometry.prototype = Object.create( Geometry.prototype );\nLatheGeometry.prototype.constructor = LatheGeometry;\n\n// LatheBufferGeometry\n\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\n\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar base;\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif ( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new Vector3();\n\t\tvar n2 = new Vector3();\n\t\tvar n = new Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\n\t\tbase = segments * points.length * 3;\n\n\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t}\n\n\t}\n\n}\n\nLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\nexport { LatheGeometry, LatheBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}