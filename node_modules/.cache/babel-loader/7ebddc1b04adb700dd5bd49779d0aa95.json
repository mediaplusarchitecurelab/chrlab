{"ast":null,"code":"/**\n * @author Nikos M. / https://github.com/foo123/\n */\nimport { DataTextureLoader, FloatType, HalfFloatType, LinearEncoding, LinearFilter, NearestFilter, RGBEEncoding, RGBEFormat, RGBFormat, UnsignedByteType } from \"../../../build/three.module.js\"; // https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = UnsignedByteType;\n};\n\nRGBELoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: RGBELoader,\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse: function (buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error(\"RGBELoader Read Error: \" + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error(\"RGBELoader Write Error: \" + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error(\"RGBELoader Bad File Format: \" + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error(\"RGBELoader: Error: \" + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = \"\\n\",\n        fgets = function (buffer, lineLimit, consume) {\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunkSize = 128,\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        \tbyteCode = m.charCodeAt(i);\n        \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      var line,\n          match,\n          // regexes to parse header info fields\n      magic_token_re = /^#\\?(\\S+)$/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0,\n\n        /* indicate which fields are valid */\n        string: '',\n\n        /* the actual header string */\n        comments: '',\n\n        /* comments found in header */\n        programtype: 'RGBE',\n\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        format: '',\n\n        /* RGBE format, default 32-bit_rle_rgbe */\n        gamma: 1.0,\n\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        exposure: 1.0,\n\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, \"no header found\");\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, \"bad initial token\");\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + \"\\n\";\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + \"\\n\";\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + \"\\n\";\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, \"missing format specifier\");\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      var data_rgba,\n          offset,\n          pos,\n          count,\n          byteValue,\n          scanline_buffer,\n          ptr,\n          ptr_end,\n          i,\n          l,\n          off,\n          isEncodedRun,\n          scanline_width = w,\n          num_scanlines = h,\n          rgbeStart;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n      }\n\n      data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba || !data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n      }\n\n      offset = 0;\n      pos = 0;\n      ptr_end = 4 * scanline_width;\n      rgbeStart = new Uint8Array(4);\n      scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        ptr = 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, \"bad scanline data\");\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            byteValue = buffer[pos++];\n\n            for (i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        l = scanline_width; //scanline_buffer.byteLength;\n\n        for (i = 0; i < l; i++) {\n          off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function () {\n      // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n      var floatView = new Float32Array(1);\n      var int32View = new Int32Array(floatView.buffer);\n      /* This method is faster than the OpenEXR implementation (very often\n       * used, eg. in Ogre), with the additional benefit of rounding, inspired\n       * by James Tursa?s half-precision code. */\n\n      function toHalf(val) {\n        floatView[0] = val;\n        var x = int32View[0];\n        var bits = x >> 16 & 0x8000;\n        /* Get the sign */\n\n        var m = x >> 12 & 0x07ff;\n        /* Keep one extra bit for rounding */\n\n        var e = x >> 23 & 0xff;\n        /* Using int is faster here */\n\n        /* If zero, or denormal, or exponent underflows too much for a denormal\n         * half, return signed zero. */\n\n        if (e < 103) return bits;\n        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n        if (e > 142) {\n          bits |= 0x7c00;\n          /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n          \t\t * not Inf, so make sure we set one mantissa bit too. */\n\n          bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n          return bits;\n        }\n        /* If exponent underflows but not too much, return a denormal */\n\n\n        if (e < 113) {\n          m |= 0x0800;\n          /* Extra rounding may overflow and set mantissa to 0 and exponent\n           * to 1, which is OK. */\n\n          bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n          return bits;\n        }\n\n        bits |= e - 112 << 10 | m >> 1;\n        /* Extra rounding. An overflow will set mantissa to 0 and increment\n         * the exponent, which is OK. */\n\n        bits += m & 1;\n        return bits;\n      }\n\n      return function (sourceArray, sourceOffset, destArray, destOffset) {\n        var e = sourceArray[sourceOffset + 3];\n        var scale = Math.pow(2.0, e - 128.0) / 255.0;\n        destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);\n        destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);\n        destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);\n      };\n    }();\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        switch (this.type) {\n          case UnsignedByteType:\n            var data = image_rgba_data;\n            var format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            var type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            var data = floatArray;\n            var format = RGBFormat;\n            var type = FloatType;\n            break;\n\n          case HalfFloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            var data = halfArray;\n            var format = RGBFormat;\n            var type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  },\n  setDataType: function (value) {\n    this.type = value;\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\nexport { RGBELoader };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/examples/jsm/loaders/RGBELoader.js"],"names":["DataTextureLoader","FloatType","HalfFloatType","LinearEncoding","LinearFilter","NearestFilter","RGBEEncoding","RGBEFormat","RGBFormat","UnsignedByteType","RGBELoader","manager","call","type","prototype","Object","assign","create","constructor","parse","buffer","RGBE_RETURN_FAILURE","rgbe_read_error","rgbe_write_error","rgbe_format_error","rgbe_memory_error","rgbe_error","rgbe_error_code","msg","console","error","RGBE_VALID_PROGRAMTYPE","RGBE_VALID_FORMAT","RGBE_VALID_DIMENSIONS","NEWLINE","fgets","lineLimit","consume","p","pos","i","len","s","chunkSize","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBE_ReadHeader","line","match","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadPixels_RLE","w","h","data_rgba","offset","count","byteValue","scanline_buffer","ptr","ptr_end","l","off","isEncodedRun","scanline_width","num_scanlines","rgbeStart","Uint8Array","set","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","floatView","Float32Array","int32View","Int32Array","toHalf","val","x","bits","m","byteArray","rgbe_header_info","image_rgba_data","data","numElements","floatArray","j","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"mappings":"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","sourcesContent":["/**\n * @author Nikos M. / https://github.com/foo123/\n */\n\nimport {\n\tDataTextureLoader,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter,\n\tNearestFilter,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBFormat,\n\tUnsignedByteType\n} from \"../../../build/three.module.js\";\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function ( manager ) {\n\n\tDataTextureLoader.call( this, manager );\n\n\tthis.type = UnsignedByteType;\n\n};\n\nRGBELoader.prototype = Object.assign( Object.create( DataTextureLoader.prototype ), {\n\n\tconstructor: RGBELoader,\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse: function ( buffer ) {\n\n\t\tvar\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( \"RGBELoader Read Error: \" + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( \"RGBELoader Write Error: \" + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( \"RGBELoader Bad File Format: \" + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( \"RGBELoader: Error: \" + ( msg || '' ) );\n\n\t\t\t\t}\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = \"\\n\",\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tvar p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '', chunkSize = 128,\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) )\n\t\t\t\t;\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\t\t\t\tvar line, match,\n\n\t\t\t\t\t// regexes to parse header info fields\n\t\t\t\t\tmagic_token_re = /^#\\?(\\S+)$/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, \"no header found\" );\n\n\t\t\t\t}\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad initial token\" );\n\n\t\t\t\t}\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + \"\\n\";\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + \"\\n\";\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + \"\\n\";\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ], 10 );\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ], 10 );\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"missing format specifier\" );\n\n\t\t\t\t}\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"missing image size specifier\" );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tvar data_rgba, offset, pos, count, byteValue,\n\t\t\t\t\tscanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun,\n\t\t\t\t\tscanline_width = w, num_scanlines = h, rgbeStart\n\t\t\t\t;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"wrong scanline width\" );\n\n\t\t\t\t}\n\n\t\t\t\tdata_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba || ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, \"unable to allocate buffer space\" );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0; pos = 0; ptr_end = 4 * scanline_width;\n\t\t\t\trgbeStart = new Uint8Array( 4 );\n\t\t\t\tscanline_buffer = new Uint8Array( ptr_end );\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad rgbe scanline format\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tisEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad scanline data\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tbyteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tl = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\toff = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tvar RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tvar e = sourceArray[ sourceOffset + 3 ];\n\t\t\tvar scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\n\t\t};\n\n\t\tvar RGBEByteToRGBHalf = ( function () {\n\n\t\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t\tvar floatView = new Float32Array( 1 );\n\t\t\tvar int32View = new Int32Array( floatView.buffer );\n\n\t\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t\t * used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t\t * by James Tursa?s half-precision code. */\n\t\t\tfunction toHalf( val ) {\n\n\t\t\t\tfloatView[ 0 ] = val;\n\t\t\t\tvar x = int32View[ 0 ];\n\n\t\t\t\tvar bits = ( x >> 16 ) & 0x8000; /* Get the sign */\n\t\t\t\tvar m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */\n\t\t\t\tvar e = ( x >> 23 ) & 0xff; /* Using int is faster here */\n\n\t\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t\t * half, return signed zero. */\n\t\t\t\tif ( e < 103 ) return bits;\n\n\t\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\t\t\tif ( e > 142 ) {\n\n\t\t\t\t\tbits |= 0x7c00;\n\t\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t\t * not Inf, so make sure we set one mantissa bit too. */\n\t\t\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\n\t\t\t\t\treturn bits;\n\n\t\t\t\t}\n\n\t\t\t\t/* If exponent underflows but not too much, return a denormal */\n\t\t\t\tif ( e < 113 ) {\n\n\t\t\t\t\tm |= 0x0800;\n\t\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t\t * to 1, which is OK. */\n\t\t\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\n\t\t\t\t\treturn bits;\n\n\t\t\t\t}\n\n\t\t\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\n\t\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t\t * the exponent, which is OK. */\n\t\t\t\tbits += m & 1;\n\t\t\t\treturn bits;\n\n\t\t\t}\n\n\t\t\treturn function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\t\tvar e = sourceArray[ sourceOffset + 3 ];\n\t\t\t\tvar scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t\tdestArray[ destOffset + 0 ] = toHalf( sourceArray[ sourceOffset + 0 ] * scale );\n\t\t\t\tdestArray[ destOffset + 1 ] = toHalf( sourceArray[ sourceOffset + 1 ] * scale );\n\t\t\t\tdestArray[ destOffset + 2 ] = toHalf( sourceArray[ sourceOffset + 2 ] * scale );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tvar rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tvar w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase UnsignedByteType:\n\n\t\t\t\t\t\tvar data = image_rgba_data;\n\t\t\t\t\t\tvar format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\t\t\t\t\t\tvar type = UnsignedByteType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tvar numElements = ( image_rgba_data.length / 4 ) * 3;\n\t\t\t\t\t\tvar floatArray = new Float32Array( numElements );\n\n\t\t\t\t\t\tfor ( var j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar data = floatArray;\n\t\t\t\t\t\tvar format = RGBFormat;\n\t\t\t\t\t\tvar type = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tvar numElements = ( image_rgba_data.length / 4 ) * 3;\n\t\t\t\t\t\tvar halfArray = new Uint16Array( numElements );\n\n\t\t\t\t\t\tfor ( var j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar data = halfArray;\n\t\t\t\t\t\tvar format = RGBFormat;\n\t\t\t\t\t\tvar type = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\tformat: format,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tsetDataType: function ( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase UnsignedByteType:\n\n\t\t\t\t\ttexture.encoding = RGBEEncoding;\n\t\t\t\t\ttexture.minFilter = NearestFilter;\n\t\t\t\t\ttexture.magFilter = NearestFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn DataTextureLoader.prototype.load.call( this, url, onLoadCallback, onProgress, onError );\n\n\t}\n\n} );\n\nexport { RGBELoader };\n"]},"metadata":{},"sourceType":"module"}