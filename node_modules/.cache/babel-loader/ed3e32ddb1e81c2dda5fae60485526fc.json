{"ast":null,"code":"import * as THREE from '../../threejs/src/Three.js'; //import SceneSubject from './SceneSubject';\n\nimport GeneralLights from './GeneralLights';\nimport * as dat from 'dat.gui';\nimport { OBJLoader } from '../../threejs/examples/jsm/loaders/OBJLoader.js';\nimport { EffectComposer } from '../../threejs/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from '../../threejs/examples/jsm/postprocessing/RenderPass.js';\nimport { FilmPass } from '../../threejs/examples/jsm/postprocessing/FilmPass.js';\nimport { BloomPass } from '../../threejs/examples/jsm/postprocessing/BloomPass.js';\nimport { ShaderPass } from '../../threejs/examples/jsm/postprocessing/ShaderPass.js';\nimport { SobelOperatorShader } from '../../threejs/examples/jsm/shaders/SobelOperatorShader.js';\nimport { OutlinePass } from '../../threejs/examples/jsm/postprocessing/OutlinePass.js'; //const glsl = require('glslify');\n\nconst OrbitControls = require('three-orbit-controls')(THREE);\n\nconst textureLoader = new THREE.TextureLoader();\nexport default (canvas => {\n  // objects\n  var geo, geoPts, geoLines, geoSelceted, backgroundcube; // material\n\n  var t1, t2, uniforms;\n  var matColor, matReflective, matShader, matWireframe, matGradient, matShaderSub, matHidden; // renderer\n\n  var composer, outlinePass; // GUI\n\n  var shading;\n  const clock = new THREE.Clock();\n  const screenDimensions = {\n    width: canvas.width,\n    height: canvas.height\n  }; // build\n\n  const scene = buildScene();\n  const camera = buildCamera(screenDimensions);\n  const renderer = buildRender(screenDimensions);\n  const controls = new OrbitControls(camera, renderer.domElement);\n  controls.target.set(0, 1, 0);\n  controls.update();\n  const lights = GeneralLights(scene); // textture\n\n  textureLoader.setPath('./assets/textures/sprites/').load('spark1.png', tex1 => {\n    //t1 = tex1;        \n    //textureLoader.setPath( './assets/textures/lava/' ).load( 'lavatile.jpg', (tex2)=>{\n    t1 = tex1;\n    uniforms = {\n      pointTexture: {\n        value: t1\n      }\n    };\n    createSceneSubjects(scene, uniforms); //},( xhr2 ) =>{\n    //    console.log( (xhr2.loaded / xhr2.total * 100) + '% loaded' );\n    //},( xhr2 ) =>{\n    //    console.log( 'An error happened' );\n    //});\n    //\n  }, xhr1 => {\n    console.log(xhr1.loaded / xhr1.total * 100 + '% loaded');\n  }, xhr1 => {\n    console.log('An error happened');\n  });\n\n  function buildScene() {\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000');\n    return scene;\n  }\n\n  function buildRender({\n    width,\n    height\n  }) {\n    const renderer = new THREE.WebGLRenderer({\n      canvas: canvas,\n      antialias: true,\n      alpha: true\n    });\n    const DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;\n    renderer.shadowMap.enabled = true;\n    renderer.localClippingEnabled = false;\n    renderer.setPixelRatio(DPR);\n    renderer.setSize(width, height);\n    renderer.autoClear = false;\n    renderer.toneMapping = THREE.ReinhardToneMapping; // post\n\n    composer = new EffectComposer(renderer); //var renderModel = new RenderPass( scene, camera );\n    //composer.addPass( renderModel );\n    //var effectFilm = new FilmPass( 0.35, 0.95, 2048, false );\n    //composer.addPass( effectFilm );   \n    //var effectBloom = new BloomPass();\n    //effectBloom.threshold = 1.5;\n    //effectBloom.strength = 1;\n    //effectBloom.radius = 1;\n    //composer.addPass( effectBloom );\n    //renderer.toneMappingExposure = Math.pow( 1.2, 4.0 );\n\n    var renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    outlinePass = new OutlinePass(new THREE.Vector2(width, height), scene, camera);\n    /*\r\n    textureLoader.load( './assets/textures/tri_pattern.jpg', ( texture )=> {\r\n            outlinePass.patternTexture = texture;\r\n            texture.wrapS = THREE.RepeatWrapping;\r\n            texture.wrapT = THREE.RepeatWrapping;\r\n        },( xhr1 ) =>{\r\n            console.log( (xhr1.loaded / xhr1.total * 100) + '% loaded' );\r\n        },( xhr1 ) =>{\r\n            console.log( 'An error happened' );\r\n        });\r\n    */\n\n    outlinePass.edgeStrength = 3.0;\n    outlinePass.edgeGlow = 0.0;\n    outlinePass.edgeThickness = 1.0;\n    outlinePass.pulsePeriod = 0;\n    outlinePass.visibleEdgeColor.set('#ff0000');\n    outlinePass.hiddenEdgeColor.set('#190a05'); //outlinePass.selectedObjects=geo;\n\n    composer.addPass(outlinePass); //var effectSobel = new ShaderPass( SobelOperatorShader );\n    //composer.addPass( effectSobel);\n\n    return renderer;\n  } // input function\n\n\n  function loadModel() {}\n\n  function onProgress(xhr) {\n    if (xhr.lengthComputable) {\n      var percentComplete = xhr.loaded / xhr.total * 100;\n      console.log('model ' + Math.round(percentComplete, 2) + '% downloaded');\n    }\n  }\n\n  function onError() {\n    console.log('error!!');\n  }\n\n  function buildCamera({\n    width,\n    height\n  }) {\n    /*\r\n    const fieldOfView = 36;\r\n    const aspectRatio = window.innerWidth / window.innerHeight;\r\n    const nearPlane = 0.25;\r\n    const farPlane = 10000; \r\n    const camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);\r\n      camera.position.set( 3, 1.3, 3 );\r\n    */\n    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);\n    camera.position.set(6, 6, 0);\n    return camera;\n  }\n\n  function createSceneSubjects(scene, uniforms) {\n    // subject\n    const customContainer = document.getElementById('canvas-gui-container');\n    var gui = new dat.GUI({\n      autoPlace: false\n    }); //var localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );\n    //var globalPlane = new THREE.Plane( new THREE.Vector3( - 1, -2, 0 ), 0.1 );\n    // material 1\n\n    matColor = new THREE.Color();\n    matColor.setRGB(0.9, 0.95, 1.0);\n    backgroundcube = new THREE.CubeTextureLoader().setPath('./assets/textures/cube/pisa/').load(['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png']);\n    matReflective = new THREE.MeshStandardMaterial({\n      color: matColor,\n      metalness: 0.1,\n      roughness: 0.1,\n      envMap: backgroundcube\n    }); // shader\n\n    const vtext = ['attribute float size;', 'varying vec3 vNormal;', 'varying vec3 vWorldPosition;', 'varying vec3 vColor;', 'void main() {', 'vColor = color;', 'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', 'gl_PointSize = size * ( 300.0 / -mvPosition.z );', 'gl_Position = projectionMatrix * mvPosition;', '}'].join('\\n');\n    const ftext = ['uniform sampler2D pointTexture;', 'varying vec3 vNormal;', 'varying vec3 vWorldPosition;', 'uniform vec3 lightPosition;', 'varying vec3 vColor;', //'varying vec3 vOpacity;',\n    'void main() {', 'vec3 lightDirection = normalize(lightPosition - vWorldPosition);', // light\n    'vec3 outgoingLight = vec3(1.0);', //'float c = 0.35 + max(0.0, dot(vNormal, lightDirection)) * 0.4 * shadowMask.x;', // shadow\n    'gl_FragColor = vec4( vColor, 1.0 );', // object\n    'gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );', // object text\n    //'gl_FragColor = gl_FragColor * vec4(vColor, 1.0);',\n    //'if (vColor.a < 0.5) discard;',\n    //'gl_FragColor = vec4(c, c, c, 1.0);',   //shadow\n    '}'].join('\\n');\n    /*\r\n    const vtext= [\r\n        'uniform vec2 uvScale;',\r\n        'varying vec2 vUv;',\r\n            'void main() {',\r\n                'vUv = uvScale * uv;',\r\n                'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n                'gl_Position = projectionMatrix * mvPosition;',\r\n            '}'].join('\\n');\r\n    const ftext=[\r\n        'uniform float time;',\r\n        'uniform float fogDensity;',\r\n        'uniform vec3 fogColor;',\r\n        'uniform sampler2D texture1;',\r\n        'uniform sampler2D texture2;',\r\n        'varying vec2 vUv;',\r\n        'void main( void ) {',\r\n            'vec2 position = - 1.0 + 2.0 * vUv;',\r\n            'vec4 noise = texture2D( texture1, vUv );',\r\n            'vec2 T1 = vUv + vec2( 1.5, - 1.5 ) * time * 0.02;',\r\n            'vec2 T2 = vUv + vec2( - 0.5, 2.0 ) * time * 0.01;',\r\n            'T1.x += noise.x * 2.0;',\r\n            'T1.y += noise.y * 2.0;',\r\n            'T2.x -= noise.y * 0.2;',\r\n            'T2.y += noise.z * 0.2;',\r\n            'float p = texture2D( texture1, T1 * 2.0 ).a;',\r\n            'vec4 color = texture2D( texture2, T2 * 2.0 );',\r\n            'vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );',\r\n            'if( temp.r > 1.0 ) { temp.bg += clamp( temp.r - 2.0, 0.0, 100.0 ); }',\r\n            'if( temp.g > 1.0 ) { temp.rb += temp.g - 1.0; }',\r\n            'if( temp.b > 1.0 ) { temp.rg += temp.b - 1.0; }',\r\n            'gl_FragColor = temp;',\r\n            'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n            'const float LOG2 = 1.442695;',\r\n            'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n        '}'\r\n        ].join('\\n');\r\n    */\n    // material 2    \n\n    matShader = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      fragmentShader: ftext,\n      vertexShader: vtext,\n      blending: THREE.AdditiveBlending,\n      depthTest: false,\n      transparent: false,\n      vertexColors: true\n    });\n    matShaderSub = new THREE.LineBasicMaterial({\n      vertexColors: THREE.VertexColors,\n      blending: THREE.AdditiveBlending,\n      transparent: true\n    });\n    matHidden = new THREE.MeshBasicMaterial({\n      color: matColor,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      opacity: 0.1\n    }); //matShader.lights = true;\n\n    /*\r\n    //var texdifCarbon = new THREE.TextureLoader().setPath( './assets/textures/carbon/' ).load( 'Carbon.png');\r\n    texdifCarbon.encoding = THREE.sRGBEncoding;\r\n    texdifCarbon.wrapS = THREE.RepeatWrapping;\r\n    texdifCarbon.wrapT = THREE.RepeatWrapping;\r\n    texdifCarbon.repeat.x = 2;\r\n    texdifCarbon.repeat.y = 2;\r\n      //var texnorCarbon = new THREE.TextureLoader().setPath( './assets/textures/carbon/' ).load( 'Carbon_Normal.png' );\r\n    texnorCarbon.wrapS = THREE.RepeatWrapping;\r\n    texnorCarbon.wrapT = THREE.RepeatWrapping;\r\n    texnorCarbon.repeat.x = 2;\r\n    texnorCarbon.repeat.y = 2;\r\n    matShader = new THREE.MeshPhysicalMaterial( {\r\n          metalness: 0.0,\r\n        roughness: 0.1, \r\n        clearcoat: 0.1,\r\n        clearcoatNormalMap: texnorCarbon,\r\n        clearcoatRoughness: 0.1,\r\n        //envMap: backgroundcube,\r\n        map: texdifCarbon,\r\n        //normalMap: texnorCarbon\r\n    } );\r\n    //matShader.envMap.mapping = THREE.CubeRefractionMapping;\r\n    */\n    // material 3\n\n    matWireframe = new THREE.MeshBasicMaterial({\n      color: matColor,\n      wireframe: true\n    }); // material 4\n\n    matGradient = new THREE.MeshLambertMaterial({\n      vertexColors: THREE.VertexColors\n    }); // manager        \n\n    const manager = new THREE.LoadingManager(loadModel);\n\n    manager.onProgress = function (item, loaded, total) {//console.log( item, loaded, total );\n    }; // execute input\n\n\n    var loader = new OBJLoader(manager); // =================object will install into ./public not in ./src===================\n\n    loader.load('./assets/rhinojs/model.obj', function (obj) {\n      // Object\n      obj.traverse(function (child) {\n        if (child.isMesh) {\n          geo = child;\n          geo.material = matReflective;\n          geo.castShadow = true;\n          scene.add(geo); // geoParticles insides\n\n          var geoPtsys = geo.geometry.clone();\n          var colors = [];\n          var sizes = [];\n          var color = new THREE.Color();\n\n          for (var i = 0, n = geoPtsys.attributes.position.count; i < n; i++) {\n            //color.setHSL( i / pnum, 1.0, 0.5 );\n            //colors.push( color.r, color.g, color.b );\n            colors.push(i / n, 0.2, 0.1);\n            sizes.push(0.3);\n          }\n\n          geoPtsys.attributes.color = new THREE.BufferAttribute(new Float32Array(colors), 3);\n          geoPtsys.attributes.size = new THREE.BufferAttribute(new Float32Array(sizes), 1); //geoPtsys.setDrawRange( 0, 1000 );\n\n          geoPts = new THREE.Points(geoPtsys, matShader);\n          geoLines = new THREE.LineSegments(geoPtsys, matShaderSub);\n          geoPts.castShadow = true;\n          geoPts.visible = false;\n          geoLines.castShadow = true;\n          geoLines.visible = false;\n          scene.add(geoPts);\n          scene.add(geoLines);\n        }\n      }); // background     \n\n      var ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(40, 40, 1, 1), new THREE.MeshPhongMaterial({\n        color: 0xa0adaf,\n        shininess: 150\n      }));\n      ground.rotation.x = -Math.PI / 2; // rotates X/Y to X/Z\n\n      ground.receiveShadow = true;\n      scene.add(ground);\n    }, onProgress, onError); //GUI\n\n    var effectController = {\n      newShading: \"Reflective\"\n    };\n    gui.add(effectController, 'newShading', [\"Wireframe\", \"Shader\", \"Reflective\", \"Gradient\"]).name('Shading').onChange(matEx);\n\n    function matEx() {\n      if (geo !== undefined) {\n        if (geo.isMesh) {\n          if (effectController.newShading !== shading) {\n            shading = effectController.newShading;\n            geoSelceted = [];\n\n            if (shading === 'Wireframe') {\n              geoPts.visible = false;\n              geoLines.visible = false;\n              geo.material = matWireframe;\n              geoSelceted.push(geo);\n            } else if (shading === 'Shader') {\n              geoPts.visible = true;\n              geoLines.visible = true;\n              geo.material = matHidden;\n              geoPts.material = matShader;\n              geoLines.material = matShaderSub;\n              geoLines.geometry.setDrawRange(0, 500);\n              geoPts.material.needsUpdate = true;\n              geoLines.material.needsUpdate = true;\n              geoSelceted.push(geo);\n            } // 點狀\n            else if (shading === 'Reflective') {\n                geoPts.visible = false;\n                geoLines.visible = false;\n                geo.material = matReflective;\n              } else if (shading === 'Gradient') {\n                geoPts.visible = false;\n                geoLines.visible = false; // translate geo to buffer geo\n\n                var newgeo = geo.geometry; //newgeo.computeVertexNormals(); // 菱角化\n\n                geo.geometry.computeBoundingBox();\n                var boundMinY = newgeo.boundingBox.min.y;\n                var boundMaxY = newgeo.boundingBox.max.y;\n                var boundH = boundMaxY - boundMinY;\n                var colors = [];\n\n                for (var i = 0, n = newgeo.attributes.position.count; i < n; ++i) {\n                  let valy = newgeo.attributes.position.getY(i);\n                  colors.push((valy - boundMinY) / boundH, 0.5, 0.5);\n                }\n\n                newgeo.attributes.color = new THREE.BufferAttribute(new Float32Array(colors), 3);\n                geo.geometry = newgeo; //updateMaterial(geo);\n\n                geo.material = matGradient;\n              }\n\n            if (outlinePass !== undefined) {\n              outlinePass.selectedObjects = geoSelceted;\n            }\n\n            geo.material.needsUpdate = true;\n          }\n        }\n      }\n    }\n\n    customContainer.appendChild(gui.domElement);\n  }\n  /*\r\n      function updateMaterial(mesh) {  \r\n          if (shading ==='Gradient'){\r\n              \r\n              lut.setColorMap( 'rainbow' );\r\n              lut.setMax( 2000 );\r\n              lut.setMin( 0 );\r\n              var geometry = mesh.geometry;\r\n              var pressures = geometry.attributes.pressure;\r\n              var colors = geometry.attributes.color;\r\n              for ( var i = 0; i < pressures.array.length; i ++ ) {\r\n                  var colorValue = pressures.array[ i ];\r\n                  var color = lut.getColor( colorValue );\r\n                  if ( color === undefined ) {\r\n                      console.log( 'Unable to determine color for value:', colorValue );\r\n                      } else {\r\n                      colors.setXYZ( i, color.r, color.g, color.b );\r\n                      }\r\n              }\r\n  \r\n              colors.needsUpdate = true;\r\n                      var map = sprite.material.map;\r\n                      lut.updateCanvas( map.image );\r\n                      map.needsUpdate = true;\r\n                      \r\n          }\r\n      }\r\n  */\n\n\n  function update() {\n    lights.update();\n    var delta = Date.now() * 0.0015;\n\n    if (shading === 'Shader') {\n      let colors = [];\n      let sizes = [];\n\n      for (var i = 0, n = geoPts.geometry.attributes.position.count; i < n; i++) {\n        colors.push(i / n, 0.5 + Math.sin(i + delta * 1.03) * 0.3, 1 - i / n);\n        sizes.push(0.3 + 0.30 * Math.sin(i + delta));\n      }\n\n      geoPts.geometry.attributes.color = new THREE.BufferAttribute(new Float32Array(colors), 3);\n      geoPts.geometry.attributes.size = new THREE.BufferAttribute(new Float32Array(sizes), 1);\n    } //uniforms[ 'time' ].value += 0.2 * delta;\n\n    /*\r\n            \r\n            \r\n            for ( var i = 0; i < scene.children.length; i ++ ) {\r\n                var object = scene.children[ i ];\r\n                    object.rotation.y += delta * 0.5 * ( i % 2 ? 1 : - 1 );\r\n                    object.rotation.x += delta * 0.5 * ( i % 2 ? - 1 : 1 );\r\n            }\r\n    */\n    // postrender\n    //renderer.clear();\n\n\n    composer.render(); //renderer.render(scene, camera);\n  }\n\n  function onWindowResize() {\n    const {\n      width,\n      height\n    } = canvas;\n    screenDimensions.width = width;\n    screenDimensions.height = height;\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n    composer.setSize(width, height);\n  }\n\n  return {\n    update,\n    onWindowResize\n  };\n});","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/Rhinojs/threejs/SceneManager.js"],"names":["THREE","GeneralLights","dat","OBJLoader","EffectComposer","RenderPass","FilmPass","BloomPass","ShaderPass","SobelOperatorShader","OutlinePass","OrbitControls","require","textureLoader","TextureLoader","canvas","geo","geoPts","geoLines","geoSelceted","backgroundcube","t1","t2","uniforms","matColor","matReflective","matShader","matWireframe","matGradient","matShaderSub","matHidden","composer","outlinePass","shading","clock","Clock","screenDimensions","width","height","scene","buildScene","camera","buildCamera","renderer","buildRender","controls","domElement","target","set","update","lights","setPath","load","tex1","pointTexture","value","createSceneSubjects","xhr1","console","log","loaded","total","Scene","background","Color","WebGLRenderer","antialias","alpha","DPR","window","devicePixelRatio","shadowMap","enabled","localClippingEnabled","setPixelRatio","setSize","autoClear","toneMapping","ReinhardToneMapping","renderPass","addPass","Vector2","edgeStrength","edgeGlow","edgeThickness","pulsePeriod","visibleEdgeColor","hiddenEdgeColor","loadModel","onProgress","xhr","lengthComputable","percentComplete","Math","round","onError","PerspectiveCamera","innerWidth","innerHeight","position","customContainer","document","getElementById","gui","GUI","autoPlace","setRGB","CubeTextureLoader","MeshStandardMaterial","color","metalness","roughness","envMap","vtext","join","ftext","ShaderMaterial","fragmentShader","vertexShader","blending","AdditiveBlending","depthTest","transparent","vertexColors","LineBasicMaterial","VertexColors","MeshBasicMaterial","opacity","wireframe","MeshLambertMaterial","manager","LoadingManager","item","loader","obj","traverse","child","isMesh","material","castShadow","add","geoPtsys","geometry","clone","colors","sizes","i","n","attributes","count","push","BufferAttribute","Float32Array","size","Points","LineSegments","visible","ground","Mesh","PlaneBufferGeometry","MeshPhongMaterial","shininess","rotation","x","PI","receiveShadow","effectController","newShading","name","onChange","matEx","undefined","setDrawRange","needsUpdate","newgeo","computeBoundingBox","boundMinY","boundingBox","min","y","boundMaxY","max","boundH","valy","getY","selectedObjects","appendChild","delta","Date","now","sin","render","onWindowResize","aspect","updateProjectionMatrix"],"mappings":"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","sourcesContent":["import * as THREE from '../../threejs/src/Three.js';\r\n//import SceneSubject from './SceneSubject';\r\nimport GeneralLights from './GeneralLights';\r\nimport * as dat from 'dat.gui';\r\nimport { OBJLoader } from '../../threejs/examples/jsm/loaders/OBJLoader.js';\r\n\r\nimport { EffectComposer } from '../../threejs/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from '../../threejs/examples/jsm/postprocessing/RenderPass.js';\r\nimport { FilmPass } from '../../threejs/examples/jsm/postprocessing/FilmPass.js';\r\nimport { BloomPass } from '../../threejs/examples/jsm/postprocessing/BloomPass.js';\r\n\r\nimport { ShaderPass } from '../../threejs/examples/jsm/postprocessing/ShaderPass.js';\r\nimport { SobelOperatorShader } from '../../threejs/examples/jsm/shaders/SobelOperatorShader.js';\r\nimport { OutlinePass } from '../../threejs/examples/jsm/postprocessing/OutlinePass.js';\r\n\r\n//const glsl = require('glslify');\r\nconst OrbitControls = require('three-orbit-controls')(THREE);\r\nconst textureLoader = new THREE.TextureLoader();\r\n\r\nexport default canvas => {\r\n    // objects\r\n    var geo, geoPts, geoLines, geoSelceted, backgroundcube;\r\n    // material\r\n    var t1, t2, uniforms;\r\n    var matColor, matReflective, matShader, matWireframe, matGradient, matShaderSub, matHidden;\r\n    // renderer\r\n    var composer, outlinePass;\r\n    // GUI\r\n    var shading;\r\n    const clock = new THREE.Clock();\r\n    const screenDimensions = {\r\n        width: canvas.width,\r\n        height: canvas.height\r\n    }\r\n\r\n    // build\r\n    const scene = buildScene();\r\n    const camera = buildCamera(screenDimensions);\r\n    const renderer = buildRender(screenDimensions);\r\n    \r\n    const controls = new OrbitControls( camera, renderer.domElement );\r\n    controls.target.set( 0, 1, 0 );\r\n    controls.update();\r\n\r\n    const lights = GeneralLights(scene);\r\n\r\n\r\n    // textture\r\n    textureLoader.setPath( './assets/textures/sprites/' ).load( 'spark1.png', (tex1)=>{\r\n        //t1 = tex1;        \r\n        //textureLoader.setPath( './assets/textures/lava/' ).load( 'lavatile.jpg', (tex2)=>{\r\n            t1 = tex1;\r\n            \r\n            uniforms ={pointTexture: { value: t1 }};\r\n\r\n            createSceneSubjects(scene, uniforms);\r\n\r\n        //},( xhr2 ) =>{\r\n        //    console.log( (xhr2.loaded / xhr2.total * 100) + '% loaded' );\r\n        //},( xhr2 ) =>{\r\n        //    console.log( 'An error happened' );\r\n        //});\r\n    //\r\n    },( xhr1 ) =>{\r\n        console.log( (xhr1.loaded / xhr1.total * 100) + '% loaded' );\r\n    },( xhr1 ) =>{\r\n        console.log( 'An error happened' );\r\n    });\r\n\r\n    \r\n\r\n    function buildScene() {\r\n        const scene = new THREE.Scene();\r\n        scene.background = new THREE.Color('#000');\r\n        return scene;\r\n    }\r\n\r\n    function buildRender({ width, height }) {\r\n        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });\r\n        const DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.localClippingEnabled = false;\r\n        renderer.setPixelRatio(DPR);\r\n        renderer.setSize(width, height);\r\n        renderer.autoClear = false;\r\n        renderer.toneMapping = THREE.ReinhardToneMapping;\r\n\r\n        // post\r\n        composer = new EffectComposer( renderer );\r\n        \r\n        //var renderModel = new RenderPass( scene, camera );\r\n        //composer.addPass( renderModel );\r\n        \r\n\r\n        //var effectFilm = new FilmPass( 0.35, 0.95, 2048, false );\r\n        //composer.addPass( effectFilm );   \r\n\r\n        //var effectBloom = new BloomPass();\r\n        //effectBloom.threshold = 1.5;\r\n        //effectBloom.strength = 1;\r\n        //effectBloom.radius = 1;\r\n        //composer.addPass( effectBloom );\r\n        \r\n        //renderer.toneMappingExposure = Math.pow( 1.2, 4.0 );\r\n        var renderPass = new RenderPass( scene, camera );\r\n        composer.addPass( renderPass );\r\n\r\n        outlinePass = new OutlinePass( new THREE.Vector2( width, height ), scene, camera );\r\n        /*\r\n        textureLoader.load( './assets/textures/tri_pattern.jpg', ( texture )=> {\r\n                outlinePass.patternTexture = texture;\r\n                texture.wrapS = THREE.RepeatWrapping;\r\n                texture.wrapT = THREE.RepeatWrapping;\r\n            },( xhr1 ) =>{\r\n                console.log( (xhr1.loaded / xhr1.total * 100) + '% loaded' );\r\n            },( xhr1 ) =>{\r\n                console.log( 'An error happened' );\r\n            });\r\n        */\r\n        outlinePass.edgeStrength = 3.0\r\n        outlinePass.edgeGlow = 0.0;\r\n        outlinePass.edgeThickness = 1.0;\r\n        outlinePass.pulsePeriod = 0;\r\n        outlinePass.visibleEdgeColor.set( '#ff0000' );\r\n        outlinePass.hiddenEdgeColor.set( '#190a05' );\r\n\r\n        //outlinePass.selectedObjects=geo;\r\n\r\n        composer.addPass( outlinePass );\r\n        \r\n        //var effectSobel = new ShaderPass( SobelOperatorShader );\r\n        //composer.addPass( effectSobel);\r\n\r\n        return renderer;\r\n    }\r\n\r\n    // input function\r\n    \r\n    function loadModel() { }\r\n    \r\n    function onProgress( xhr ) {\r\n            if ( xhr.lengthComputable ) {\r\n                var percentComplete = xhr.loaded / xhr.total * 100;\r\n                console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );\r\n                }\r\n    }\r\n\r\n    function onError() {\r\n            console.log( 'error!!' );\r\n    }\r\n\r\n    function buildCamera({ width, height }) {\r\n        /*\r\n        const fieldOfView = 36;\r\n        const aspectRatio = window.innerWidth / window.innerHeight;\r\n        const nearPlane = 0.25;\r\n        const farPlane = 10000; \r\n        const camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);\r\n\r\n        camera.position.set( 3, 1.3, 3 );\r\n        */\r\n\r\n        const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );\r\n        camera.position.set( 6, 6, 0 );\r\n        \r\n        return camera;\r\n    }\r\n\r\n    function createSceneSubjects(scene , uniforms) {\r\n\r\n        // subject\r\n        const customContainer = document.getElementById('canvas-gui-container');\r\n        var gui = new dat.GUI({ autoPlace: false }); \r\n        //var localPlane = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );\r\n        //var globalPlane = new THREE.Plane( new THREE.Vector3( - 1, -2, 0 ), 0.1 );\r\n\r\n        // material 1\r\n        matColor = new THREE.Color();\r\n        matColor.setRGB( 0.9, 0.95, 1.0 );\r\n        \r\n        backgroundcube = new THREE.CubeTextureLoader()\r\n                    .setPath( './assets/textures/cube/pisa/' )\r\n                    .load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] );\r\n        matReflective = new THREE.MeshStandardMaterial( { color: matColor, metalness: 0.1, roughness:0.1, envMap: backgroundcube} );\r\n\r\n        \r\n        // shader\r\nconst vtext =[\r\n            'attribute float size;',\r\n\r\n            'varying vec3 vNormal;',\r\n            'varying vec3 vWorldPosition;',\r\n\r\n            'varying vec3 vColor;',\r\n            'void main() {',\r\n                'vColor = color;',\r\n                'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n                'gl_PointSize = size * ( 300.0 / -mvPosition.z );',\r\n                'gl_Position = projectionMatrix * mvPosition;',\r\n            '}'].join('\\n');\r\n\r\nconst ftext =[\r\n            'uniform sampler2D pointTexture;',\r\n\r\n            'varying vec3 vNormal;',\r\n            'varying vec3 vWorldPosition;',\r\n\r\n            'uniform vec3 lightPosition;',\r\n            'varying vec3 vColor;',\r\n            //'varying vec3 vOpacity;',\r\n            'void main() {',\r\n\r\n                'vec3 lightDirection = normalize(lightPosition - vWorldPosition);', // light\r\n                'vec3 outgoingLight = vec3(1.0);',\r\n                //'float c = 0.35 + max(0.0, dot(vNormal, lightDirection)) * 0.4 * shadowMask.x;', // shadow\r\n\r\n                \r\n\r\n                'gl_FragColor = vec4( vColor, 1.0 );',  // object\r\n                'gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );', // object text\r\n                //'gl_FragColor = gl_FragColor * vec4(vColor, 1.0);',\r\n                //'if (vColor.a < 0.5) discard;',\r\n                //'gl_FragColor = vec4(c, c, c, 1.0);',   //shadow\r\n            '}'].join('\\n');\r\n        /*\r\nconst vtext= [\r\n            'uniform vec2 uvScale;',\r\n            'varying vec2 vUv;',\r\n                'void main() {',\r\n                    'vUv = uvScale * uv;',\r\n                    'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n                    'gl_Position = projectionMatrix * mvPosition;',\r\n                '}'].join('\\n');\r\nconst ftext=[\r\n            'uniform float time;',\r\n            'uniform float fogDensity;',\r\n            'uniform vec3 fogColor;',\r\n            'uniform sampler2D texture1;',\r\n            'uniform sampler2D texture2;',\r\n            'varying vec2 vUv;',\r\n            'void main( void ) {',\r\n                'vec2 position = - 1.0 + 2.0 * vUv;',\r\n                'vec4 noise = texture2D( texture1, vUv );',\r\n                'vec2 T1 = vUv + vec2( 1.5, - 1.5 ) * time * 0.02;',\r\n                'vec2 T2 = vUv + vec2( - 0.5, 2.0 ) * time * 0.01;',\r\n                'T1.x += noise.x * 2.0;',\r\n                'T1.y += noise.y * 2.0;',\r\n                'T2.x -= noise.y * 0.2;',\r\n                'T2.y += noise.z * 0.2;',\r\n                'float p = texture2D( texture1, T1 * 2.0 ).a;',\r\n                'vec4 color = texture2D( texture2, T2 * 2.0 );',\r\n                'vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );',\r\n                'if( temp.r > 1.0 ) { temp.bg += clamp( temp.r - 2.0, 0.0, 100.0 ); }',\r\n                'if( temp.g > 1.0 ) { temp.rb += temp.g - 1.0; }',\r\n                'if( temp.b > 1.0 ) { temp.rg += temp.b - 1.0; }',\r\n                'gl_FragColor = temp;',\r\n                'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n                'const float LOG2 = 1.442695;',\r\n                'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n                'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n                'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n            '}'\r\n            ].join('\\n');\r\n*/\r\n        // material 2    \r\n        matShader = new THREE.ShaderMaterial( {\r\n                    uniforms: uniforms,\r\n                    fragmentShader: ftext,\r\n                    vertexShader: vtext,\r\n\r\n                    blending: THREE.AdditiveBlending,\r\n                    depthTest: false,\r\n                    transparent: false,\r\n                    vertexColors: true\r\n                });\r\n\r\n        matShaderSub = new THREE.LineBasicMaterial( {\r\n                    vertexColors: THREE.VertexColors,\r\n                    blending: THREE.AdditiveBlending,\r\n                    transparent: true\r\n                } );\r\n        matHidden = new THREE.MeshBasicMaterial( { \r\n            color: matColor, \r\n            transparent: true, \r\n            blending: THREE.AdditiveBlending,\r\n            opacity : 0.1\r\n        } );\r\n        //matShader.lights = true;\r\n        /*\r\n        //var texdifCarbon = new THREE.TextureLoader().setPath( './assets/textures/carbon/' ).load( 'Carbon.png');\r\n        texdifCarbon.encoding = THREE.sRGBEncoding;\r\n        texdifCarbon.wrapS = THREE.RepeatWrapping;\r\n        texdifCarbon.wrapT = THREE.RepeatWrapping;\r\n        texdifCarbon.repeat.x = 2;\r\n        texdifCarbon.repeat.y = 2;\r\n\r\n        //var texnorCarbon = new THREE.TextureLoader().setPath( './assets/textures/carbon/' ).load( 'Carbon_Normal.png' );\r\n        texnorCarbon.wrapS = THREE.RepeatWrapping;\r\n        texnorCarbon.wrapT = THREE.RepeatWrapping;\r\n        texnorCarbon.repeat.x = 2;\r\n        texnorCarbon.repeat.y = 2;\r\n        matShader = new THREE.MeshPhysicalMaterial( {\r\n\r\n            metalness: 0.0,\r\n            roughness: 0.1, \r\n            clearcoat: 0.1,\r\n            clearcoatNormalMap: texnorCarbon,\r\n            clearcoatRoughness: 0.1,\r\n            //envMap: backgroundcube,\r\n            map: texdifCarbon,\r\n            //normalMap: texnorCarbon\r\n        } );\r\n        //matShader.envMap.mapping = THREE.CubeRefractionMapping;\r\n        */\r\n\r\n        // material 3\r\n        matWireframe = new THREE.MeshBasicMaterial( { color: matColor, wireframe: true } );\r\n        \r\n        // material 4\r\n        matGradient = new THREE.MeshLambertMaterial( {\r\n                    vertexColors: THREE.VertexColors\r\n                });\r\n        // manager        \r\n        const manager = new THREE.LoadingManager(loadModel);        \r\n        manager.onProgress = function ( item, loaded, total ) {\r\n            //console.log( item, loaded, total );\r\n        };\r\n\r\n\r\n        // execute input\r\n        var loader = new OBJLoader(manager);\r\n        // =================object will install into ./public not in ./src===================\r\n        loader.load( './assets/rhinojs/model.obj', function ( obj ) {\r\n            // Object\r\n            obj.traverse( function ( child ) {\r\n                if ( child.isMesh ) {\r\n                    geo = child;\r\n                    geo.material = matReflective;\r\n                    \r\n                    geo.castShadow = true;\r\n                    scene.add(geo);\r\n\r\n                    // geoParticles insides\r\n                    var geoPtsys = geo.geometry.clone();\r\n                    var colors = [];\r\n                    var sizes = [];\r\n                    \r\n                    var color = new THREE.Color();\r\n\r\n                    for ( var i = 0, n = geoPtsys.attributes.position.count; i < n; i ++ ) {\r\n                        //color.setHSL( i / pnum, 1.0, 0.5 );\r\n                        //colors.push( color.r, color.g, color.b );\r\n                        colors.push( i / n, 0.2, 0.1 );\r\n                        sizes.push( 0.3 );\r\n                    }\r\n                    geoPtsys.attributes.color = new THREE.BufferAttribute( new Float32Array(colors), 3 );\r\n                    geoPtsys.attributes.size = new THREE.BufferAttribute( new Float32Array(sizes), 1 );\r\n                    //geoPtsys.setDrawRange( 0, 1000 );\r\n\r\n                    geoPts = new THREE.Points( geoPtsys, matShader );\r\n                    geoLines = new THREE.LineSegments( geoPtsys, matShaderSub );\r\n\r\n                    geoPts.castShadow = true;\r\n                    geoPts.visible = false;\r\n                    geoLines.castShadow = true;\r\n                    geoLines.visible = false;\r\n                    \r\n                    scene.add(geoPts);\r\n                    scene.add(geoLines);                    \r\n                }               \r\n            });\r\n\r\n            // background     \r\n            var ground = new THREE.Mesh(\r\n                        new THREE.PlaneBufferGeometry( 40, 40, 1, 1 ),\r\n                        new THREE.MeshPhongMaterial( { color: 0xa0adaf, shininess: 150 } )\r\n            );\r\n\r\n            ground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\r\n            ground.receiveShadow = true;            \r\n            scene.add( ground );\r\n\r\n        }, onProgress, onError );\r\n\r\n        //GUI\r\n        var effectController = {\r\n            newShading: \"Reflective\"\r\n        }\r\n        gui.add( effectController, 'newShading', [ \"Wireframe\", \"Shader\", \"Reflective\", \"Gradient\" ]).name('Shading').onChange( matEx );\r\n\r\n         function matEx(){\r\n            if (geo!==undefined){\r\n                if (geo.isMesh){\r\n                    if(effectController.newShading !== shading)\r\n                    {\r\n                        shading = effectController.newShading;\r\n                        geoSelceted = [];\r\n\r\n                        if (shading === 'Wireframe'){\r\n                            geoPts.visible = false; geoLines.visible = false; \r\n                            geo.material=matWireframe;\r\n                            \r\n                            geoSelceted.push( geo);\r\n                        }else if (shading === 'Shader'){\r\n                            geoPts.visible = true; geoLines.visible = true; \r\n                            \r\n                            geo.material=matHidden;\r\n                            geoPts.material=matShader;\r\n                            geoLines.material=matShaderSub; \r\n\r\n                            geoLines.geometry.setDrawRange( 0, 500 );\r\n\r\n                            geoPts.material.needsUpdate = true;\r\n                            geoLines.material.needsUpdate = true;\r\n\r\n                            geoSelceted.push( geo);\r\n\r\n                            } // 點狀\r\n                        else if (shading === 'Reflective'){\r\n                            geoPts.visible = false; geoLines.visible = false; \r\n                            geo.material=matReflective;\r\n                        }else if (shading ==='Gradient'){\r\n                            geoPts.visible = false; geoLines.visible = false; \r\n                            // translate geo to buffer geo\r\n                            var newgeo=geo.geometry;\r\n                            //newgeo.computeVertexNormals(); // 菱角化\r\n                            geo.geometry.computeBoundingBox ();\r\n\r\n                            var boundMinY = newgeo.boundingBox.min.y;\r\n                            var boundMaxY = newgeo.boundingBox.max.y;\r\n                            var boundH = boundMaxY - boundMinY;\r\n\r\n                            var colors = [];\r\n                            for ( var i = 0, n = newgeo.attributes.position.count; i < n; ++ i ) {\r\n                                let valy = newgeo.attributes.position.getY(i);\r\n                                colors.push( (valy-boundMinY)/boundH, 0.5, 0.5 );\r\n                            }\r\n                            newgeo.attributes.color = new THREE.BufferAttribute( new Float32Array(colors), 3 );\r\n\r\n                            geo.geometry = newgeo;\r\n                            //updateMaterial(geo);\r\n\r\n                            geo.material = matGradient;\r\n                        }\r\n\r\n                        if (outlinePass !==undefined) {\r\n                            outlinePass.selectedObjects = geoSelceted;\r\n                        }\r\n                        geo.material.needsUpdate = true;\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        customContainer.appendChild(gui.domElement);\r\n    }\r\n/*\r\n    function updateMaterial(mesh) {  \r\n        if (shading ==='Gradient'){\r\n            \r\n            lut.setColorMap( 'rainbow' );\r\n            lut.setMax( 2000 );\r\n            lut.setMin( 0 );\r\n            var geometry = mesh.geometry;\r\n            var pressures = geometry.attributes.pressure;\r\n            var colors = geometry.attributes.color;\r\n            for ( var i = 0; i < pressures.array.length; i ++ ) {\r\n                var colorValue = pressures.array[ i ];\r\n                var color = lut.getColor( colorValue );\r\n                if ( color === undefined ) {\r\n                    console.log( 'Unable to determine color for value:', colorValue );\r\n                    } else {\r\n                    colors.setXYZ( i, color.r, color.g, color.b );\r\n                    }\r\n            }\r\n\r\n            colors.needsUpdate = true;\r\n                    var map = sprite.material.map;\r\n                    lut.updateCanvas( map.image );\r\n                    map.needsUpdate = true;\r\n                    \r\n        }\r\n    }\r\n*/\r\n    function update() {\r\n        lights.update();\r\n        var delta = Date.now()*0.0015;\r\n\r\n        if (shading ==='Shader'){\r\n            let colors= [];\r\n            let sizes = [];\r\n            for ( var i = 0, n = geoPts.geometry.attributes.position.count; i < n; i ++ ) {\r\n                    colors.push( i / n, 0.5+Math.sin( i + delta*1.03 )*0.3, 1-(i / n));\r\n                    sizes.push( 0.3 + 0.30*Math.sin( i + delta) );\r\n            }\r\n            geoPts.geometry.attributes.color = new THREE.BufferAttribute( new Float32Array(colors), 3 );\r\n            geoPts.geometry.attributes.size = new THREE.BufferAttribute( new Float32Array(sizes), 1 );\r\n        }\r\n        //uniforms[ 'time' ].value += 0.2 * delta;\r\n/*\r\n        \r\n        \r\n        for ( var i = 0; i < scene.children.length; i ++ ) {\r\n            var object = scene.children[ i ];\r\n                object.rotation.y += delta * 0.5 * ( i % 2 ? 1 : - 1 );\r\n                object.rotation.x += delta * 0.5 * ( i % 2 ? - 1 : 1 );\r\n        }\r\n*/\r\n        // postrender\r\n        //renderer.clear();\r\n        composer.render();\r\n\r\n        //renderer.render(scene, camera);\r\n        \r\n    }\r\n\r\n    function onWindowResize() {\r\n        const { width, height } = canvas;\r\n        \r\n        screenDimensions.width = width;\r\n        screenDimensions.height = height;\r\n\r\n        camera.aspect = width / height;\r\n        camera.updateProjectionMatrix();\r\n        \r\n        renderer.setSize(width, height);\r\n        composer.setSize( width,  height);\r\n\r\n        \r\n    }\r\n\r\n    return {\r\n        update,\r\n        onWindowResize\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}