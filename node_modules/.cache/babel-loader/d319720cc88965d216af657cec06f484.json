{"ast":null,"code":"import { BackSide, NoBlending } from '../constants.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxBufferGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\n/**\n * @author alteredq / http://alteredqualia.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction WebGLCubeRenderTarget(size, options, dummy) {\n  if (Number.isInteger(options)) {\n    console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');\n    options = dummy;\n  }\n\n  WebGLRenderTarget.call(this, size, size, options);\n}\n\nWebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);\nWebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nWebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {\n  this.texture.type = texture.type;\n  this.texture.format = texture.format;\n  this.texture.encoding = texture.encoding;\n  var scene = new Scene();\n  var shader = {\n    uniforms: {\n      tEquirect: {\n        value: null\n      }\n    },\n    vertexShader: [\"varying vec3 vWorldDirection;\", \"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\", \"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\", \"}\", \"void main() {\", \"\tvWorldDirection = transformDirection( position, modelMatrix );\", \"\t#include <begin_vertex>\", \"\t#include <project_vertex>\", \"}\"].join('\\n'),\n    fragmentShader: [\"uniform sampler2D tEquirect;\", \"varying vec3 vWorldDirection;\", \"#define RECIPROCAL_PI 0.31830988618\", \"#define RECIPROCAL_PI2 0.15915494\", \"void main() {\", \"\tvec3 direction = normalize( vWorldDirection );\", \"\tvec2 sampleUV;\", \"\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\", \"\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\", \"\tgl_FragColor = texture2D( tEquirect, sampleUV );\", \"}\"].join('\\n')\n  };\n  var material = new ShaderMaterial({\n    type: 'CubemapFromEquirect',\n    uniforms: cloneUniforms(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    side: BackSide,\n    blending: NoBlending\n  });\n  material.uniforms.tEquirect.value = texture;\n  var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);\n  scene.add(mesh);\n  var camera = new CubeCamera(1, 10, 1);\n  camera.renderTarget = this;\n  camera.renderTarget.texture.name = 'CubeCameraTexture';\n  camera.update(renderer, scene);\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  return this;\n};\n\nexport { WebGLCubeRenderTarget };","map":{"version":3,"sources":["D:/chrlab/src/component/panelComponent/Canvas/threejs/src/renderers/WebGLCubeRenderTarget.js"],"names":["BackSide","NoBlending","Scene","Mesh","BoxBufferGeometry","ShaderMaterial","cloneUniforms","WebGLRenderTarget","CubeCamera","WebGLCubeRenderTarget","size","options","dummy","Number","isInteger","console","warn","call","prototype","Object","create","constructor","isWebGLCubeRenderTarget","fromEquirectangularTexture","renderer","texture","type","format","encoding","scene","shader","uniforms","tEquirect","value","vertexShader","join","fragmentShader","material","side","blending","mesh","add","camera","renderTarget","name","update","geometry","dispose"],"mappings":"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","sourcesContent":["import { BackSide, NoBlending } from '../constants.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxBufferGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\n\n/**\n * @author alteredq / http://alteredqualia.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction WebGLCubeRenderTarget( size, options, dummy ) {\n\n\tif ( Number.isInteger( options ) ) {\n\n\t\tconsole.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );\n\n\t\toptions = dummy;\n\n\t}\n\n\tWebGLRenderTarget.call( this, size, size, options );\n\n}\n\nWebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );\nWebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nWebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {\n\n\tthis.texture.type = texture.type;\n\tthis.texture.format = texture.format;\n\tthis.texture.encoding = texture.encoding;\n\n\tvar scene = new Scene();\n\n\tvar shader = {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vWorldDirection;\",\n\n\t\t\t\"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\",\n\n\t\t\t\"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvWorldDirection = transformDirection( position, modelMatrix );\",\n\n\t\t\t\"\t#include <begin_vertex>\",\n\t\t\t\"\t#include <project_vertex>\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tEquirect;\",\n\n\t\t\t\"varying vec3 vWorldDirection;\",\n\n\t\t\t\"#define RECIPROCAL_PI 0.31830988618\",\n\t\t\t\"#define RECIPROCAL_PI2 0.15915494\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec3 direction = normalize( vWorldDirection );\",\n\n\t\t\t\"\tvec2 sampleUV;\",\n\n\t\t\t\"\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\",\n\n\t\t\t\"\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\n\n\t\t\t\"\tgl_FragColor = texture2D( tEquirect, sampleUV );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\t};\n\n\tvar material = new ShaderMaterial( {\n\n\t\ttype: 'CubemapFromEquirect',\n\n\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tside: BackSide,\n\t\tblending: NoBlending\n\n\t} );\n\n\tmaterial.uniforms.tEquirect.value = texture;\n\n\tvar mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );\n\n\tscene.add( mesh );\n\n\tvar camera = new CubeCamera( 1, 10, 1 );\n\n\tcamera.renderTarget = this;\n\tcamera.renderTarget.texture.name = 'CubeCameraTexture';\n\n\tcamera.update( renderer, scene );\n\n\tmesh.geometry.dispose();\n\tmesh.material.dispose();\n\n\treturn this;\n\n};\n\nexport { WebGLCubeRenderTarget };\n"]},"metadata":{},"sourceType":"module"}