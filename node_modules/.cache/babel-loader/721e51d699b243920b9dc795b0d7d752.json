{"ast":null,"code":"import { Line } from './Line.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _start = new Vector3();\n\nvar _end = new Vector3();\n\nfunction LineSegments(geometry, material) {\n  Line.call(this, geometry, material);\n  this.type = 'LineSegments';\n}\n\nLineSegments.prototype = Object.assign(Object.create(Line.prototype), {\n  constructor: LineSegments,\n  isLineSegments: true,\n  computeLineDistances: function () {\n    var geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        var positionAttribute = geometry.attributes.position;\n        var lineDistances = [];\n\n        for (var i = 0, l = positionAttribute.count; i < l; i += 2) {\n          _start.fromBufferAttribute(positionAttribute, i);\n\n          _end.fromBufferAttribute(positionAttribute, i + 1);\n\n          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      var vertices = geometry.vertices;\n      var lineDistances = geometry.lineDistances;\n\n      for (var i = 0, l = vertices.length; i < l; i += 2) {\n        _start.copy(vertices[i]);\n\n        _end.copy(vertices[i + 1]);\n\n        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n      }\n    }\n\n    return this;\n  }\n});\nexport { LineSegments };","map":{"version":3,"sources":["D:/chrlab/src/component/panelComponent/Canvas/threejs/src/objects/LineSegments.js"],"names":["Line","Vector3","Float32BufferAttribute","_start","_end","LineSegments","geometry","material","call","type","prototype","Object","assign","create","constructor","isLineSegments","computeLineDistances","isBufferGeometry","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","console","warn","isGeometry","vertices","length","copy"],"mappings":"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","sourcesContent":["import { Line } from './Line.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _start = new Vector3();\nvar _end = new Vector3();\n\nfunction LineSegments( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n}\n\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineSegments,\n\n\tisLineSegments: true,\n\n\tcomputeLineDistances: function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar lineDistances = [];\n\n\t\t\t\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\n\n\t\t\t\t_start.copy( vertices[ i ] );\n\t\t\t\t_end.copy( vertices[ i + 1 ] );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { LineSegments };\n"]},"metadata":{},"sourceType":"module"}