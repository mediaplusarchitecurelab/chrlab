{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _start = new Vector3();\n\nvar _end = new Vector3();\n\nvar _inverseMatrix = new Matrix4();\n\nvar _ray = new Ray();\n\nvar _sphere = new Sphere();\n\nfunction Line(geometry, material, mode) {\n  if (mode === 1) {\n    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');\n  }\n\n  Object3D.call(this);\n  this.type = 'Line';\n  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n  this.material = material !== undefined ? material : new LineBasicMaterial();\n}\n\nLine.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: Line,\n  isLine: true,\n  computeLineDistances: function () {\n    var geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        var positionAttribute = geometry.attributes.position;\n        var lineDistances = [0];\n\n        for (var i = 1, l = positionAttribute.count; i < l; i++) {\n          _start.fromBufferAttribute(positionAttribute, i - 1);\n\n          _end.fromBufferAttribute(positionAttribute, i);\n\n          lineDistances[i] = lineDistances[i - 1];\n          lineDistances[i] += _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      var vertices = geometry.vertices;\n      var lineDistances = geometry.lineDistances;\n      lineDistances[0] = 0;\n\n      for (var i = 1, l = vertices.length; i < l; i++) {\n        lineDistances[i] = lineDistances[i - 1];\n        lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);\n      }\n    }\n\n    return this;\n  },\n  raycast: function (raycaster, intersects) {\n    var geometry = this.geometry;\n    var matrixWorld = this.matrixWorld;\n    var threshold = raycaster.params.Line.threshold; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.getInverse(matrixWorld);\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    var localThresholdSq = localThreshold * localThreshold;\n    var vStart = new Vector3();\n    var vEnd = new Vector3();\n    var interSegment = new Vector3();\n    var interRay = new Vector3();\n    var step = this && this.isLineSegments ? 2 : 1;\n\n    if (geometry.isBufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positions = attributes.position.array;\n\n      if (index !== null) {\n        var indices = index.array;\n\n        for (var i = 0, l = indices.length - 1; i < l; i += step) {\n          var a = indices[i];\n          var b = indices[i + 1];\n          vStart.fromArray(positions, a * 3);\n          vEnd.fromArray(positions, b * 3);\n\n          var distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n          vStart.fromArray(positions, 3 * i);\n          vEnd.fromArray(positions, 3 * i + 3);\n\n          var distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    } else if (geometry.isGeometry) {\n      var vertices = geometry.vertices;\n      var nbVertices = vertices.length;\n\n      for (var i = 0; i < nbVertices - 1; i += step) {\n        var distSq = _ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);\n\n        if (distSq > localThresholdSq) continue;\n        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n        var distance = raycaster.ray.origin.distanceTo(interRay);\n        if (distance < raycaster.near || distance > raycaster.far) continue;\n        intersects.push({\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this\n        });\n      }\n    }\n  },\n  clone: function () {\n    return new this.constructor(this.geometry, this.material).copy(this);\n  }\n});\nexport { Line };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/objects/Line.js"],"names":["Sphere","Ray","Matrix4","Object3D","Vector3","LineBasicMaterial","BufferGeometry","Float32BufferAttribute","_start","_end","_inverseMatrix","_ray","_sphere","Line","geometry","material","mode","console","error","call","type","undefined","prototype","Object","assign","create","constructor","isLine","computeLineDistances","isBufferGeometry","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","warn","isGeometry","vertices","length","raycast","raycaster","intersects","matrixWorld","threshold","params","boundingSphere","computeBoundingSphere","copy","applyMatrix4","radius","ray","intersectsSphere","getInverse","localThreshold","scale","x","y","z","localThresholdSq","vStart","vEnd","interSegment","interRay","step","isLineSegments","positions","array","indices","a","b","fromArray","distSq","distanceSqToSegment","distance","origin","near","far","push","point","clone","face","faceIndex","object","nbVertices"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _start = new Vector3();\nvar _end = new Vector3();\nvar _inverseMatrix = new Matrix4();\nvar _ray = new Ray();\nvar _sphere = new Sphere();\n\nfunction Line( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );\n\n\t}\n\n\tObject3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new LineBasicMaterial();\n\n}\n\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Line,\n\n\tisLine: true,\n\n\tcomputeLineDistances: function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar lineDistances = [ 0 ];\n\n\t\t\t\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i ] += _start.distanceTo( _end );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\tlineDistances[ 0 ] = 0;\n\n\t\t\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tvar geometry = this.geometry;\n\t\tvar matrixWorld = this.matrixWorld;\n\t\tvar threshold = raycaster.params.Line.threshold;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.getInverse( matrixWorld );\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tvar localThresholdSq = localThreshold * localThreshold;\n\n\t\tvar vStart = new Vector3();\n\t\tvar vEnd = new Vector3();\n\t\tvar interSegment = new Vector3();\n\t\tvar interRay = new Vector3();\n\t\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\tvar distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\tvar distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar nbVertices = vertices.length;\n\n\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\tvar distSq = _ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n\nexport { Line };\n"]},"metadata":{},"sourceType":"module"}