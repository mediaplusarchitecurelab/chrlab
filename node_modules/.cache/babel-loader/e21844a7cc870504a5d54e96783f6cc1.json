{"ast":null,"code":"/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n **/\nimport { Color } from '../../math/Color.js';\nimport { Path } from './Path.js';\nimport { Shape } from './Shape.js';\nimport { ShapeUtils } from '../ShapeUtils.js';\n\nfunction ShapePath() {\n  this.type = 'ShapePath';\n  this.color = new Color();\n  this.subPaths = [];\n  this.currentPath = null;\n}\n\nObject.assign(ShapePath.prototype, {\n  moveTo: function (x, y) {\n    this.currentPath = new Path();\n    this.subPaths.push(this.currentPath);\n    this.currentPath.moveTo(x, y);\n    return this;\n  },\n  lineTo: function (x, y) {\n    this.currentPath.lineTo(x, y);\n    return this;\n  },\n  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {\n    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n    return this;\n  },\n  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n    return this;\n  },\n  splineThru: function (pts) {\n    this.currentPath.splineThru(pts);\n    return this;\n  },\n  toShapes: function (isCCW, noHoles) {\n    function toShapesNoHoles(inSubpaths) {\n      var shapes = [];\n\n      for (var i = 0, l = inSubpaths.length; i < l; i++) {\n        var tmpPath = inSubpaths[i];\n        var tmpShape = new Shape();\n        tmpShape.curves = tmpPath.curves;\n        shapes.push(tmpShape);\n      }\n\n      return shapes;\n    }\n\n    function isPointInsidePolygon(inPt, inPolygon) {\n      var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or\n      // toggling of inside/outside at every single! intersection point of an edge\n      //  with the horizontal line through inPt, left of inPt\n      //  not counting lowerY endpoints of edges and whole edges on that line\n\n      var inside = false;\n\n      for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n        var edgeLowPt = inPolygon[p];\n        var edgeHighPt = inPolygon[q];\n        var edgeDx = edgeHighPt.x - edgeLowPt.x;\n        var edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n        if (Math.abs(edgeDy) > Number.EPSILON) {\n          // not parallel\n          if (edgeDy < 0) {\n            edgeLowPt = inPolygon[q];\n            edgeDx = -edgeDx;\n            edgeHighPt = inPolygon[p];\n            edgeDy = -edgeDy;\n          }\n\n          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n          if (inPt.y === edgeLowPt.y) {\n            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n            // continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n          } else {\n            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n            if (perpEdge === 0) return true; // inPt is on contour ?\n\n            if (perpEdge < 0) continue;\n            inside = !inside; // true intersection left of inPt\n          }\n        } else {\n          // parallel or collinear\n          if (inPt.y !== edgeLowPt.y) continue; // parallel\n          // edge lies on the same horizontal line as inPt\n\n          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n          // continue;\n        }\n      }\n\n      return inside;\n    }\n\n    var isClockWise = ShapeUtils.isClockWise;\n    var subPaths = this.subPaths;\n    if (subPaths.length === 0) return [];\n    if (noHoles === true) return toShapesNoHoles(subPaths);\n    var solid,\n        tmpPath,\n        tmpShape,\n        shapes = [];\n\n    if (subPaths.length === 1) {\n      tmpPath = subPaths[0];\n      tmpShape = new Shape();\n      tmpShape.curves = tmpPath.curves;\n      shapes.push(tmpShape);\n      return shapes;\n    }\n\n    var holesFirst = !isClockWise(subPaths[0].getPoints());\n    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log(\"Holes first\", holesFirst);\n\n    var betterShapeHoles = [];\n    var newShapes = [];\n    var newShapeHoles = [];\n    var mainIdx = 0;\n    var tmpPoints;\n    newShapes[mainIdx] = undefined;\n    newShapeHoles[mainIdx] = [];\n\n    for (var i = 0, l = subPaths.length; i < l; i++) {\n      tmpPath = subPaths[i];\n      tmpPoints = tmpPath.getPoints();\n      solid = isClockWise(tmpPoints);\n      solid = isCCW ? !solid : solid;\n\n      if (solid) {\n        if (!holesFirst && newShapes[mainIdx]) mainIdx++;\n        newShapes[mainIdx] = {\n          s: new Shape(),\n          p: tmpPoints\n        };\n        newShapes[mainIdx].s.curves = tmpPath.curves;\n        if (holesFirst) mainIdx++;\n        newShapeHoles[mainIdx] = []; //console.log('cw', i);\n      } else {\n        newShapeHoles[mainIdx].push({\n          h: tmpPath,\n          p: tmpPoints[0]\n        }); //console.log('ccw', i);\n      }\n    } // only Holes? -> probably all Shapes with wrong orientation\n\n\n    if (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n    if (newShapes.length > 1) {\n      var ambiguous = false;\n      var toChange = [];\n\n      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        betterShapeHoles[sIdx] = [];\n      }\n\n      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        var sho = newShapeHoles[sIdx];\n\n        for (var hIdx = 0; hIdx < sho.length; hIdx++) {\n          var ho = sho[hIdx];\n          var hole_unassigned = true;\n\n          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n              if (sIdx !== s2Idx) toChange.push({\n                froms: sIdx,\n                tos: s2Idx,\n                hole: hIdx\n              });\n\n              if (hole_unassigned) {\n                hole_unassigned = false;\n                betterShapeHoles[s2Idx].push(ho);\n              } else {\n                ambiguous = true;\n              }\n            }\n          }\n\n          if (hole_unassigned) {\n            betterShapeHoles[sIdx].push(ho);\n          }\n        }\n      } // console.log(\"ambiguous: \", ambiguous);\n\n\n      if (toChange.length > 0) {\n        // console.log(\"to change: \", toChange);\n        if (!ambiguous) newShapeHoles = betterShapeHoles;\n      }\n    }\n\n    var tmpHoles;\n\n    for (var i = 0, il = newShapes.length; i < il; i++) {\n      tmpShape = newShapes[i].s;\n      shapes.push(tmpShape);\n      tmpHoles = newShapeHoles[i];\n\n      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {\n        tmpShape.holes.push(tmpHoles[j].h);\n      }\n    } //console.log(\"shape\", shapes);\n\n\n    return shapes;\n  }\n});\nexport { ShapePath };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/extras/core/ShapePath.js"],"names":["Color","Path","Shape","ShapeUtils","ShapePath","type","color","subPaths","currentPath","Object","assign","prototype","moveTo","x","y","push","lineTo","quadraticCurveTo","aCPx","aCPy","aX","aY","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","pts","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","shapes","i","l","length","tmpPath","tmpShape","curves","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","p","q","edgeLowPt","edgeHighPt","edgeDx","edgeDy","Math","abs","Number","EPSILON","perpEdge","isClockWise","solid","holesFirst","getPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","tmpPoints","undefined","s","h","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","froms","tos","hole","tmpHoles","il","j","jl","holes"],"mappings":"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","sourcesContent":["/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n **/\n\nimport { Color } from '../../math/Color.js';\nimport { Path } from './Path.js';\nimport { Shape } from './Shape.js';\nimport { ShapeUtils } from '../ShapeUtils.js';\n\nfunction ShapePath() {\n\n\tthis.type = 'ShapePath';\n\n\tthis.color = new Color();\n\n\tthis.subPaths = [];\n\tthis.currentPath = null;\n\n}\n\nObject.assign( ShapePath.prototype, {\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t},\n\n\tsplineThru: function ( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\tvar subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n\nexport { ShapePath };\n"]},"metadata":{},"sourceType":"module"}