{"ast":null,"code":"/**\n * @author Emmett Lalish / elalish\n *\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\nimport { CubeUVReflectionMapping, GammaEncoding, LinearEncoding, LinearToneMapping, NearestFilter, NoBlending, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBM16Encoding, RGBM7Encoding, UnsignedByteType, sRGBEncoding } from \"../constants.js\";\nimport { BufferAttribute } from \"../core/BufferAttribute.js\";\nimport { BufferGeometry } from \"../core/BufferGeometry.js\";\nimport { Mesh } from \"../objects/Mesh.js\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera.js\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera.js\";\nimport { RawShaderMaterial } from \"../materials/RawShaderMaterial.js\";\nimport { Scene } from \"../scenes/Scene.js\";\nimport { Vector2 } from \"../math/Vector2.js\";\nimport { Vector3 } from \"../math/Vector3.js\";\nimport { WebGLRenderTarget } from \"../renderers/WebGLRenderTarget.js\";\nvar LOD_MIN = 4;\nvar LOD_MAX = 8;\nvar SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nvar EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nvar MAX_SAMPLES = 20;\nvar ENCODINGS = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\n\nvar _flatCamera = new OrthographicCamera();\n\nvar _blurMaterial = _getBlurShader(MAX_SAMPLES);\n\nvar _equirectShader = null;\nvar _cubemapShader = null;\n\nvar {\n  _lodPlanes,\n  _sizeLods,\n  _sigmas\n} = _createPlanes();\n\nvar _pingPongRenderTarget = null;\nvar _renderer = null;\nvar _oldTarget = null; // Golden Ratio\n\nvar PHI = (1 + Math.sqrt(5)) / 2;\nvar INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nvar _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];\n\nfunction PMREMGenerator(renderer) {\n  _renderer = renderer;\n\n  _compileMaterial(_blurMaterial);\n}\n\nPMREMGenerator.prototype = {\n  constructor: PMREMGenerator,\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene: function (scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = _renderer.getRenderTarget();\n\n    var cubeUVRenderTarget = _allocateTargets();\n\n    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      _blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    _applyPMREM(cubeUVRenderTarget);\n\n    _cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  },\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular: function (equirectangular) {\n    equirectangular.magFilter = NearestFilter;\n    equirectangular.minFilter = NearestFilter;\n    equirectangular.generateMipmaps = false;\n    return this.fromCubemap(equirectangular);\n  },\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap: function (cubemap) {\n    _oldTarget = _renderer.getRenderTarget();\n\n    var cubeUVRenderTarget = _allocateTargets(cubemap);\n\n    _textureToCubeUV(cubemap, cubeUVRenderTarget);\n\n    _applyPMREM(cubeUVRenderTarget);\n\n    _cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  },\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileCubemapShader: function () {\n    if (_cubemapShader == null) {\n      _cubemapShader = _getCubemapShader();\n\n      _compileMaterial(_cubemapShader);\n    }\n  },\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileEquirectangularShader: function () {\n    if (_equirectShader == null) {\n      _equirectShader = _getEquirectShader();\n\n      _compileMaterial(_equirectShader);\n    }\n  },\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose: function () {\n    _blurMaterial.dispose();\n\n    if (_cubemapShader != null) _cubemapShader.dispose();\n    if (_equirectShader != null) _equirectShader.dispose();\n\n    for (var i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  }\n};\n\nfunction _createPlanes() {\n  var _lodPlanes = [];\n  var _sizeLods = [];\n  var _sigmas = [];\n  var lod = LOD_MAX;\n\n  for (var i = 0; i < TOTAL_LODS; i++) {\n    var sizeLod = Math.pow(2, lod);\n\n    _sizeLods.push(sizeLod);\n\n    var sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    var texelSize = 1.0 / (sizeLod - 1);\n    var min = -texelSize / 2;\n    var max = 1 + texelSize / 2;\n    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    var cubeFaces = 6;\n    var vertices = 6;\n    var positionSize = 3;\n    var uvSize = 2;\n    var faceIndexSize = 1;\n    var position = new Float32Array(positionSize * vertices * cubeFaces);\n    var uv = new Float32Array(uvSize * vertices * cubeFaces);\n    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (var face = 0; face < cubeFaces; face++) {\n      var x = face % 3 * 2 / 3 - 1;\n      var y = face > 2 ? 0 : -1;\n      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      var fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    var planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    _lodPlanes,\n    _sizeLods,\n    _sigmas\n  };\n}\n\nfunction _allocateTargets(equirectangular) {\n  var params = {\n    magFilter: NearestFilter,\n    minFilter: NearestFilter,\n    generateMipmaps: false,\n    type: equirectangular ? equirectangular.type : UnsignedByteType,\n    format: equirectangular ? equirectangular.format : RGBEFormat,\n    encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,\n    depthBuffer: false,\n    stencilBuffer: false\n  };\n\n  var cubeUVRenderTarget = _createRenderTarget(params);\n\n  cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;\n  _pingPongRenderTarget = _createRenderTarget(params);\n  return cubeUVRenderTarget;\n}\n\nfunction _cleanup(outputTarget) {\n  _pingPongRenderTarget.dispose();\n\n  _renderer.setRenderTarget(_oldTarget);\n\n  outputTarget.scissorTest = false; // reset viewport and scissor\n\n  outputTarget.setSize(outputTarget.width, outputTarget.height);\n}\n\nfunction _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n  var fov = 90;\n  var aspect = 1;\n  var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n  var upSign = [1, 1, 1, 1, -1, 1];\n  var forwardSign = [1, 1, -1, -1, -1, 1];\n  var outputEncoding = _renderer.outputEncoding;\n  var toneMapping = _renderer.toneMapping;\n  var toneMappingExposure = _renderer.toneMappingExposure;\n\n  var clearColor = _renderer.getClearColor();\n\n  var clearAlpha = _renderer.getClearAlpha();\n\n  _renderer.toneMapping = LinearToneMapping;\n  _renderer.toneMappingExposure = 1.0;\n  _renderer.outputEncoding = LinearEncoding;\n  scene.scale.z *= -1;\n  var background = scene.background;\n\n  if (background && background.isColor) {\n    background.convertSRGBToLinear(); // Convert linear to RGBE\n\n    var maxComponent = Math.max(background.r, background.g, background.b);\n    var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n    background = background.multiplyScalar(Math.pow(2.0, -fExp));\n    var alpha = (fExp + 128.0) / 255.0;\n\n    _renderer.setClearColor(background, alpha);\n\n    scene.background = null;\n  }\n\n  for (var i = 0; i < 6; i++) {\n    var col = i % 3;\n\n    if (col == 0) {\n      cubeCamera.up.set(0, upSign[i], 0);\n      cubeCamera.lookAt(forwardSign[i], 0, 0);\n    } else if (col == 1) {\n      cubeCamera.up.set(0, 0, upSign[i]);\n      cubeCamera.lookAt(0, forwardSign[i], 0);\n    } else {\n      cubeCamera.up.set(0, upSign[i], 0);\n      cubeCamera.lookAt(0, 0, forwardSign[i]);\n    }\n\n    _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n    _renderer.setRenderTarget(cubeUVRenderTarget);\n\n    _renderer.render(scene, cubeCamera);\n  }\n\n  _renderer.toneMapping = toneMapping;\n  _renderer.toneMappingExposure = toneMappingExposure;\n  _renderer.outputEncoding = outputEncoding;\n\n  _renderer.setClearColor(clearColor, clearAlpha);\n\n  scene.scale.z *= -1;\n}\n\nfunction _textureToCubeUV(texture, cubeUVRenderTarget) {\n  var scene = new Scene();\n\n  if (texture.isCubeTexture) {\n    if (_cubemapShader == null) {\n      _cubemapShader = _getCubemapShader();\n    }\n  } else {\n    if (_equirectShader == null) {\n      _equirectShader = _getEquirectShader();\n    }\n  }\n\n  var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;\n  scene.add(new Mesh(_lodPlanes[0], material));\n  var uniforms = material.uniforms;\n  uniforms['envMap'].value = texture;\n\n  if (!texture.isCubeTexture) {\n    uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n  }\n\n  uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n  uniforms['outputEncoding'].value = ENCODINGS[texture.encoding];\n\n  _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n  _renderer.setRenderTarget(cubeUVRenderTarget);\n\n  _renderer.render(scene, _flatCamera);\n}\n\nfunction _compileMaterial(material) {\n  var tmpScene = new Scene();\n  tmpScene.add(new Mesh(_lodPlanes[0], material));\n\n  _renderer.compile(tmpScene, _flatCamera);\n}\n\nfunction _createRenderTarget(params) {\n  var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _applyPMREM(cubeUVRenderTarget) {\n  var autoClear = _renderer.autoClear;\n  _renderer.autoClear = false;\n\n  for (var i = 1; i < TOTAL_LODS; i++) {\n    var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n    var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n    _blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n  }\n\n  _renderer.autoClear = autoClear;\n}\n/**\n * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n * vertically and horizontally, but this breaks down on a cube. Here we apply\n * the blur latitudinally (around the poles), and then longitudinally (towards\n * the poles) to approximate the orthogonally-separable blur. It is least\n * accurate at the poles, but still does a decent job.\n */\n\n\nfunction _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n  _halfBlur(cubeUVRenderTarget, _pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n  _halfBlur(_pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n}\n\nfunction _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n  if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n    console.error('blur direction must be either latitudinal or longitudinal!');\n  } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n  var STANDARD_DEVIATIONS = 3;\n  var blurScene = new Scene();\n  blurScene.add(new Mesh(_lodPlanes[lodOut], _blurMaterial));\n  var blurUniforms = _blurMaterial.uniforms;\n  var pixels = _sizeLods[lodIn] - 1;\n  var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n  var sigmaPixels = sigmaRadians / radiansPerPixel;\n  var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n  if (samples > MAX_SAMPLES) {\n    console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n  }\n\n  var weights = [];\n  var sum = 0;\n\n  for (var i = 0; i < MAX_SAMPLES; ++i) {\n    var x = i / sigmaPixels;\n    var weight = Math.exp(-x * x / 2);\n    weights.push(weight);\n\n    if (i == 0) {\n      sum += weight;\n    } else if (i < samples) {\n      sum += 2 * weight;\n    }\n  }\n\n  for (var i = 0; i < weights.length; i++) {\n    weights[i] = weights[i] / sum;\n  }\n\n  blurUniforms['envMap'].value = targetIn.texture;\n  blurUniforms['samples'].value = samples;\n  blurUniforms['weights'].value = weights;\n  blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n  if (poleAxis) {\n    blurUniforms['poleAxis'].value = poleAxis;\n  }\n\n  blurUniforms['dTheta'].value = radiansPerPixel;\n  blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n  blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n  blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n  var outputSize = _sizeLods[lodOut];\n  var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n  var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n  _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n  _renderer.setRenderTarget(targetOut);\n\n  _renderer.render(blurScene, _flatCamera);\n}\n\nfunction _getBlurShader(maxSamples) {\n  var weights = new Float32Array(maxSamples);\n  var poleAxis = new Vector3(0, 1, 0);\n  var shaderMaterial = new RawShaderMaterial({\n    defines: {\n      'n': maxSamples\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${_getEncodings()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'SphericalGaussianBlur';\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  var texelSize = new Vector2(1, 1);\n  var shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'texelSize': {\n        value: texelSize\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${_getEncodings()}\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'EquirectangularToCubeUV';\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  var shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${_getEncodings()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'CubemapToCubeUV';\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t`;\n}\n\nfunction _getEncodings() {\n  return `\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t`;\n}\n\nexport { PMREMGenerator };","map":{"version":3,"sources":["D:/chrlab/src/component/panelComponent/Canvas/threejs/src/extras/PMREMGenerator.js"],"names":["CubeUVReflectionMapping","GammaEncoding","LinearEncoding","LinearToneMapping","NearestFilter","NoBlending","RGBDEncoding","RGBEEncoding","RGBEFormat","RGBM16Encoding","RGBM7Encoding","UnsignedByteType","sRGBEncoding","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","RawShaderMaterial","Scene","Vector2","Vector3","WebGLRenderTarget","LOD_MIN","LOD_MAX","SIZE_MAX","Math","pow","EXTRA_LOD_SIGMA","TOTAL_LODS","length","MAX_SAMPLES","ENCODINGS","_flatCamera","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_lodPlanes","_sizeLods","_sigmas","_createPlanes","_pingPongRenderTarget","_renderer","_oldTarget","PHI","sqrt","INV_PHI","_axisDirections","PMREMGenerator","renderer","_compileMaterial","prototype","constructor","fromScene","scene","sigma","near","far","getRenderTarget","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","magFilter","minFilter","generateMipmaps","fromCubemap","cubemap","_textureToCubeUV","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","dispose","i","lod","sizeLod","push","texelSize","min","max","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","uv","faceIndex","face","x","y","coordinates","set","fill","planes","setAttribute","params","type","format","encoding","depthBuffer","stencilBuffer","_createRenderTarget","outputTarget","setRenderTarget","scissorTest","setSize","width","height","fov","aspect","cubeCamera","upSign","forwardSign","outputEncoding","toneMapping","toneMappingExposure","clearColor","getClearColor","clearAlpha","getClearAlpha","scale","z","background","isColor","convertSRGBToLinear","maxComponent","r","g","b","fExp","ceil","log2","multiplyScalar","alpha","setClearColor","col","up","lookAt","_setViewport","render","texture","isCubeTexture","material","add","uniforms","value","image","tmpScene","compile","mapping","name","target","viewport","scissor","autoClear","poleAxis","lodIn","lodOut","_halfBlur","targetIn","targetOut","sigmaRadians","direction","console","error","STANDARD_DEVIATIONS","blurScene","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","floor","warn","weights","sum","weight","exp","outputSize","maxSamples","shaderMaterial","defines","vertexShader","_getCommonVertexShader","fragmentShader","_getEncodings","blending","depthTest","depthWrite"],"mappings":"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","sourcesContent":["/**\n * @author Emmett Lalish / elalish\n *\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\n\nimport {\n\tCubeUVReflectionMapping,\n\tGammaEncoding,\n\tLinearEncoding,\n\tLinearToneMapping,\n\tNearestFilter,\n\tNoBlending,\n\tRGBDEncoding,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBM16Encoding,\n\tRGBM7Encoding,\n\tUnsignedByteType,\n\tsRGBEncoding\n} from \"../constants.js\";\n\nimport { BufferAttribute } from \"../core/BufferAttribute.js\";\nimport { BufferGeometry } from \"../core/BufferGeometry.js\";\nimport { Mesh } from \"../objects/Mesh.js\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera.js\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera.js\";\nimport { RawShaderMaterial } from \"../materials/RawShaderMaterial.js\";\nimport { Scene } from \"../scenes/Scene.js\";\nimport { Vector2 } from \"../math/Vector2.js\";\nimport { Vector3 } from \"../math/Vector3.js\";\nimport { WebGLRenderTarget } from \"../renderers/WebGLRenderTarget.js\";\n\nvar LOD_MIN = 4;\nvar LOD_MAX = 8;\nvar SIZE_MAX = Math.pow( 2, LOD_MAX );\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nvar EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\nvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nvar MAX_SAMPLES = 20;\nvar ENCODINGS = {\n\t[ LinearEncoding ]: 0,\n\t[ sRGBEncoding ]: 1,\n\t[ RGBEEncoding ]: 2,\n\t[ RGBM7Encoding ]: 3,\n\t[ RGBM16Encoding ]: 4,\n\t[ RGBDEncoding ]: 5,\n\t[ GammaEncoding ]: 6\n};\n\nvar _flatCamera = new OrthographicCamera();\nvar _blurMaterial = _getBlurShader( MAX_SAMPLES );\nvar _equirectShader = null;\nvar _cubemapShader = null;\n\nvar { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();\nvar _pingPongRenderTarget = null;\nvar _renderer = null;\n\nvar _oldTarget = null;\n\n// Golden Ratio\nvar PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nvar INV_PHI = 1 / PHI;\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nvar _axisDirections = [\n\tnew Vector3( 1, 1, 1 ),\n\tnew Vector3( - 1, 1, 1 ),\n\tnew Vector3( 1, 1, - 1 ),\n\tnew Vector3( - 1, 1, - 1 ),\n\tnew Vector3( 0, PHI, INV_PHI ),\n\tnew Vector3( 0, PHI, - INV_PHI ),\n\tnew Vector3( INV_PHI, 0, PHI ),\n\tnew Vector3( - INV_PHI, 0, PHI ),\n\tnew Vector3( PHI, INV_PHI, 0 ),\n\tnew Vector3( - PHI, INV_PHI, 0 ) ];\n\nfunction PMREMGenerator( renderer ) {\n\n\t_renderer = renderer;\n\t_compileMaterial( _blurMaterial );\n\n}\n\nPMREMGenerator.prototype = {\n\n\tconstructor: PMREMGenerator,\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = _renderer.getRenderTarget();\n\t\tvar cubeUVRenderTarget = _allocateTargets();\n\t\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\t\tif ( sigma > 0 ) {\n\n\t\t\t_blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\t\t_applyPMREM( cubeUVRenderTarget );\n\t\t_cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t},\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular: function ( equirectangular ) {\n\n\t\tequirectangular.magFilter = NearestFilter;\n\t\tequirectangular.minFilter = NearestFilter;\n\t\tequirectangular.generateMipmaps = false;\n\n\t\treturn this.fromCubemap( equirectangular );\n\n\t},\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap: function ( cubemap ) {\n\n\t\t_oldTarget = _renderer.getRenderTarget();\n\t\tvar cubeUVRenderTarget = _allocateTargets( cubemap );\n\t\t_textureToCubeUV( cubemap, cubeUVRenderTarget );\n\t\t_applyPMREM( cubeUVRenderTarget );\n\t\t_cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t},\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader: function () {\n\n\t\tif ( _cubemapShader == null ) {\n\n\t\t\t_cubemapShader = _getCubemapShader();\n\t\t\t_compileMaterial( _cubemapShader );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader: function () {\n\n\t\tif ( _equirectShader == null ) {\n\n\t\t\t_equirectShader = _getEquirectShader();\n\t\t\t_compileMaterial( _equirectShader );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose: function () {\n\n\t\t_blurMaterial.dispose();\n\n\t\tif ( _cubemapShader != null ) _cubemapShader.dispose();\n\t\tif ( _equirectShader != null ) _equirectShader.dispose();\n\n\t\tfor ( var i = 0; i < _lodPlanes.length; i ++ ) {\n\n\t\t\t_lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t},\n\n};\n\nfunction _createPlanes() {\n\n\tvar _lodPlanes = [];\n\tvar _sizeLods = [];\n\tvar _sigmas = [];\n\n\tvar lod = LOD_MAX;\n\tfor ( var i = 0; i < TOTAL_LODS; i ++ ) {\n\n\t\tvar sizeLod = Math.pow( 2, lod );\n\t\t_sizeLods.push( sizeLod );\n\t\tvar sigma = 1.0 / sizeLod;\n\t\tif ( i > LOD_MAX - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\n\n\t\t} else if ( i == 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\t\t_sigmas.push( sigma );\n\n\t\tvar texelSize = 1.0 / ( sizeLod - 1 );\n\t\tvar min = - texelSize / 2;\n\t\tvar max = 1 + texelSize / 2;\n\t\tvar uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tvar cubeFaces = 6;\n\t\tvar vertices = 6;\n\t\tvar positionSize = 3;\n\t\tvar uvSize = 2;\n\t\tvar faceIndexSize = 1;\n\n\t\tvar position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tvar uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tvar faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( var face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tvar x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tvar y = face > 2 ? 0 : - 1;\n\t\t\tvar coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tvar fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\t\tvar planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\t_lodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\treturn { _lodPlanes, _sizeLods, _sigmas };\n\n}\n\nfunction _allocateTargets( equirectangular ) {\n\n\tvar params = {\n\t\tmagFilter: NearestFilter,\n\t\tminFilter: NearestFilter,\n\t\tgenerateMipmaps: false,\n\t\ttype: equirectangular ? equirectangular.type : UnsignedByteType,\n\t\tformat: equirectangular ? equirectangular.format : RGBEFormat,\n\t\tencoding: equirectangular ? equirectangular.encoding : RGBEEncoding,\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false\n\t};\n\tvar cubeUVRenderTarget = _createRenderTarget( params );\n\tcubeUVRenderTarget.depthBuffer = equirectangular ? false : true;\n\t_pingPongRenderTarget = _createRenderTarget( params );\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _cleanup( outputTarget ) {\n\n\t_pingPongRenderTarget.dispose();\n\t_renderer.setRenderTarget( _oldTarget );\n\toutputTarget.scissorTest = false;\n\t// reset viewport and scissor\n\toutputTarget.setSize( outputTarget.width, outputTarget.height );\n\n}\n\nfunction _sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\tvar fov = 90;\n\tvar aspect = 1;\n\tvar cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\tvar upSign = [ 1, 1, 1, 1, - 1, 1 ];\n\tvar forwardSign = [ 1, 1, - 1, - 1, - 1, 1 ];\n\n\tvar outputEncoding = _renderer.outputEncoding;\n\tvar toneMapping = _renderer.toneMapping;\n\tvar toneMappingExposure = _renderer.toneMappingExposure;\n\tvar clearColor = _renderer.getClearColor();\n\tvar clearAlpha = _renderer.getClearAlpha();\n\n\t_renderer.toneMapping = LinearToneMapping;\n\t_renderer.toneMappingExposure = 1.0;\n\t_renderer.outputEncoding = LinearEncoding;\n\tscene.scale.z *= - 1;\n\n\tvar background = scene.background;\n\tif ( background && background.isColor ) {\n\n\t\tbackground.convertSRGBToLinear();\n\t\t// Convert linear to RGBE\n\t\tvar maxComponent = Math.max( background.r, background.g, background.b );\n\t\tvar fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\n\t\tbackground = background.multiplyScalar( Math.pow( 2.0, - fExp ) );\n\t\tvar alpha = ( fExp + 128.0 ) / 255.0;\n\t\t_renderer.setClearColor( background, alpha );\n\t\tscene.background = null;\n\n\t}\n\n\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\tvar col = i % 3;\n\t\tif ( col == 0 ) {\n\n\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t} else if ( col == 1 ) {\n\n\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t} else {\n\n\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t}\n\t\t_setViewport( cubeUVRenderTarget,\n\t\t\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\n\t\t_renderer.setRenderTarget( cubeUVRenderTarget );\n\t\t_renderer.render( scene, cubeCamera );\n\n\t}\n\n\t_renderer.toneMapping = toneMapping;\n\t_renderer.toneMappingExposure = toneMappingExposure;\n\t_renderer.outputEncoding = outputEncoding;\n\t_renderer.setClearColor( clearColor, clearAlpha );\n\tscene.scale.z *= - 1;\n\n}\n\nfunction _textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\tvar scene = new Scene();\n\tif ( texture.isCubeTexture ) {\n\n\t\tif ( _cubemapShader == null ) {\n\n\t\t\t_cubemapShader = _getCubemapShader();\n\n\t\t}\n\n\t} else {\n\n\t\tif ( _equirectShader == null ) {\n\n\t\t\t_equirectShader = _getEquirectShader();\n\n\t\t}\n\n\t}\n\tvar material = texture.isCubeTexture ? _cubemapShader : _equirectShader;\n\tscene.add( new Mesh( _lodPlanes[ 0 ], material ) );\n\tvar uniforms = material.uniforms;\n\n\tuniforms[ 'envMap' ].value = texture;\n\tif ( ! texture.isCubeTexture ) {\n\n\t\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\n\n\t}\n\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\n\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\n\t_renderer.setRenderTarget( cubeUVRenderTarget );\n\t_renderer.render( scene, _flatCamera );\n\n}\n\nfunction _compileMaterial( material ) {\n\n\tvar tmpScene = new Scene();\n\ttmpScene.add( new Mesh( _lodPlanes[ 0 ], material ) );\n\t_renderer.compile( tmpScene, _flatCamera );\n\n}\n\nfunction _createRenderTarget( params ) {\n\n\tvar cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _applyPMREM( cubeUVRenderTarget ) {\n\n\tvar autoClear = _renderer.autoClear;\n\t_renderer.autoClear = false;\n\n\tfor ( var i = 1; i < TOTAL_LODS; i ++ ) {\n\n\t\tvar sigma = Math.sqrt(\n\t\t\t_sigmas[ i ] * _sigmas[ i ] -\n\t\t_sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\n\t\tvar poleAxis =\n\t\t_axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\t\t_blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t}\n\n\t_renderer.autoClear = autoClear;\n\n}\n\n/**\n * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n * vertically and horizontally, but this breaks down on a cube. Here we apply\n * the blur latitudinally (around the poles), and then longitudinally (towards\n * the poles) to approximate the orthogonally-separable blur. It is least\n * accurate at the poles, but still does a decent job.\n */\nfunction _blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t_halfBlur(\n\t\tcubeUVRenderTarget,\n\t\t_pingPongRenderTarget,\n\t\tlodIn,\n\t\tlodOut,\n\t\tsigma,\n\t\t'latitudinal',\n\t\tpoleAxis );\n\n\t_halfBlur(\n\t\t_pingPongRenderTarget,\n\t\tcubeUVRenderTarget,\n\t\tlodOut,\n\t\tlodOut,\n\t\tsigma,\n\t\t'longitudinal',\n\t\tpoleAxis );\n\n}\n\nfunction _halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\tconsole.error(\n\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t}\n\n\t// Number of standard deviations at which to cut off the discrete approximation.\n\tvar STANDARD_DEVIATIONS = 3;\n\n\tvar blurScene = new Scene();\n\tblurScene.add( new Mesh( _lodPlanes[ lodOut ], _blurMaterial ) );\n\tvar blurUniforms = _blurMaterial.uniforms;\n\n\tvar pixels = _sizeLods[ lodIn ] - 1;\n\tvar radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\tvar sigmaPixels = sigmaRadians / radiansPerPixel;\n\tvar samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\tif ( samples > MAX_SAMPLES ) {\n\n\t\tconsole.warn( `sigmaRadians, ${\n\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t}\n\n\tvar weights = [];\n\tvar sum = 0;\n\n\tfor ( var i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\tvar x = i / sigmaPixels;\n\t\tvar weight = Math.exp( - x * x / 2 );\n\t\tweights.push( weight );\n\n\t\tif ( i == 0 ) {\n\n\t\t\tsum += weight;\n\n\t\t} else if ( i < samples ) {\n\n\t\t\tsum += 2 * weight;\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < weights.length; i ++ ) {\n\n\t\tweights[ i ] = weights[ i ] / sum;\n\n\t}\n\n\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\tblurUniforms[ 'samples' ].value = samples;\n\tblurUniforms[ 'weights' ].value = weights;\n\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\tif ( poleAxis ) {\n\n\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t}\n\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\n\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\n\tvar outputSize = _sizeLods[ lodOut ];\n\tvar x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\n\tvar y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) +\n\t2 * outputSize *\n\t\t( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\n\n\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t_renderer.setRenderTarget( targetOut );\n\t_renderer.render( blurScene, _flatCamera );\n\n}\n\nfunction _getBlurShader( maxSamples ) {\n\n\tvar weights = new Float32Array( maxSamples );\n\tvar poleAxis = new Vector3( 0, 1, 0 );\n\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\tdefines: { 'n': maxSamples },\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${_getEncodings()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\tshaderMaterial.type = 'SphericalGaussianBlur';\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectShader() {\n\n\tvar texelSize = new Vector2( 1, 1 );\n\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'texelSize': { value: texelSize },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${_getEncodings()}\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\tshaderMaterial.type = 'EquirectangularToCubeUV';\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCubemapShader() {\n\n\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${_getEncodings()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\tshaderMaterial.type = 'CubemapToCubeUV';\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t`;\n\n}\n\nfunction _getEncodings() {\n\n\treturn `\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t`;\n\n}\n\nexport { PMREMGenerator };\n"]},"metadata":{},"sourceType":"module"}