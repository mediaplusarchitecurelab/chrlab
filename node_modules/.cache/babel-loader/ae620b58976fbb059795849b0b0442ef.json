{"ast":null,"code":"import { Vector2 } from '../../math/Vector2.js';\nimport { CurvePath } from './CurvePath.js';\nimport { EllipseCurve } from '../curves/EllipseCurve.js';\nimport { SplineCurve } from '../curves/SplineCurve.js';\nimport { CubicBezierCurve } from '../curves/CubicBezierCurve.js';\nimport { QuadraticBezierCurve } from '../curves/QuadraticBezierCurve.js';\nimport { LineCurve } from '../curves/LineCurve.js';\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n **/\n\nfunction Path(points) {\n  CurvePath.call(this);\n  this.type = 'Path';\n  this.currentPoint = new Vector2();\n\n  if (points) {\n    this.setFromPoints(points);\n  }\n}\n\nPath.prototype = Object.assign(Object.create(CurvePath.prototype), {\n  constructor: Path,\n  setFromPoints: function (points) {\n    this.moveTo(points[0].x, points[0].y);\n\n    for (var i = 1, l = points.length; i < l; i++) {\n      this.lineTo(points[i].x, points[i].y);\n    }\n\n    return this;\n  },\n  moveTo: function (x, y) {\n    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n    return this;\n  },\n  lineTo: function (x, y) {\n    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n    this.curves.push(curve);\n    this.currentPoint.set(x, y);\n    return this;\n  },\n  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {\n    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  },\n  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  },\n  splineThru: function (pts\n  /*Array of Vector*/\n  ) {\n    var npts = [this.currentPoint.clone()].concat(pts);\n    var curve = new SplineCurve(npts);\n    this.curves.push(curve);\n    this.currentPoint.copy(pts[pts.length - 1]);\n    return this;\n  },\n  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    var x0 = this.currentPoint.x;\n    var y0 = this.currentPoint.y;\n    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  },\n  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  },\n  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    var x0 = this.currentPoint.x;\n    var y0 = this.currentPoint.y;\n    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n    return this;\n  },\n  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n    if (this.curves.length > 0) {\n      // if a previous curve is present, attempt to join\n      var firstPoint = curve.getPoint(0);\n\n      if (!firstPoint.equals(this.currentPoint)) {\n        this.lineTo(firstPoint.x, firstPoint.y);\n      }\n    }\n\n    this.curves.push(curve);\n    var lastPoint = curve.getPoint(1);\n    this.currentPoint.copy(lastPoint);\n    return this;\n  },\n  copy: function (source) {\n    CurvePath.prototype.copy.call(this, source);\n    this.currentPoint.copy(source.currentPoint);\n    return this;\n  },\n  toJSON: function () {\n    var data = CurvePath.prototype.toJSON.call(this);\n    data.currentPoint = this.currentPoint.toArray();\n    return data;\n  },\n  fromJSON: function (json) {\n    CurvePath.prototype.fromJSON.call(this, json);\n    this.currentPoint.fromArray(json.currentPoint);\n    return this;\n  }\n});\nexport { Path };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/extras/core/Path.js"],"names":["Vector2","CurvePath","EllipseCurve","SplineCurve","CubicBezierCurve","QuadraticBezierCurve","LineCurve","Path","points","call","type","currentPoint","setFromPoints","prototype","Object","assign","create","constructor","moveTo","x","y","i","l","length","lineTo","set","curve","clone","curves","push","quadraticCurveTo","aCPx","aCPy","aX","aY","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","pts","npts","concat","copy","arc","aRadius","aStartAngle","aEndAngle","aClockwise","x0","y0","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","firstPoint","getPoint","equals","lastPoint","source","toJSON","data","toArray","fromJSON","json","fromArray"],"mappings":"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","sourcesContent":["import { Vector2 } from '../../math/Vector2.js';\nimport { CurvePath } from './CurvePath.js';\nimport { EllipseCurve } from '../curves/EllipseCurve.js';\nimport { SplineCurve } from '../curves/SplineCurve.js';\nimport { CubicBezierCurve } from '../curves/CubicBezierCurve.js';\nimport { QuadraticBezierCurve } from '../curves/QuadraticBezierCurve.js';\nimport { LineCurve } from '../curves/LineCurve.js';\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n **/\n\nfunction Path( points ) {\n\n\tCurvePath.call( this );\n\n\tthis.type = 'Path';\n\n\tthis.currentPoint = new Vector2();\n\n\tif ( points ) {\n\n\t\tthis.setFromPoints( points );\n\n\t}\n\n}\n\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\tconstructor: Path,\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tvar curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurvePath.prototype.copy.call( this, source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = CurvePath.prototype.toJSON.call( this );\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurvePath.prototype.fromJSON.call( this, json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { Path };\n"]},"metadata":{},"sourceType":"module"}