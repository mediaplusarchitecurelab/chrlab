{"ast":null,"code":"import * as THREE from '../../threejs/src/Three.js'; //import SceneSubject from './SceneSubject';\n\nimport GeneralLights from './GeneralLights';\nimport * as dat from 'dat.gui';\nimport { OBJLoader } from '../../threejs/examples/jsm/loaders/OBJLoader.js';\nimport { EffectComposer } from '../../threejs/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from '../../threejs/examples/jsm/postprocessing/RenderPass.js';\nimport { FilmPass } from '../../threejs/examples/jsm/postprocessing/FilmPass.js';\nimport { BloomPass } from '../../threejs/examples/jsm/postprocessing/BloomPass.js';\nimport { ShaderPass } from '../../threejs/examples/jsm/postprocessing/ShaderPass.js';\nimport { SobelOperatorShader } from '../../threejs/examples/jsm/shaders/SobelOperatorShader.js';\nimport { OutlinePass } from '../../threejs/examples/jsm/postprocessing/OutlinePass.js'; //\n//import { MeshText2D, textAlign } from '../../threejs/examples/jsm/postprocessing/three-text2d';\n//import SpriteText from 'three-spritetext';\n// two kinds class\n// curve >> [] with geoCmap\n\n/*\r\nuserData {\r\n            \"nodes\": nidlstr,\r\n            \"nodesVec\": npts,\r\n            \"disteach\": diststr,\r\n            \"locked\": false\r\n        };\r\n*/\n// vertex >> [] with geoVmap\n\n/*\r\nuserData {\r\n            \"object\":object,\r\n            \"tag\": vvtag,\r\n            \"tagnormal\": vt,\r\n            \"locked\": false\r\n        };\r\n*/\n\nimport $ from 'jquery'; //const glsl = require('glslify');\n\nconst OrbitControls = require('three-orbit-controls')(THREE);\n\nconst textureLoader = new THREE.TextureLoader();\nexport default (canvas => {\n  // objects\n  var request;\n  var loader;\n  var parmfont;\n  const ssnodeurl = 'https://spreadsheets.google.com/feeds/list/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/1/public/values?alt=json';\n  const sscrvurl = 'https://spreadsheets.google.com/feeds/list/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/2/public/values?alt=json';\n  const exeurl = 'https://script.google.com/macros/s/AKfycbyYhxPfFDvS1nPTuDg9n5SZLYwbzaD6zqVbBkVJzzEWDoWjW6B8/exec';\n  const ssnodeurledit = 'https://docs.google.com/spreadsheets/d/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/edit?usp=sharing'; //var geos = new THREE.Group();\n  //var geoVmap, geoCrvmap;\n\n  var geoVmap = [];\n  var geoCmap = [];\n  var geo, geoPts, geoLines;\n  var backgroundcube, text; // as Three.Group = children[0] = frontface / children[1] = backface\n\n  var geoSelected;\n  var geoAll = [];\n  var geoFinished = [];\n  var geoPossible = [];\n  var geoLocked = [];\n  var cLocked = []; // material\n\n  var t1, t2, uniforms;\n  var matColor, matFinColor, matPosColor, matShader, matWireframe, matGradient, matShaderSub, matHidden, matLine;\n  var matFinished, matFinishedBack, matPossible, matLocked, matPossibleBack, matFade, matFadeBack;\n  var matFinishedArray, matPossibleArray, matFadeArray;\n  var textloader = new THREE.FontLoader(); // renderer\n\n  var composer, outlinePass; // control\n\n  var raycaster = new THREE.Raycaster();\n  var mouse = new THREE.Vector2();\n  var screen = new THREE.Vector2();\n  var pieceSelected = false;\n  var textFinished = '';\n  var texetAll = '';\n  var nodeSize = 0.6;\n  var pipeDegree = 20; // default as 64\n\n  var pipeSize = 0.3;\n  var pipeRacial = 4;\n  var pipeClose = false; // GUI\n\n  var gui, guiData, shading;\n  var tagratio = 2.0;\n  var tagdist = 1.0;\n  const clock = new THREE.Clock();\n  const screenDimensions = {\n    width: canvas.width,\n    height: canvas.height,\n    halfwidth: canvas.width * 0.5,\n    halfheight: canvas.height * 0.5\n  };\n  const pannelSize = {\n    width: canvas.width,\n    height: canvas.height,\n    halfwidth: canvas.width * 0.5,\n    halfheight: canvas.height * 0.5\n  };\n  var displayFolder, teamCallbackFolder; // build\n\n  const scene = buildScene();\n  const camera = buildCamera(screenDimensions);\n  const renderer = buildRender(screenDimensions);\n  const controls = new OrbitControls(camera, renderer.domElement);\n  controls.target.set(0, 1, 0);\n  controls.update();\n  const customContainer = document.getElementById('canvas-gui-container');\n  const lights = GeneralLights(scene);\n  createSceneSubjects(scene, uniforms); // textture\n\n  textureLoader.setPath('./assets/textures/sprites/').load('spark1.png', tex1 => {\n    t1 = tex1;\n    uniforms = {\n      pointTexture: {\n        value: t1\n      }\n    };\n  }, xhr1 => {\n    console.log(xhr1.loaded / xhr1.total * 100 + '% loaded');\n  }, xhr1 => {\n    console.log('An error happened');\n  }); //parmfont = new THREE.Font( fontJson );\n\n  function preload() {\n    // load url1\n    fetch(ssnodeurl).then(response => {\n      return response.text();\n    }).then(data => {\n      // do url1data\n      let val = JSON.parse(data);\n      encodenode(val); // load url2\n\n      fetch(sscrvurl).then(response2 => {\n        return response2.text();\n      }).then(data2 => {\n        // do url2data\n        let val2 = JSON.parse(data2);\n        encodecrv(val2);\n      }).catch(error2 => {\n        console.log(error2);\n      });\n    }).catch(error => {\n      console.log(error);\n    }); // font\n\n    /*\r\n    let sprite = new TextSprite({\r\n          fillStyle: '#ff0000',\r\n          fontFamily: '\"Times New Roman\", Times, serif',\r\n          fontSize: 10,\r\n          fontStyle: 'italic',\r\n          text: 'aa',\r\n        });\r\n        scene.add(sprite); \r\n    */\n    //console.log(geoVmap);\n    //loadJSON(ssjointurl, encodejoint);\n  }\n\n  function makeLabel(msg, size, pos, ratio) {\n    //const borderSize = 1;\n    let canvastxt = document.createElement('canvas');\n    let ctx = canvastxt.getContext('2d');\n    ctx.font = size + 'px Arial'; // measure how long the name will be\n    //ctx.canvas.width = ctx.measureText(msg).width;\n\n    ctx.canvas.width = size * 1.75;\n    ctx.canvas.height = size * 1.75; //ctx.canvas.height = size;\n\n    /*            \r\n                if (msg.length===1) {\r\n                    //size*=0.5;\r\n                    ctx.canvas.width = ctx.measureText(msg).width*0.5;\r\n                    ctx.canvas.height = size; // fontsize * 1.5\r\n                }\r\n                else if (msg.length===2) {\r\n                    //size*=1.0;\r\n                    ctx.canvas.width = ctx.measureText(msg).width;\r\n                    ctx.canvas.height = size;\r\n                }\r\n                else if (msg.length===3) {\r\n                    //size*=1.5;\r\n                    ctx.canvas.width = ctx.measureText(msg).width*1.5;\r\n                    ctx.canvas.height = size;\r\n                }\r\n    */\n    // after setting the canvas width/height we have to re-set font to apply!?! looks like ctx reset\n\n    ctx.font = size + \"px Arial\";\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center'; //ctx.fillStyle = 'white';\n    //ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);\n    ctx.fillStyle = 'red';\n    ctx.fillText(msg, 0, 0);\n    let texture = new THREE.CanvasTexture(ctx.canvas);\n    texture.minFilter = THREE.LinearFilter; //texture.wrapS = THREE.ClampToEdgeWrapping;\n    //texture.wrapT = THREE.ClampToEdgeWrapping;\n\n    let matTag = new THREE.SpriteMaterial({\n      map: texture,\n      transparent: true\n    });\n    let tag = new THREE.Sprite(matTag);\n    tag.scale.x = ratio;\n    tag.scale.y = ratio;\n    tag.scale.z = ratio;\n    tag.position.x = pos.x;\n    tag.position.y = pos.y;\n    tag.position.z = pos.z;\n    tag.visible = false;\n    scene.add(tag);\n    return tag;\n  }\n\n  function encodenode(data) {\n    let vs = [];\n    let geoMesh = new THREE.SphereBufferGeometry(nodeSize);\n    geoMesh.castShadow = true; //geoVtMesh = new THREE.InstancedMesh( geoVertics, matFinished, count );\n\n    for (let i = 0; i < data.feed.entry.length; i += 1) {\n      let nidlocked = data.feed.entry[i].gsx$locked.$t === '0' ? false : true;\n      let object = nidlocked ? new THREE.Mesh(geoMesh, matLocked) : new THREE.Mesh(geoMesh, matFinished);\n      let vv = new THREE.Vector3(parseFloat(data.feed.entry[i].gsx$x.$t), parseFloat(data.feed.entry[i].gsx$z.$t), parseFloat(data.feed.entry[i].gsx$y.$t));\n      let vt = new THREE.Vector3(parseFloat(data.feed.entry[i].gsx$nx.$t) * -1, parseFloat(data.feed.entry[i].gsx$nz.$t) * -1, parseFloat(data.feed.entry[i].gsx$ny.$t) * -1);\n      let vvtag = makeLabel(i.toString(), 30, vt.clone().multiplyScalar(tagdist).add(vv), tagratio);\n      object.position.x = vv.x;\n      object.position.z = vv.z;\n      object.position.y = vv.y;\n      vv.userData = {\n        \"object\": object,\n        \"tag\": vvtag,\n        \"tagnormal\": vt,\n        \"locked\": nidlocked,\n        \"parent\": [] // not setted right now\n\n      };\n      /*\r\n      let  v= { \"id\": parseInt(data.feed.entry[i].gsx$id.$t),\r\n                \"node\": vv,  \r\n                \"mesh\":object\r\n              };\r\n      \r\n      let vvtag = new THREE.ShapeGeometry(\r\n          THREE.Font.generateShapes( \"i\", {\r\n              font: parmfont,\r\n              size: 2,\r\n          }));\r\n      \r\n      let vvtag = new THREE.Texture({\r\n          font: \"2px Arial\",\r\n          fillStyle:\"rgba(255,0,0)\",\r\n          fillText:i\r\n      })\r\n      \r\n      let vvtag = new THREE.TextSprite({\r\n        text: 'Hello World!',\r\n        fontFamily: 'Arial, Helvetica, sans-serif',\r\n        fontSize: 12,\r\n        fillColor: '#ffbbff',\r\n      });\r\n      \r\n      vv.userData={\r\n          \"tag\": vvtag\r\n      };\r\n      */\n\n      scene.add(object); //scene.add(vvtag);\n\n      geoVmap.push(vv);\n    } //geoVmap = vs;\n\n  }\n\n  function encodecrv(data) {\n    //let crvs = [];\n    //let geoMesh = new THREE.SphereBufferGeometry( 0.25 );\n    //geoVtMesh = new THREE.InstancedMesh( geoVertics, matFinished, count );\n    for (let i = 0; i < data.feed.entry.length; i += 1) {\n      let nidlstr = data.feed.entry[i].gsx$nid.$t.split('^');\n      let diststr = data.feed.entry[i].gsx$disteach.$t.split('^');\n      let cidlocked = data.feed.entry[i].gsx$locked.$t === '0' ? false : true; // data anaylsis\n\n      let npts = [];\n      nidlstr.forEach(v => {\n        npts.push(geoVmap[parseInt(v)]);\n      });\n      let spl = new THREE.CatmullRomCurve3(npts);\n      spl.curveType = 'catmullrom';\n      let tub = new THREE.TubeBufferGeometry(spl, pipeDegree, pipeSize, pipeRacial, pipeClose); //let pipe = new THREE.Mesh( new THREE.TubeBufferGeometry( spl, pipeDegree, pipeSize, pipeRacial, pipeClose), matFade);\n\n      let name = 'crv_' + data.feed.entry[i].gsx$id.$t;\n      let pipe = cidlocked ? new THREE.Mesh(tub, matLocked) : new THREE.Mesh(tub, matFade);\n      pipe.name = name;\n      npts.forEach((nv, i) => {\n        nv.userData.parent.push(pipe);\n      });\n      pipe.userData = {\n        \"object\": pipe,\n        \"nodes\": nidlstr,\n        \"nodesVec\": npts,\n        \"disteach\": diststr,\n        \"locked\": cidlocked\n      };\n      pipe.castShadow = true;\n      /*\r\n      let crv = {\r\n          \"name\": name,\r\n          \"curve\": spl,\r\n          \"pipe\": pipe,\r\n          \"disteach\": diststr\r\n      }\r\n      */\n\n      scene.add(pipe);\n      geoCmap.push(pipe);\n    }\n\n    ; //console.log(geoCrvmap );\n  } // function below\n\n\n  function buildScene() {\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#a0a0a0');\n    scene.fog = new THREE.Fog(0xa0a0a0, 10, 100);\n    return scene;\n  }\n\n  function buildRender({\n    width,\n    height\n  }) {\n    const renderer = new THREE.WebGLRenderer({\n      canvas: canvas,\n      antialias: true,\n      alpha: true\n    });\n    const DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;\n    renderer.shadowMap.enabled = true;\n    renderer.localClippingEnabled = false;\n    renderer.setPixelRatio(DPR);\n    renderer.setSize(width, height);\n    renderer.autoClear = false;\n    renderer.toneMapping = THREE.ReinhardToneMapping; // post\n\n    composer = new EffectComposer(renderer);\n    var renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    outlinePass = new OutlinePass(new THREE.Vector2(width, height), scene, camera);\n    outlinePass.edgeStrength = 2.0;\n    outlinePass.edgeGlow = 0.0;\n    outlinePass.edgeThickness = 0.7;\n    outlinePass.pulsePeriod = 0;\n    outlinePass.visibleEdgeColor.set('#ff0000');\n    outlinePass.hiddenEdgeColor.set('#190a05');\n    composer.addPass(outlinePass);\n    return renderer;\n  } // input function    \n\n\n  function onProgress(xhr) {\n    if (xhr.lengthComputable) {\n      var percentComplete = xhr.loaded / xhr.total * 100;\n      console.log('model ' + Math.round(percentComplete, 2) + '% downloaded');\n    }\n  }\n\n  function onError() {\n    console.log('error!!');\n  }\n\n  function buildCamera({\n    width,\n    height\n  }) {\n    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 160);\n    camera.position.set(70, 70, 0);\n    return camera;\n  }\n\n  function createSceneSubjects(scene, uniforms) {\n    // material 1\n    backgroundcube = new THREE.CubeTextureLoader().setPath('./assets/textures/cube/pisa/').load(['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png']);\n    matLine = new THREE.LineBasicMaterial({\n      color: 0xff00ff\n    });\n    matFade = new THREE.MeshPhongMaterial({\n      color: 0xeeeeee,\n      transparent: true,\n      opacity: 0.7,\n      roughness: 0.9,\n      depthTest: true,\n      depthWrite: true,\n      flatShading: true,\n      side: THREE.FrontSide\n    });\n    matFadeBack = new THREE.MeshBasicMaterial({\n      color: 0x555555,\n      transparent: true,\n      opacity: 0.7,\n      side: THREE.BackSide\n    });\n    matFadeArray = [matFade, matFadeBack];\n    matFinished = new THREE.MeshPhongMaterial({\n      color: 0x21ce94,\n      emssive: 0x0,\n      specular: 0x111111,\n      shininess: 30,\n      roughness: 0.9,\n      depthTest: true,\n      depthWrite: true,\n      //envMap: backgroundcube,\n      flatShading: true,\n      side: THREE.FrontSide\n    });\n    matFinishedBack = new THREE.MeshBasicMaterial({\n      color: 0x555594,\n      side: THREE.BackSide\n    });\n    matFinishedArray = [matFinished, matFinishedBack];\n    matLocked = new THREE.MeshStandardMaterial({\n      color: 0xeee143,\n      transparent: true,\n      opacity: 0.7,\n      roughness: 0.9,\n      depthTest: true,\n      depthWrite: true,\n      flatShading: true,\n      side: THREE.FrontSide\n    });\n    matPossibleBack = new THREE.MeshBasicMaterial({\n      color: 0x888122,\n      transparent: true,\n      opacity: 0.7,\n      side: THREE.BackSide\n    });\n    matPossibleArray = [matPossible, matPossibleBack];\n    matShaderSub = new THREE.LineBasicMaterial({\n      vertexColors: THREE.VertexColors,\n      blending: THREE.AdditiveBlending,\n      transparent: true\n    });\n    matHidden = new THREE.MeshBasicMaterial({\n      color: matColor,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      opacity: 0.1\n    }); // material 3\n\n    matWireframe = new THREE.MeshBasicMaterial({\n      color: matColor,\n      wireframe: true\n    }); // material 4\n\n    matGradient = new THREE.MeshLambertMaterial({\n      vertexColors: THREE.VertexColors,\n      side: THREE.DoubleSide\n    }); // background     \n\n    var ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(400, 400, 1, 1), new THREE.MeshPhongMaterial({\n      color: 0x999999,\n      shininess: 150,\n      depthWrite: false\n    }));\n    ground.rotation.x = -Math.PI / 2; // rotates X/Y to X/Z\n\n    ground.receiveShadow = true; //ground.name='ground';          \n\n    scene.add(ground);\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mousedown', onDown, false); // subject\n\n    createGUI();\n    initModel();\n  }\n\n  function createGUI() {\n    //GUI\n    //if ( gui ) gui.destroy();\n    gui = new dat.GUI({\n      autoPlace: false\n    });\n    /*\r\n    guiData = {\r\n        'tagdist': tagdist\r\n            }.name( 'GUIedit' ).onChange( updateModel );\r\n    gui.add();\r\n    */\n    // display floder\n\n    displayFolder = gui.addFolder('Display');\n    var displayParams = {\n      // tagdist\n      get 'TagDistance'() {\n        return tagdist;\n      },\n\n      set 'TagDistance'(v) {\n        tagdist = v;\n        updateModel(0);\n      },\n\n      //nodesize\n      get 'NodeSize'() {\n        return nodeSize;\n      },\n\n      set 'NodeSize'(v) {\n        nodeSize = v;\n        updateModel(1);\n      }\n\n    };\n    displayFolder.add(displayParams, 'TagDistance', 0.5, 3.0);\n    displayFolder.add(displayParams, 'NodeSize', 0.3, 2.0);\n    displayFolder.open(); // teamcallback folder\n\n    teamCallbackFolder = gui.addFolder('TeamCallback');\n    var teamParam = {\n      // upload\n      lockupload: () => {\n        // vertex\n        let lv = '';\n        geoVmap.forEach((v, i) => {\n          // spreadsheet all >> (col)1 = id | (col)2=x | (col)3=y | (col)4=z | (col)5=nx | (col)6=ny | (col)7=nz | (col)8=locked ;\n          // 0 = idv | 8 = locked ;\n          if (v.userData.locked) {\n            // true as 1\n            lv += '0=' + i + '|8=1;';\n          } else {\n            // false as 0\n            lv += '0=' + i + '|8=0;';\n          } // next row\n\n        });\n        lv = lv.substring(0, lv.length - 1);\n        ssVjson(lv, exeurl, ssnodeurl, 'node'); // crv\n\n        let lc = '';\n        geoCmap.forEach((v, i) => {\n          // spreadsheet all >> (col)1 = id | (col)2=nid | (col)3=disteach | (col)4=locked;\n          // 0 = idv | 8 = locked ;\n          if (v.userData.locked) {\n            // true as 1\n            lc += '0=' + i + '|4=1;';\n          } else {\n            // false as 0\n            lc += '0=' + i + '|4=0;';\n          } // next row\n\n        });\n        lc = lc.substring(0, lv.length - 1);\n        ssVjson(lc, exeurl, ssnodeurl, 'curve');\n      },\n      // reset and upload\n      reset: () => {\n        // crv\n        let lc = '';\n        geoCmap.forEach((vc, i) => {\n          if (vc.userData.locked) {\n            vc.userData.locked = false;\n            vc.userData.object.material = matFade;\n            vc.userData.object.material.needsUpdate = true;\n          }\n\n          lc += '0=' + i + '|4=0;';\n        });\n        lc = lc.substring(0, lc.length - 1);\n        ssVjson(lc, exeurl, ssnodeurl, 'curve'); // vertex\n\n        let lv = '';\n        geoVmap.forEach((v, i) => {\n          if (v.userData.locked) {\n            v.userData.locked = false;\n            v.userData.object.material = matFinished;\n            v.userData.object.material.needsUpdate = true;\n          } //v.node\n\n\n          lv += '0=' + i + '|8=0;';\n        });\n        lv = lv.substring(0, lv.length - 1);\n        ssVjson(lv, exeurl, ssnodeurl, 'node');\n      }\n    };\n    teamCallbackFolder.add(teamParam, 'lockupload');\n    teamCallbackFolder.add(teamParam, 'reset');\n    teamCallbackFolder.open();\n    /*\r\n            // pubilc/assets/prototypingjs/XXXX.obj\r\n    \r\n            gui.add( guiData, 'currentURL', {\r\n                        \"2020Fab01_00\": './assets/prototypingjs/2020Fab01_00.obj',\r\n                        \"2020Fab01_01\": './assets/prototypingjs/2020Fab01_01.obj'\r\n                    } ).name( 'FabModel' ).onChange( updateModel );\r\n            // gui action\r\n            editFolder = gui.addFolder( 'Edit' );\r\n            var editParms = {\r\n                clearSelection: ()=>{clearSelection();},\r\n                undoSelection: ()=>{undoSelection();}\r\n            };\r\n            editFolder.add(editParms, 'clearSelection');\r\n            editFolder.add(editParms, 'undoSelection');\r\n            editFolder.open();\r\n    */\n\n    customContainer.appendChild(gui.domElement);\n  }\n\n  function ssVjson(strjs, exeurl, ssurl, tabname) {\n    let jsonout = {\n      data: strjs,\n      sheetUrl: ssnodeurledit,\n      sheetTag: tabname\n    };\n    $.post(exeurl, jsonout, data => {\n      console.log(data);\n    }).done(() => {\n      console.log('a');\n    }).fail(error => {\n      console.log(error);\n    }); //console.log('b');\n\n    /*\r\n    $.ajax({\r\n        type: \"GET\",\r\n        data: JSON.stringify(strjs),\r\n        url: exeurl,\r\n        dataType: \"jsonp\",\r\n        success: function(data) {\r\n            console.log('a');\r\n        },\r\n        error: function() {\r\n            console.log('Request Error.');\r\n        }\r\n    });\r\n    */\n  }\n\n  function updateModel(e) {\n    switch (e) {\n      // tagdist\n      case 0:\n        geoVmap.forEach(v => {\n          let vn = v.userData.tagnormal.clone().multiplyScalar(tagdist);\n          let np = vn.add(v);\n          v.userData.tag.position.x = np.x;\n          v.userData.tag.position.y = np.y;\n          v.userData.tag.position.z = np.z; //console.log();\n        });\n        break;\n      // nodesize\n\n      case 1:\n        let geobuff = new THREE.SphereBufferGeometry(nodeSize);\n        geoVmap.forEach(v => {\n          let vog = v.userData.object;\n          vog.geometry = geobuff.clone();\n          vog.position.x = v.x;\n          vog.position.y = v.y;\n          vog.position.z = v.z; //vo.geometry.scale(nodeSize,nodeSize,nodeSize);\n          //console.log();\n        });\n        break;\n\n      default:\n    }\n  }\n  /*    \r\n      function removefromScene(array){\r\n          for (let i=0;i<array.length;i+=1){\r\n              if (array[i].type == 'Group'){\r\n                  array[i].children.forEach((g, i)=>{\r\n                      g.material.dispose();\r\n                      g.geometry.dispose();\r\n                  })\r\n              }else{\r\n                  // ground\r\n                  array[i].geometry.dispose();\r\n                  array[i].material.dispose();\r\n              }\r\n              scene.remove(array[i]); \r\n          }\r\n      }\r\n  */\n  // assign front and back\n\n\n  function meshgroupfb(geo, matarr) {\n    if (geo.type == 'Group') {\n      geo.children.forEach((g, i) => {\n        g.material = matarr[i];\n        g.material.needsUpdate = true;\n      });\n    }\n  }\n  /*\r\n      function clearSelection(){\r\n          // All part\r\n          for (let i=geoFinished.length-1; i>=0; i-=1){\r\n              // front\r\n              meshgroupfb(geoFinished[i], matFadeArray);\r\n              geoAll.push(geoFinished[i]);\r\n              geoFinished.pop();\r\n          }\r\n          // possible part\r\n          for (let i=geoAll.length-1; i>=0; i-=1){\r\n              // front\r\n              geoAll[i].children[0].material=matFade;\r\n              geoAll[i].children[0].material.needsUpdate =true;\r\n              // back\r\n              geoAll[i].children[0].material=matFade;\r\n              geoAll[i].children[0].material.needsUpdate =true;\r\n          }\r\n          geoPossible=[];\r\n  \r\n          updateText();\r\n      }\r\n      function undoSelection(){\r\n          // finish part\r\n          if (geoFinished.length>0){\r\n              geoFinished[geoFinished.length-1].material=matFade;\r\n              geoFinished[geoFinished.length-1].material.needsUpdate =true;\r\n              geoAll.push(geoFinished[geoFinished.length-1]);\r\n              geoFinished.pop();\r\n          }\r\n              // possible part\r\n              geoPossible=[];\r\n              var idPos=[];\r\n              \r\n              for (let i=0; i<geoAll.length; i+=1){\r\n                      geoAll[i].material = matFade;\r\n                      geoAll[i].material.needsUpdate =true;\r\n                      let ac = geoAll[i].geometry.boundingSphere.center;\r\n  \r\n                      for (let j=0; j<geoFinished.length; j+=1){\r\n                          let fc = geoFinished[j].geometry.boundingSphere.center;\r\n                          let d = fc.distanceTo( ac );\r\n                          if (d<0.65){\r\n                              geoPossible.push(geoAll[i]);\r\n                              idPos.push(i);\r\n                          }\r\n                      }\r\n              }\r\n              \r\n              for (let k=0; k<idPos.length;k+=1){\r\n                  geoAll[idPos[k]].material = matPossible;\r\n                  geoAll[idPos[k]].material.needsUpdate =true;\r\n              }\r\n          updateText();\r\n      }\r\n  */\n\n\n  function initModel() {\n    // remove\n\n    /*\r\n    for (let i=0;i<geoAll.length;i+=1){\r\n        geoAll[i].geometry.dispose();\r\n        geoAll[i].material.dispose();\r\n        scene.remove(geoAll[i]);\r\n    }\r\n    */\n    //clearModel();\n    preload();\n    /*\r\n    // manager        \r\n    const manager = new THREE.LoadingManager();\r\n    manager.onProgress = function ( item, loaded, total ) {};\r\n      loader = new OBJLoader(manager);\r\n    // execute input\r\n    // =================object will install into ./public not in ./src===================\r\n    loader.load( guiData.currentURL, function ( obj ) {\r\n        // Object\r\n        obj.traverse( function ( child ) {\r\n            if ( child.isMesh ) {\r\n                    var piece = child.clone();\r\n                    // put data into group then make it show different texture\r\n                    var pieces = new THREE.Group();\r\n                    pieces.add(new THREE.Mesh(piece.geometry, matFade));\r\n                    pieces.add(new THREE.Mesh(piece.geometry, matFadeBack));\r\n                    pieces.children[0].castShadow = true; // only cast one geomtry shadow \r\n                    pieces.name = piece.name;\r\n                    //console.log(pieces.name);\r\n                    scene.add(pieces);\r\n                    geoAll.push(pieces);                           \r\n            }               \r\n        });\r\n        //scene.add( geos );\r\n    }, onProgress, onError );\r\n    */\n    //updateText();\n  }\n\n  function onMove(event) {\n    //event.preventDefault();\n    var x, y;\n\n    if (event.changedTouches) {\n      x = event.changedTouches[0].pageX;\n      y = event.changedTouches[0].pageY;\n    } else {\n      x = event.clientX;\n      y = event.clientY;\n      screen.x = event.pageX;\n      screen.y = event.pageY;\n    }\n\n    mouse.x = x / window.innerWidth * 2 - 1;\n    mouse.y = -(y / window.innerHeight) * 2 + 1;\n    checkIntersection();\n  }\n\n  function onDown(event) {\n    switch (event.which) {\n      case 2:\n        // mouse middle button\n        if (outlinePass !== undefined) {\n          // crv\n          outlinePass.selectedObjects.forEach(v => {\n            if (v.name) {\n              // crv unlock\n              if (v.userData.locked) {\n                v.userData.locked = false;\n                v.material = matFade; // node unlock\n\n                v.userData.nodesVec.forEach(vn => {\n                  // check parent curve locked or not\n                  let checkparent = false;\n                  vn.userData.parent.forEach(vc => {\n                    if (vc.userData.locked) {\n                      checkparent = true;\n                      return;\n                    }\n                  });\n\n                  if (checkparent === false) {\n                    vn.userData.locked = false;\n                    vn.userData.object.material = matFinished;\n                    vn.userData.object.material.needsUpdate = true;\n                  }\n                }); // crv lock\n              } else {\n                v.userData.locked = true;\n                v.material = matLocked; // node lock\n\n                v.userData.nodesVec.forEach(vn => {\n                  // check parent curve locked or not\n                  let checkparent = false;\n                  vn.userData.parent.forEach(vc => {\n                    if (vc.userData.locked) {\n                      checkparent = true;\n                      return;\n                    }\n                  });\n\n                  if (checkparent) {\n                    vn.userData.locked = true;\n                    vn.userData.object.material = matLocked;\n                    vn.userData.object.material.needsUpdate = true;\n                  }\n                });\n              }\n            }\n\n            v.material.needsUpdate = true;\n          });\n        } // make sure all data locked\n        // geoCmap.forEach(b)  \n\n\n        break;\n    }\n  }\n  /*\r\n      function onDown(event){\r\n          //console.log(guiData.currentURL);\r\n          //event.preventDefault();\r\n  \r\n          switch (event.which){\r\n              case 1:\r\n                  var checkFinished = false;\r\n                  var idFinished = -1;\r\n                  var idAll = -1;\r\n                  var idPos = [];\r\n                  geoPossible =[];\r\n  \r\n                  // if selected something\r\n                  if (pieceSelected){\r\n  \r\n                      // update all\r\n                      for (let i=0;i<geoAll.length;i+=1){\r\n                          meshgroupfb(geoAll[i], matFadeArray);\r\n                          //geoAll[i].material = matFade;\r\n                      }\r\n                      // for selected\r\n                      if (geoSelected !== undefined && geoSelected.length>0){\r\n                          \r\n                          // check finished\r\n                          if (geoFinished.length>0){\r\n                              for (let i=0;i<geoFinished.length;i+=1){\r\n                                  if (geoFinished[i].name === geoSelected[0].name){\r\n                                     idFinished = i;\r\n                                     checkFinished = true;\r\n                                     break;\r\n                                  }\r\n                              }\r\n                          }\r\n  \r\n                          // step1 : if check finidshed > become fade\r\n                          if (checkFinished){\r\n                              // add into geoAll\r\n                              geoAll.push(geoFinished[idFinished]);\r\n  \r\n                              // texture change\r\n                              meshgroupfb(geoFinished[idFinished], matFadeArray);\r\n                              //geoFinished[idFinished].children[0].material = matFade;\r\n                              //geoFinished[idFinished].children[1].material = matFadeBack;\r\n                              //geoFinished[idFinished].children[0].material.needsUpdate =true;\r\n                              //geoFinished[idFinished].children[1].material.needsUpdate =true;\r\n                              // removed from geofinished\r\n                              geoFinished.splice(idFinished, 1);\r\n  \r\n                          }else{\r\n                              // if fade > become finished\r\n                              // add into geofinished\r\n                              // geoSelected got group\r\n                              meshgroupfb(geoSelected[0], matFinishedArray);\r\n                              //geoSelected[0].children[0].material = matFinished;\r\n                              //geoSelected[0].children[1].material = matFinishedBack;\r\n                              //geoSelected[0].children[0].material.needsUpdate =true;\r\n                              //geoSelected[0].children[1].material.needsUpdate =true;\r\n                              geoFinished.push(geoSelected[0]);\r\n  \r\n                              // removed from geoAll\r\n                              for (let i=0;i<geoAll.length;i+=1){\r\n                                  if (geoAll[i].name === geoSelected[0].name){\r\n                                     idAll = i;\r\n                                     break;\r\n                                  }\r\n                              }\r\n                              geoAll.splice(idAll, 1);\r\n                          }\r\n  \r\n                          // step2 : check surrounded and preseverd in geoAll\r\n                          \r\n                          for (let i=0; i<geoAll.length; i+=1){\r\n                              let ac = geoAll[i].children[0].geometry.boundingSphere.center;\r\n  \r\n                              for (let j=0; j<geoFinished.length; j+=1){\r\n                                  let fc = geoFinished[j].children[0].geometry.boundingSphere.center;\r\n                                  let d = fc.distanceTo( ac );\r\n                                  if (d<0.65){\r\n                                      geoPossible.push(geoAll[i]);\r\n                                      idPos.push(i);\r\n                                  }\r\n                              }\r\n                          }\r\n                          \r\n                          for (let k=0; k<idPos.length;k+=1){\r\n                              meshgroupfb(geoAll[idPos[k]], matPossibleArray);\r\n                              //geoAll[idPos[k]].material = matPossible;\r\n                              //geoAll[idPos[k]].material.needsUpdate =true;\r\n                          }\r\n                              \r\n  \r\n                      }\r\n                  }\r\n                  break;\r\n          }\r\n  \r\n          updateText();\r\n      }\r\n  \r\n  */\n\n  /*\r\n      function clearModel(){\r\n          var geoSelected; \r\n          removefromScene(geoAll);\r\n          removefromScene(geoFinished);\r\n          removefromScene(geoPossible);\r\n          geoAll=[];\r\n          geoFinished =[];\r\n          geoPossible =[];\r\n      }\r\n  */\n\n\n  function checkIntersection() {\n    geoSelected = [];\n    raycaster.setFromCamera(mouse, camera);\n    var intersects = raycaster.intersectObjects([scene], true); //console.log(intersects);\n\n    if (intersects.length > 0) {\n      var selectedObject = intersects[0].object; //>> this just one object not group\n\n      if (selectedObject.name) {\n        geoSelected.push(selectedObject);\n        pieceSelected = true;\n      } else {\n        pieceSelected = false;\n      }\n    } else {\n      //$('#infoCanvas').text('1');\n      pieceSelected = false;\n    } // render and show text\n\n\n    if (outlinePass !== undefined && pieceSelected) {\n      outlinePass.selectedObjects = geoSelected;\n      updateText();\n    }\n  }\n\n  function updateText() {\n    // make sure hide\n    geoVmap.forEach((v, i) => {\n      v.userData.tag.visible = false;\n    });\n    $(document).ready(() => {\n      let textFinished = '';\n      let nodeText = '';\n\n      if (geoSelected.length > 0) {\n        if (geoSelected[0].name) {\n          textFinished += geoSelected[0].name + '<br>';\n          let dstr = '';\n          let dtol = 0.0;\n          let nsv = new THREE.Vector3();\n          geoSelected[0].userData.nodes.forEach((val, i) => {\n            if (i % 4 == 0) {\n              textFinished += '<br>';\n            }\n\n            textFinished += '<button id=\"node_' + val + '\" class=\"ui mini posstive button\">n' + val + '</button>'; //record for dist\n\n            if (i > 0) {\n              let v = parseFloat(geoSelected[0].userData.disteach[i - 1]);\n              dstr += 'n' + geoSelected[0].userData.nodes[i - 1] + ' to n' + val + ' = ' + v + ' mm | ' + (dtol += v).toFixed(3) + ' mm<br>';\n            }\n\n            geoVmap[val].userData.tag.visible = true; //let vt = geoSelected[0].userData.neodesVec[i];\n\n            /*\r\n            let p = geoSelected[0].userData.nodesVec[i].clone();\r\n            //camera.updateMatrixWorld();\r\n            \r\n            let vt = p.project(camera);\r\n            vt.x = Math.round( (   vt.x + 1 ) * pannelSize.halfwidth);\r\n            vt.y = Math.round( (   vt.y + 1 ) * pannelSize.halfheight );\r\n            console.log(vt);\r\n            //console.log(renderer.context.canvas.width);\r\n            //sv.project(camera);\r\n            nodeText+='<div style=\"position:fixed; left: '+vt.x+'px; top: '+vt.y+'px;\">'+val+'</div>';\r\n            //sv.x = ( sv.x * screenDimensions.halfwidth) + screenDimensions.halfwidth;\r\n            //sv.y = - ( sv.y * screenDimensions.halfheight) + screenDimensions.halfheight;\r\n            */\n            //return vector;\n            //geoSelected[0].userData.neodesVec[i].x;\n          });\n          textFinished += '<br><br><div style=\"color:red\">' + dstr + '</div>';\n        } else {\n          textFinished += 'Nothing selected...';\n        }\n      } else {\n        textFinished += 'Nothing selected...';\n      }\n\n      $('#infoProgress').html(() => {\n        return textFinished;\n      });\n      $('#infoCanvas').html(() => {\n        return nodeText;\n      });\n    });\n  }\n  /*\r\n      function updateText(){\r\n          //geoSelected =[];\r\n          //var count=0;\r\n          // text attatch\r\n         // $(document).ready(()=>{\r\n              $('#infoProgress').html(()=>{\r\n                  textFinished ='Sotck<br>';\r\n  \r\n                  // geoall part\r\n                  if (geoAll !== undefined && geoAll.length>0){\r\n                      for (var i=0;i<geoAll.length;i+=1){\r\n                          //textFinished += ''geoFinished[i].name +',';\r\n                          if (i%5==0){ textFinished += '<br>'; }\r\n                          var idstr = geoAll[i].name;\r\n                          \r\n                          textFinished += '<button id=\"'+idstr+'\" class=\"ui mini inverted button\">'+idstr+'</button>';\r\n                      }\r\n                      //count+=1;\r\n                  }\r\n  \r\n                  // finished part\r\n                  textFinished += '<br><br>Finished<br>';\r\n                  if (geoFinished !== undefined && geoFinished.length>0){\r\n                      for (var i=0;i<geoFinished.length;i+=1){\r\n                          //textFinished += ''geoFinished[i].name +',';\r\n                          if (i%5==0){ textFinished += '<br>'; }\r\n                          textFinished += '<button id=\"'+geoFinished[i].name+'\" class=\"ui mini posstive button\">'+geoFinished[i].name+'</button>';\r\n  \r\n                      }\r\n                      //count+=1;\r\n                  } \r\n  \r\n                  return textFinished;\r\n              });\r\n  \r\n              if (geoAll !== undefined){\r\n                  $('#infoAll').html(()=>{\r\n                      return 'GoeFinishedNum:'+geoFinished.length;\r\n                  });\r\n                  // add interactive hover\r\n                  \r\n                  if (geoAll.length>0){\r\n                      for(let i=0;i<geoAll.length;i+=1){\r\n                          $('#'+geoAll[i].name).hover(()=>{\r\n                              checkButton(geoAll[i]);\r\n                          });  \r\n                      }    \r\n                  }\r\n                  if (geoFinished.length>0){\r\n                      for(let i=0;i<geoFinished.length;i+=1){\r\n                          $('#'+geoFinished[i].name).hover(()=>{\r\n                              checkButton(geoFinished[i]);\r\n                          });  \r\n                      }    \r\n                  }\r\n              }\r\n  \r\n              // set pieces\r\n              if (pieceSelected){\r\n                  //console.log(geoSelected[0].type);\r\n                  if (geoSelected.length>0){\r\n                      $('#'+geoSelected[0].name).addClass(\"red\");\r\n                  }\r\n              }\r\n         // });\r\n  \r\n      }\r\n  */\n\n  /*\r\n      function checkButton(obj){\r\n          pieceSelected =true;\r\n          geoSelected =[];\r\n          geoSelected.push(obj);\r\n          outlinePass.selectedObjects = geoSelected;\r\n      }   \r\n  */\n\n\n  function update() {\n    lights.update();\n    var delta = Date.now() * 0.0015; // postrender\n\n    composer.render();\n  }\n\n  function onWindowResize() {\n    const {\n      width,\n      height\n    } = canvas;\n    screenDimensions.width = width;\n    screenDimensions.height = height;\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n    composer.setSize(width, height);\n    pannelSize.width = renderer.context.canvas.width;\n    pannelSize.height = renderer.context.canvas.height;\n    pannelSize.halfwidth = renderer.context.canvas.width * 0.5;\n    pannelSize.halfwidth = renderer.context.canvas.height * 0.5;\n  }\n\n  return {\n    update,\n    onWindowResize\n  };\n});","map":{"version":3,"sources":["D:/chrlab/src/component/panelComponent/Canvas/Weavingjs/threejs/SceneManager.js"],"names":["THREE","GeneralLights","dat","OBJLoader","EffectComposer","RenderPass","FilmPass","BloomPass","ShaderPass","SobelOperatorShader","OutlinePass","$","OrbitControls","require","textureLoader","TextureLoader","canvas","request","loader","parmfont","ssnodeurl","sscrvurl","exeurl","ssnodeurledit","geoVmap","geoCmap","geo","geoPts","geoLines","backgroundcube","text","geoSelected","geoAll","geoFinished","geoPossible","geoLocked","cLocked","t1","t2","uniforms","matColor","matFinColor","matPosColor","matShader","matWireframe","matGradient","matShaderSub","matHidden","matLine","matFinished","matFinishedBack","matPossible","matLocked","matPossibleBack","matFade","matFadeBack","matFinishedArray","matPossibleArray","matFadeArray","textloader","FontLoader","composer","outlinePass","raycaster","Raycaster","mouse","Vector2","screen","pieceSelected","textFinished","texetAll","nodeSize","pipeDegree","pipeSize","pipeRacial","pipeClose","gui","guiData","shading","tagratio","tagdist","clock","Clock","screenDimensions","width","height","halfwidth","halfheight","pannelSize","displayFolder","teamCallbackFolder","scene","buildScene","camera","buildCamera","renderer","buildRender","controls","domElement","target","set","update","customContainer","document","getElementById","lights","createSceneSubjects","setPath","load","tex1","pointTexture","value","xhr1","console","log","loaded","total","preload","fetch","then","response","data","val","JSON","parse","encodenode","response2","data2","val2","encodecrv","catch","error2","error","makeLabel","msg","size","pos","ratio","canvastxt","createElement","ctx","getContext","font","textBaseline","textAlign","translate","fillStyle","fillText","texture","CanvasTexture","minFilter","LinearFilter","matTag","SpriteMaterial","map","transparent","tag","Sprite","scale","x","y","z","position","visible","add","vs","geoMesh","SphereBufferGeometry","castShadow","i","feed","entry","length","nidlocked","gsx$locked","$t","object","Mesh","vv","Vector3","parseFloat","gsx$x","gsx$z","gsx$y","vt","gsx$nx","gsx$nz","gsx$ny","vvtag","toString","clone","multiplyScalar","userData","push","nidlstr","gsx$nid","split","diststr","gsx$disteach","cidlocked","npts","forEach","v","parseInt","spl","CatmullRomCurve3","curveType","tub","TubeBufferGeometry","name","gsx$id","pipe","nv","parent","Scene","background","Color","fog","Fog","WebGLRenderer","antialias","alpha","DPR","window","devicePixelRatio","shadowMap","enabled","localClippingEnabled","setPixelRatio","setSize","autoClear","toneMapping","ReinhardToneMapping","renderPass","addPass","edgeStrength","edgeGlow","edgeThickness","pulsePeriod","visibleEdgeColor","hiddenEdgeColor","onProgress","xhr","lengthComputable","percentComplete","Math","round","onError","PerspectiveCamera","innerWidth","innerHeight","CubeTextureLoader","LineBasicMaterial","color","MeshPhongMaterial","opacity","roughness","depthTest","depthWrite","flatShading","side","FrontSide","MeshBasicMaterial","BackSide","emssive","specular","shininess","MeshStandardMaterial","vertexColors","VertexColors","blending","AdditiveBlending","wireframe","MeshLambertMaterial","DoubleSide","ground","PlaneBufferGeometry","rotation","PI","receiveShadow","addEventListener","onMove","onDown","createGUI","initModel","GUI","autoPlace","addFolder","displayParams","updateModel","open","teamParam","lockupload","lv","locked","substring","ssVjson","lc","reset","vc","material","needsUpdate","appendChild","strjs","ssurl","tabname","jsonout","sheetUrl","sheetTag","post","done","fail","e","vn","tagnormal","np","geobuff","vog","geometry","meshgroupfb","matarr","type","children","g","event","changedTouches","pageX","pageY","clientX","clientY","checkIntersection","which","undefined","selectedObjects","nodesVec","checkparent","setFromCamera","intersects","intersectObjects","selectedObject","updateText","ready","nodeText","dstr","dtol","nsv","nodes","disteach","toFixed","html","delta","Date","now","render","onWindowResize","aspect","updateProjectionMatrix","context"],"mappings":"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","sourcesContent":["import * as THREE from '../../threejs/src/Three.js';\r\n//import SceneSubject from './SceneSubject';\r\nimport GeneralLights from './GeneralLights';\r\nimport * as dat from 'dat.gui';\r\nimport { OBJLoader } from '../../threejs/examples/jsm/loaders/OBJLoader.js';\r\n\r\nimport { EffectComposer } from '../../threejs/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from '../../threejs/examples/jsm/postprocessing/RenderPass.js';\r\nimport { FilmPass } from '../../threejs/examples/jsm/postprocessing/FilmPass.js';\r\nimport { BloomPass } from '../../threejs/examples/jsm/postprocessing/BloomPass.js';\r\n\r\nimport { ShaderPass } from '../../threejs/examples/jsm/postprocessing/ShaderPass.js';\r\nimport { SobelOperatorShader } from '../../threejs/examples/jsm/shaders/SobelOperatorShader.js';\r\nimport { OutlinePass } from '../../threejs/examples/jsm/postprocessing/OutlinePass.js';\r\n//\r\n//import { MeshText2D, textAlign } from '../../threejs/examples/jsm/postprocessing/three-text2d';\r\n//import SpriteText from 'three-spritetext';\r\n// two kinds class\r\n\r\n// curve >> [] with geoCmap\r\n    /*\r\n    userData {\r\n                \"nodes\": nidlstr,\r\n                \"nodesVec\": npts,\r\n                \"disteach\": diststr,\r\n                \"locked\": false\r\n            };\r\n    */\r\n\r\n// vertex >> [] with geoVmap\r\n    /*\r\n    userData {\r\n                \"object\":object,\r\n                \"tag\": vvtag,\r\n                \"tagnormal\": vt,\r\n                \"locked\": false\r\n            };\r\n    */\r\n\r\n\r\nimport $ from 'jquery';\r\n\r\n//const glsl = require('glslify');\r\nconst OrbitControls = require('three-orbit-controls')(THREE);\r\nconst textureLoader = new THREE.TextureLoader();\r\n\r\nexport default canvas => {\r\n    // objects\r\n    var request;\r\n    var loader;\r\n    var parmfont;\r\n    const ssnodeurl = 'https://spreadsheets.google.com/feeds/list/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/1/public/values?alt=json';\r\n    const sscrvurl = 'https://spreadsheets.google.com/feeds/list/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/2/public/values?alt=json';\r\n    const exeurl = 'https://script.google.com/macros/s/AKfycbyYhxPfFDvS1nPTuDg9n5SZLYwbzaD6zqVbBkVJzzEWDoWjW6B8/exec';\r\n    const ssnodeurledit = 'https://docs.google.com/spreadsheets/d/1l3DvxzJxmCPyk3TruBMCC_YXWEvRJXnkwaKcx41IoKA/edit?usp=sharing';\r\n    //var geos = new THREE.Group();\r\n    //var geoVmap, geoCrvmap;\r\n\r\n    var geoVmap =[];\r\n    var geoCmap=[];  \r\n    var geo, geoPts, geoLines;\r\n    var backgroundcube, text;\r\n    // as Three.Group = children[0] = frontface / children[1] = backface\r\n    var geoSelected;\r\n    var geoAll =[];\r\n    var geoFinished =[];\r\n    var geoPossible =[];\r\n    var geoLocked =[];\r\n    var cLocked =[];\r\n    // material\r\n    var t1, t2, uniforms;\r\n    var matColor, matFinColor, matPosColor, matShader, matWireframe, matGradient, matShaderSub, matHidden, matLine;\r\n    var matFinished, matFinishedBack, matPossible, matLocked, matPossibleBack, matFade, matFadeBack;\r\n    var matFinishedArray, matPossibleArray, matFadeArray;\r\n    var textloader = new THREE.FontLoader();\r\n    // renderer\r\n    var composer, outlinePass;\r\n    // control\r\n    var raycaster = new THREE.Raycaster();\r\n    var mouse = new THREE.Vector2();\r\n    var screen = new THREE.Vector2();\r\n    var pieceSelected = false;\r\n    var textFinished ='';\r\n    var texetAll='';\r\n\r\n    var nodeSize = 0.6;\r\n\r\n    var pipeDegree = 20; // default as 64\r\n    var pipeSize = 0.3;\r\n    var pipeRacial = 4;\r\n    var pipeClose = false;\r\n\r\n    // GUI\r\n    var gui, guiData, shading;\r\n    var tagratio=2.0;\r\n    var tagdist=1.0;\r\n    const clock = new THREE.Clock();\r\n    const screenDimensions = {\r\n        width: canvas.width,\r\n        height: canvas.height,\r\n        halfwidth: canvas.width*0.5,\r\n        halfheight: canvas.height*0.5\r\n    }\r\n    const pannelSize = {\r\n        width: canvas.width,\r\n        height: canvas.height,\r\n        halfwidth: canvas.width*0.5,\r\n        halfheight: canvas.height*0.5\r\n    }\r\n    var displayFolder, teamCallbackFolder;\r\n\r\n    // build\r\n    const scene = buildScene();\r\n    const camera = buildCamera(screenDimensions);\r\n    const renderer = buildRender(screenDimensions);\r\n    \r\n    const controls = new OrbitControls( camera, renderer.domElement );\r\n    controls.target.set( 0, 1, 0 );\r\n    controls.update();\r\n\r\n    const customContainer = document.getElementById('canvas-gui-container');\r\n    const lights = GeneralLights(scene);\r\n\r\n    createSceneSubjects(scene, uniforms);\r\n\r\n    // textture\r\n    textureLoader.setPath( './assets/textures/sprites/' ).load( 'spark1.png', (tex1)=>{\r\n\r\n        t1 = tex1;\r\n        uniforms ={pointTexture: { value: t1 }};\r\n\r\n    },( xhr1 ) =>{\r\n        console.log( (xhr1.loaded / xhr1.total * 100) + '% loaded' );\r\n    },( xhr1 ) =>{\r\n        console.log( 'An error happened' );\r\n    });\r\n\r\n    //parmfont = new THREE.Font( fontJson );\r\n\r\n    function preload(){\r\n        // load url1\r\n        fetch(ssnodeurl)\r\n            .then((response)=>{\r\n            return response.text();\r\n        }).then((data)=>{\r\n            // do url1data\r\n            let val = JSON.parse(data);\r\n            encodenode(val);\r\n            // load url2\r\n            fetch(sscrvurl)\r\n                .then((response2)=>{\r\n                return response2.text();\r\n                }).then((data2)=>{\r\n                    // do url2data\r\n                    let val2 = JSON.parse(data2);\r\n                    encodecrv(val2);\r\n                }).catch((error2)=>{\r\n                    console.log(error2);\r\n            });\r\n        }).catch((error)=>{\r\n            console.log(error);\r\n        });\r\n\r\n        // font\r\n          \r\n        \r\n               \r\n        /*\r\n        let sprite = new TextSprite({\r\n              fillStyle: '#ff0000',\r\n              fontFamily: '\"Times New Roman\", Times, serif',\r\n              fontSize: 10,\r\n              fontStyle: 'italic',\r\n              text: 'aa',\r\n            });\r\n            scene.add(sprite); \r\n        */\r\n        //console.log(geoVmap);\r\n        //loadJSON(ssjointurl, encodejoint);\r\n    }\r\n\r\n    function makeLabel(msg, size, pos, ratio) {\r\n            //const borderSize = 1;\r\n            let canvastxt = document.createElement('canvas');\r\n            let ctx = canvastxt.getContext('2d');\r\n            ctx.font = size + 'px Arial';\r\n            // measure how long the name will be\r\n            //ctx.canvas.width = ctx.measureText(msg).width;\r\n            ctx.canvas.width = size*1.75;\r\n            ctx.canvas.height = size*1.75;\r\n            //ctx.canvas.height = size;\r\n/*            \r\n            if (msg.length===1) {\r\n                //size*=0.5;\r\n                ctx.canvas.width = ctx.measureText(msg).width*0.5;\r\n                ctx.canvas.height = size; // fontsize * 1.5\r\n            }\r\n            else if (msg.length===2) {\r\n                //size*=1.0;\r\n                ctx.canvas.width = ctx.measureText(msg).width;\r\n                ctx.canvas.height = size;\r\n            }\r\n            else if (msg.length===3) {\r\n                //size*=1.5;\r\n                ctx.canvas.width = ctx.measureText(msg).width*1.5;\r\n                ctx.canvas.height = size;\r\n            }\r\n*/             \r\n            // after setting the canvas width/height we have to re-set font to apply!?! looks like ctx reset\r\n            ctx.font = size + \"px Arial\";\r\n            ctx.textBaseline = 'middle';\r\n            ctx.textAlign = 'center';\r\n            \r\n            //ctx.fillStyle = 'white';\r\n            //ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n            \r\n            ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);\r\n            ctx.fillStyle = 'red';\r\n            ctx.fillText(msg, 0, 0);\r\n\r\n            let texture = new THREE.CanvasTexture(ctx.canvas);\r\n            texture.minFilter = THREE.LinearFilter;\r\n            //texture.wrapS = THREE.ClampToEdgeWrapping;\r\n            //texture.wrapT = THREE.ClampToEdgeWrapping;\r\n\r\n            let matTag = new THREE.SpriteMaterial({\r\n                    map: texture,\r\n                    transparent: true,\r\n            });\r\n            let tag = new THREE.Sprite(matTag);\r\n            tag.scale.x =ratio;\r\n            tag.scale.y =ratio;\r\n            tag.scale.z =ratio;\r\n\r\n            tag.position.x = pos.x;\r\n            tag.position.y = pos.y;\r\n            tag.position.z = pos.z;\r\n\r\n            tag.visible = false;\r\n\r\n            scene.add(tag);\r\n        \r\n            return tag;\r\n    }\r\n\r\n\r\n    function encodenode(data){\r\n\r\n        let vs = [];\r\n        \r\n        let geoMesh = new THREE.SphereBufferGeometry( nodeSize );\r\n        geoMesh.castShadow = true;\r\n        //geoVtMesh = new THREE.InstancedMesh( geoVertics, matFinished, count );\r\n        for (let i = 0; i < data.feed.entry.length; i+=1) {\r\n\r\n            let nidlocked = data.feed.entry[i].gsx$locked.$t === '0' ? false : true;\r\n\r\n            let object = nidlocked ? new THREE.Mesh( geoMesh, matLocked ) : new THREE.Mesh( geoMesh, matFinished);\r\n            let vv = new THREE.Vector3( \r\n                parseFloat(data.feed.entry[i].gsx$x.$t),\r\n                parseFloat(data.feed.entry[i].gsx$z.$t),\r\n                parseFloat(data.feed.entry[i].gsx$y.$t));\r\n            let vt = new THREE.Vector3( \r\n                parseFloat(data.feed.entry[i].gsx$nx.$t)*(-1),\r\n                parseFloat(data.feed.entry[i].gsx$nz.$t)*(-1),\r\n                parseFloat(data.feed.entry[i].gsx$ny.$t)*(-1));\r\n            let vvtag = makeLabel(i.toString(), 30, vt.clone().multiplyScalar(tagdist).add(vv), tagratio);\r\n            object.position.x = vv.x;\r\n            object.position.z = vv.z;\r\n            object.position.y = vv.y;\r\n\r\n            vv.userData={\r\n                \"object\":object,\r\n                \"tag\": vvtag,\r\n                \"tagnormal\": vt,\r\n                \"locked\": nidlocked,\r\n                \"parent\":[] // not setted right now\r\n            };\r\n            /*\r\n            let  v= { \"id\": parseInt(data.feed.entry[i].gsx$id.$t),\r\n                      \"node\": vv,  \r\n                      \"mesh\":object\r\n                    };\r\n            \r\n            let vvtag = new THREE.ShapeGeometry(\r\n                THREE.Font.generateShapes( \"i\", {\r\n                    font: parmfont,\r\n                    size: 2,\r\n                }));\r\n            \r\n            let vvtag = new THREE.Texture({\r\n                font: \"2px Arial\",\r\n                fillStyle:\"rgba(255,0,0)\",\r\n                fillText:i\r\n            })\r\n            \r\n            let vvtag = new THREE.TextSprite({\r\n              text: 'Hello World!',\r\n              fontFamily: 'Arial, Helvetica, sans-serif',\r\n              fontSize: 12,\r\n              fillColor: '#ffbbff',\r\n            });\r\n            \r\n            vv.userData={\r\n                \"tag\": vvtag\r\n            };\r\n            */\r\n            \r\n            \r\n\r\n            scene.add(object);\r\n            //scene.add(vvtag);\r\n            geoVmap.push(vv);\r\n        }\r\n        //geoVmap = vs;\r\n    }\r\n\r\n    function encodecrv(data){\r\n\r\n        //let crvs = [];\r\n        \r\n        //let geoMesh = new THREE.SphereBufferGeometry( 0.25 );\r\n        //geoVtMesh = new THREE.InstancedMesh( geoVertics, matFinished, count );\r\n        for (let i = 0; i < data.feed.entry.length; i+=1) {\r\n            let nidlstr = data.feed.entry[i].gsx$nid.$t.split('^');\r\n            let diststr = data.feed.entry[i].gsx$disteach.$t.split('^');\r\n            let cidlocked = data.feed.entry[i].gsx$locked.$t === '0' ? false : true; \r\n            // data anaylsis\r\n            let npts = [];\r\n            nidlstr.forEach((v)=>{\r\n               npts.push(geoVmap[parseInt(v)]);\r\n            })\r\n\r\n            \r\n            let spl = new THREE.CatmullRomCurve3(npts);\r\n            spl.curveType = 'catmullrom';\r\n            let tub = new THREE.TubeBufferGeometry( spl, pipeDegree, pipeSize, pipeRacial, pipeClose );\r\n            //let pipe = new THREE.Mesh( new THREE.TubeBufferGeometry( spl, pipeDegree, pipeSize, pipeRacial, pipeClose), matFade);\r\n            let name = 'crv_'+ data.feed.entry[i].gsx$id.$t;\r\n            let pipe = cidlocked ? new THREE.Mesh( tub, matLocked ) : new THREE.Mesh( tub, matFade);\r\n            pipe.name = name;\r\n            npts.forEach((nv,i)=>{\r\n                nv.userData.parent.push(pipe);\r\n            });\r\n\r\n            pipe.userData={\r\n                \"object\": pipe,\r\n                \"nodes\": nidlstr,\r\n                \"nodesVec\": npts,\r\n                \"disteach\": diststr,\r\n                \"locked\": cidlocked\r\n            };\r\n            pipe.castShadow = true;\r\n            /*\r\n            let crv = {\r\n                \"name\": name,\r\n                \"curve\": spl,\r\n                \"pipe\": pipe,\r\n                \"disteach\": diststr\r\n            }\r\n            */\r\n            scene.add(pipe);\r\n            geoCmap.push(pipe);\r\n        }\r\n        ;\r\n        \r\n        //console.log(geoCrvmap );\r\n    }\r\n    // function below\r\n\r\n    function buildScene() {\r\n        const scene = new THREE.Scene();\r\n        scene.background = new THREE.Color('#a0a0a0');\r\n        scene.fog = new THREE.Fog( 0xa0a0a0, 10, 100 );\r\n        return scene;\r\n    }\r\n\r\n    function buildRender({ width, height }) {\r\n        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });\r\n        const DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.localClippingEnabled = false;\r\n        renderer.setPixelRatio(DPR);\r\n        renderer.setSize(width, height);\r\n        renderer.autoClear = false;\r\n        renderer.toneMapping = THREE.ReinhardToneMapping;\r\n\r\n        // post\r\n        \r\n        composer = new EffectComposer( renderer );\r\n\r\n        var renderPass = new RenderPass( scene, camera );\r\n        composer.addPass( renderPass );\r\n        \r\n        outlinePass = new OutlinePass( new THREE.Vector2( width, height ), scene, camera );\r\n\r\n        outlinePass.edgeStrength = 2.0\r\n        outlinePass.edgeGlow = 0.0;\r\n        outlinePass.edgeThickness = 0.7;\r\n        outlinePass.pulsePeriod = 0;\r\n        outlinePass.visibleEdgeColor.set( '#ff0000' );\r\n        outlinePass.hiddenEdgeColor.set( '#190a05' );\r\n\r\n        composer.addPass( outlinePass );\r\n      \r\n        return renderer;\r\n    }\r\n\r\n    // input function    \r\n    function onProgress( xhr ) {\r\n            if ( xhr.lengthComputable ) {\r\n                var percentComplete = xhr.loaded / xhr.total * 100;\r\n                console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );\r\n                }\r\n    }\r\n\r\n    function onError() {\r\n            console.log( 'error!!' );\r\n    }\r\n\r\n    function buildCamera({ width, height }) {\r\n        const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 160 );\r\n        camera.position.set( 70, 70, 0 );       \r\n        return camera;\r\n    }\r\n\r\n    function createSceneSubjects(scene , uniforms) {\r\n        // material 1\r\n\r\n        backgroundcube = new THREE.CubeTextureLoader()\r\n                    .setPath( './assets/textures/cube/pisa/' )\r\n                    .load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] );\r\n        matLine = new THREE.LineBasicMaterial( { color : 0xff00ff } );\r\n        matFade = new THREE.MeshPhongMaterial( { \r\n            color: 0xeeeeee, \r\n            transparent: true,\r\n            opacity: 0.7,\r\n            roughness: 0.9,\r\n            depthTest: true,\r\n            depthWrite: true,\r\n            flatShading:true,\r\n            side: THREE.FrontSide\r\n        } );\r\n        matFadeBack = new THREE.MeshBasicMaterial( { \r\n            color: 0x555555,\r\n            transparent: true,\r\n            opacity: 0.7,\r\n            side: THREE.BackSide\r\n        });\r\n        matFadeArray =[matFade, matFadeBack];\r\n\r\n        matFinished = new THREE.MeshPhongMaterial( { \r\n            color: 0x21ce94,\r\n            emssive: 0x0,\r\n            specular:0x111111,\r\n            shininess: 30,\r\n            roughness: 0.9,\r\n            depthTest:true,\r\n            depthWrite:true,\r\n            //envMap: backgroundcube,\r\n            flatShading:true,\r\n            side: THREE.FrontSide\r\n        });\r\n        matFinishedBack = new THREE.MeshBasicMaterial( { \r\n            color: 0x555594,\r\n            side: THREE.BackSide\r\n        });\r\n        matFinishedArray =[matFinished, matFinishedBack];\r\n\r\n        matLocked = new THREE.MeshStandardMaterial( { \r\n            color: 0xeee143,\r\n            transparent: true,\r\n            opacity: 0.7,\r\n            roughness: 0.9,\r\n            depthTest: true,\r\n            depthWrite: true,\r\n            flatShading:true,\r\n            side: THREE.FrontSide\r\n        } );\r\n        matPossibleBack = new THREE.MeshBasicMaterial( { \r\n            color: 0x888122,\r\n            transparent: true,\r\n            opacity: 0.7,\r\n            side: THREE.BackSide\r\n        });\r\n        matPossibleArray =[matPossible, matPossibleBack];\r\n\r\n        matShaderSub = new THREE.LineBasicMaterial( {\r\n                    vertexColors: THREE.VertexColors,\r\n                    blending: THREE.AdditiveBlending,\r\n                    transparent: true\r\n                } );\r\n        matHidden = new THREE.MeshBasicMaterial( { \r\n            color: matColor, \r\n            transparent: true, \r\n            blending: THREE.AdditiveBlending,\r\n            opacity : 0.1\r\n        } );\r\n\r\n        // material 3\r\n        matWireframe = new THREE.MeshBasicMaterial( { color: matColor, wireframe: true } );\r\n        \r\n        // material 4\r\n        matGradient = new THREE.MeshLambertMaterial( {\r\n                    vertexColors: THREE.VertexColors,\r\n                    side: THREE.DoubleSide\r\n                });       \r\n\r\n        // background     \r\n        var ground = new THREE.Mesh(\r\n            new THREE.PlaneBufferGeometry( 400, 400, 1, 1 ),\r\n            new THREE.MeshPhongMaterial( { color: 0x999999, shininess: 150, depthWrite: false } )\r\n        );        \r\n\r\n        ground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\r\n        ground.receiveShadow = true; \r\n        //ground.name='ground';          \r\n        scene.add( ground );\r\n\r\n        window.addEventListener( 'mousemove', onMove );\r\n        window.addEventListener( 'mousedown', onDown, false );\r\n\r\n        // subject\r\n        createGUI();  \r\n        initModel();        \r\n    }\r\n    \r\n    function createGUI(){\r\n        //GUI\r\n        //if ( gui ) gui.destroy();\r\n\r\n        gui = new dat.GUI({ autoPlace: false });\r\n        /*\r\n        guiData = {\r\n            'tagdist': tagdist\r\n                }.name( 'GUIedit' ).onChange( updateModel );\r\n        gui.add();\r\n        */\r\n\r\n        // display floder\r\n        displayFolder = gui.addFolder( 'Display' );\r\n        var displayParams = {\r\n            // tagdist\r\n                get 'TagDistance'() {\r\n                    return tagdist;\r\n                },\r\n                set 'TagDistance'( v ) {\r\n                    tagdist = v;\r\n                    updateModel(0);\r\n                },\r\n            //nodesize\r\n                get 'NodeSize'() {\r\n                    return nodeSize;\r\n                },\r\n                set 'NodeSize'( v ) {\r\n                    nodeSize = v;\r\n                    updateModel(1);\r\n                }\r\n        };\r\n        displayFolder.add(displayParams, 'TagDistance', 0.5,3.0);\r\n        displayFolder.add(displayParams, 'NodeSize', 0.3,2.0);\r\n        displayFolder.open();\r\n\r\n        // teamcallback folder\r\n        teamCallbackFolder = gui.addFolder( 'TeamCallback' );\r\n        var teamParam = {\r\n            // upload\r\n            lockupload: ()=>{ \r\n                // vertex\r\n                let lv='';\r\n                geoVmap.forEach((v,i)=>{\r\n                    // spreadsheet all >> (col)1 = id | (col)2=x | (col)3=y | (col)4=z | (col)5=nx | (col)6=ny | (col)7=nz | (col)8=locked ;\r\n                    // 0 = idv | 8 = locked ;\r\n                    if(v.userData.locked){ // true as 1\r\n                        lv+='0='+i+'|8=1;';\r\n                    }else{ // false as 0\r\n                        lv+='0='+i+'|8=0;';\r\n                    } // next row\r\n                });\r\n                lv = lv.substring(0, lv.length - 1);\r\n                ssVjson(lv,exeurl,ssnodeurl,'node');\r\n\r\n                // crv\r\n                let lc='';\r\n                geoCmap.forEach((v,i)=>{\r\n                    // spreadsheet all >> (col)1 = id | (col)2=nid | (col)3=disteach | (col)4=locked;\r\n                    // 0 = idv | 8 = locked ;\r\n                    if(v.userData.locked){ // true as 1\r\n                        lc+='0='+i+'|4=1;';\r\n                    }else{ // false as 0\r\n                        lc+='0='+i+'|4=0;';\r\n                    } // next row\r\n                });\r\n                lc = lc.substring(0, lv.length - 1);\r\n                ssVjson(lc,exeurl,ssnodeurl,'curve');\r\n            },\r\n            // reset and upload\r\n            reset: ()=>{ \r\n\r\n                // crv\r\n                let lc='';\r\n                geoCmap.forEach((vc,i)=>{\r\n                    if (vc.userData.locked){\r\n                        vc.userData.locked = false;\r\n                        vc.userData.object.material = matFade;\r\n                        vc.userData.object.material.needsUpdate =true;\r\n                    }\r\n                    lc+='0='+i+'|4=0;';\r\n                })\r\n                lc = lc.substring(0, lc.length - 1);\r\n                ssVjson(lc,exeurl,ssnodeurl,'curve');\r\n                // vertex\r\n                let lv='';\r\n                geoVmap.forEach((v,i)=>{\r\n                    if (v.userData.locked){\r\n                        v.userData.locked = false;\r\n                        v.userData.object.material = matFinished;\r\n                        v.userData.object.material.needsUpdate =true;\r\n                    }\r\n                    //v.node\r\n                    lv+='0='+i+'|8=0;';\r\n                });\r\n                lv = lv.substring(0, lv.length - 1);\r\n                ssVjson(lv,exeurl,ssnodeurl,'node');\r\n            }\r\n        };\r\n        teamCallbackFolder.add(teamParam,'lockupload');\r\n        teamCallbackFolder.add(teamParam,'reset');\r\n        \r\n\r\n        teamCallbackFolder.open();\r\n\r\n/*\r\n        // pubilc/assets/prototypingjs/XXXX.obj\r\n\r\n        gui.add( guiData, 'currentURL', {\r\n                    \"2020Fab01_00\": './assets/prototypingjs/2020Fab01_00.obj',\r\n                    \"2020Fab01_01\": './assets/prototypingjs/2020Fab01_01.obj'\r\n                } ).name( 'FabModel' ).onChange( updateModel );\r\n        // gui action\r\n        editFolder = gui.addFolder( 'Edit' );\r\n        var editParms = {\r\n            clearSelection: ()=>{clearSelection();},\r\n            undoSelection: ()=>{undoSelection();}\r\n        };\r\n        editFolder.add(editParms, 'clearSelection');\r\n        editFolder.add(editParms, 'undoSelection');\r\n        editFolder.open();\r\n*/\r\n        customContainer.appendChild(gui.domElement);\r\n    }\r\n    function ssVjson(strjs,exeurl,ssurl,tabname){\r\n        \r\n        let jsonout = {\r\n                  data: strjs,\r\n                  sheetUrl: ssnodeurledit,\r\n                  sheetTag: tabname\r\n            };\r\n        $.post(exeurl, jsonout, (data)=>{\r\n            console.log(data);\r\n        }).done(()=>{\r\n            console.log('a');\r\n        }).fail((error)=>{\r\n            console.log(error);\r\n        });\r\n        //console.log('b');\r\n        /*\r\n        $.ajax({\r\n            type: \"GET\",\r\n            data: JSON.stringify(strjs),\r\n            url: exeurl,\r\n            dataType: \"jsonp\",\r\n            success: function(data) {\r\n                console.log('a');\r\n            },\r\n            error: function() {\r\n                console.log('Request Error.');\r\n            }\r\n        });\r\n        */\r\n    }\r\n\r\n    function updateModel(e){\r\n        switch(e){\r\n            // tagdist\r\n            case 0:\r\n                geoVmap.forEach((v)=>{\r\n                    let vn = v.userData.tagnormal.clone().multiplyScalar(tagdist);\r\n                    let np = vn.add(v);\r\n                    v.userData.tag.position.x= np.x;\r\n                    v.userData.tag.position.y= np.y;\r\n                    v.userData.tag.position.z= np.z;\r\n                    //console.log();\r\n                });\r\n                break;\r\n            // nodesize\r\n            case 1:\r\n                let geobuff = new THREE.SphereBufferGeometry( nodeSize );\r\n                geoVmap.forEach((v)=>{\r\n                    let vog = v.userData.object;\r\n                    vog.geometry=geobuff.clone();\r\n                    vog.position.x=v.x;\r\n                    vog.position.y=v.y;\r\n                    vog.position.z=v.z;\r\n                    //vo.geometry.scale(nodeSize,nodeSize,nodeSize);\r\n                    //console.log();\r\n                });\r\n                break;\r\n            default:\r\n\r\n        }\r\n    }\r\n/*    \r\n    function removefromScene(array){\r\n        for (let i=0;i<array.length;i+=1){\r\n            if (array[i].type == 'Group'){\r\n                array[i].children.forEach((g, i)=>{\r\n                    g.material.dispose();\r\n                    g.geometry.dispose();\r\n                })\r\n            }else{\r\n                // ground\r\n                array[i].geometry.dispose();\r\n                array[i].material.dispose();\r\n            }\r\n            scene.remove(array[i]); \r\n        }\r\n    }\r\n*/\r\n    // assign front and back\r\n    function meshgroupfb(geo, matarr){\r\n        if (geo.type == 'Group'){\r\n            geo.children.forEach((g, i)=>{\r\n                g.material=matarr[i];\r\n                g.material.needsUpdate =true;\r\n            })\r\n        }\r\n    }\r\n/*\r\n    function clearSelection(){\r\n        // All part\r\n        for (let i=geoFinished.length-1; i>=0; i-=1){\r\n            // front\r\n            meshgroupfb(geoFinished[i], matFadeArray);\r\n            geoAll.push(geoFinished[i]);\r\n            geoFinished.pop();\r\n        }\r\n        // possible part\r\n        for (let i=geoAll.length-1; i>=0; i-=1){\r\n            // front\r\n            geoAll[i].children[0].material=matFade;\r\n            geoAll[i].children[0].material.needsUpdate =true;\r\n            // back\r\n            geoAll[i].children[0].material=matFade;\r\n            geoAll[i].children[0].material.needsUpdate =true;\r\n        }\r\n        geoPossible=[];\r\n\r\n        updateText();\r\n    }\r\n    function undoSelection(){\r\n        // finish part\r\n        if (geoFinished.length>0){\r\n            geoFinished[geoFinished.length-1].material=matFade;\r\n            geoFinished[geoFinished.length-1].material.needsUpdate =true;\r\n            geoAll.push(geoFinished[geoFinished.length-1]);\r\n            geoFinished.pop();\r\n        }\r\n            // possible part\r\n            geoPossible=[];\r\n            var idPos=[];\r\n            \r\n            for (let i=0; i<geoAll.length; i+=1){\r\n                    geoAll[i].material = matFade;\r\n                    geoAll[i].material.needsUpdate =true;\r\n                    let ac = geoAll[i].geometry.boundingSphere.center;\r\n\r\n                    for (let j=0; j<geoFinished.length; j+=1){\r\n                        let fc = geoFinished[j].geometry.boundingSphere.center;\r\n                        let d = fc.distanceTo( ac );\r\n                        if (d<0.65){\r\n                            geoPossible.push(geoAll[i]);\r\n                            idPos.push(i);\r\n                        }\r\n                    }\r\n            }\r\n            \r\n            for (let k=0; k<idPos.length;k+=1){\r\n                geoAll[idPos[k]].material = matPossible;\r\n                geoAll[idPos[k]].material.needsUpdate =true;\r\n            }\r\n        updateText();\r\n    }\r\n*/\r\n    function initModel(){\r\n        // remove\r\n        /*\r\n        for (let i=0;i<geoAll.length;i+=1){\r\n            geoAll[i].geometry.dispose();\r\n            geoAll[i].material.dispose();\r\n            scene.remove(geoAll[i]);\r\n        }\r\n        */\r\n        //clearModel();\r\n        preload();\r\n        /*\r\n        // manager        \r\n        const manager = new THREE.LoadingManager();\r\n        manager.onProgress = function ( item, loaded, total ) {};\r\n\r\n        loader = new OBJLoader(manager);\r\n        // execute input\r\n        // =================object will install into ./public not in ./src===================\r\n        loader.load( guiData.currentURL, function ( obj ) {\r\n            // Object\r\n            obj.traverse( function ( child ) {\r\n                if ( child.isMesh ) {\r\n                        var piece = child.clone();\r\n                        // put data into group then make it show different texture\r\n                        var pieces = new THREE.Group();\r\n                        pieces.add(new THREE.Mesh(piece.geometry, matFade));\r\n                        pieces.add(new THREE.Mesh(piece.geometry, matFadeBack));\r\n                        pieces.children[0].castShadow = true; // only cast one geomtry shadow \r\n                        pieces.name = piece.name;\r\n                        //console.log(pieces.name);\r\n                        scene.add(pieces);\r\n                        geoAll.push(pieces);                           \r\n                }               \r\n            });\r\n            //scene.add( geos );\r\n        }, onProgress, onError );\r\n        */\r\n        //updateText();\r\n    }\r\n\r\n    function onMove(event){\r\n        //event.preventDefault();\r\n        var x, y;\r\n        if ( event.changedTouches ) {\r\n            x = event.changedTouches[ 0 ].pageX;\r\n            y = event.changedTouches[ 0 ].pageY;\r\n        } else {\r\n            x = event.clientX;\r\n            y = event.clientY;\r\n\r\n            screen.x = event.pageX;\r\n            screen.y = event.pageY;\r\n        }\r\n        \r\n        mouse.x = ( x / window.innerWidth) * 2 - 1;\r\n        mouse.y = - ( y / window.innerHeight) * 2 + 1;\r\n        checkIntersection();\r\n    }\r\n\r\n    function onDown(event){\r\n        switch (event.which){\r\n            case 2: // mouse middle button\r\n                if (outlinePass !== undefined) {\r\n                    // crv\r\n                    outlinePass.selectedObjects.forEach((v)=>{\r\n                        if (v.name){\r\n                            // crv unlock\r\n                            if (v.userData.locked){\r\n                                v.userData.locked = false;\r\n                                v.material = matFade;\r\n                                // node unlock\r\n                                v.userData.nodesVec.forEach((vn)=>{\r\n                                    // check parent curve locked or not\r\n                                    let checkparent = false;\r\n                                    vn.userData.parent.forEach((vc)=>{\r\n                                        if (vc.userData.locked){\r\n                                            checkparent = true;\r\n                                            return;\r\n                                        }\r\n                                    });\r\n                                    if (checkparent === false){\r\n                                        vn.userData.locked = false;\r\n                                        vn.userData.object.material = matFinished;\r\n                                        vn.userData.object.material.needsUpdate =true;\r\n                                    }\r\n                                });\r\n                                \r\n                            // crv lock\r\n                            }else{\r\n                                v.userData.locked = true;\r\n                                v.material = matLocked;\r\n                                // node lock\r\n                                \r\n                                v.userData.nodesVec.forEach((vn)=>{\r\n                                    // check parent curve locked or not\r\n                                    let checkparent = false;\r\n                                    vn.userData.parent.forEach((vc)=>{\r\n                                        if (vc.userData.locked){\r\n                                            checkparent = true;\r\n                                            return;\r\n                                        }\r\n                                    });\r\n                                    if (checkparent){\r\n                                        vn.userData.locked = true;\r\n                                        vn.userData.object.material = matLocked;\r\n                                        vn.userData.object.material.needsUpdate =true;\r\n                                    }\r\n                                });\r\n                                \r\n                            }\r\n                        }\r\n                        v.material.needsUpdate =true;\r\n                    });    \r\n                }\r\n                // make sure all data locked\r\n                // geoCmap.forEach(b)  \r\n            break;\r\n        }\r\n    }\r\n/*\r\n    function onDown(event){\r\n        //console.log(guiData.currentURL);\r\n        //event.preventDefault();\r\n\r\n        switch (event.which){\r\n            case 1:\r\n                var checkFinished = false;\r\n                var idFinished = -1;\r\n                var idAll = -1;\r\n                var idPos = [];\r\n                geoPossible =[];\r\n\r\n                // if selected something\r\n                if (pieceSelected){\r\n\r\n                    // update all\r\n                    for (let i=0;i<geoAll.length;i+=1){\r\n                        meshgroupfb(geoAll[i], matFadeArray);\r\n                        //geoAll[i].material = matFade;\r\n                    }\r\n                    // for selected\r\n                    if (geoSelected !== undefined && geoSelected.length>0){\r\n                        \r\n                        // check finished\r\n                        if (geoFinished.length>0){\r\n                            for (let i=0;i<geoFinished.length;i+=1){\r\n                                if (geoFinished[i].name === geoSelected[0].name){\r\n                                   idFinished = i;\r\n                                   checkFinished = true;\r\n                                   break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // step1 : if check finidshed > become fade\r\n                        if (checkFinished){\r\n                            // add into geoAll\r\n                            geoAll.push(geoFinished[idFinished]);\r\n\r\n                            // texture change\r\n                            meshgroupfb(geoFinished[idFinished], matFadeArray);\r\n                            //geoFinished[idFinished].children[0].material = matFade;\r\n                            //geoFinished[idFinished].children[1].material = matFadeBack;\r\n                            //geoFinished[idFinished].children[0].material.needsUpdate =true;\r\n                            //geoFinished[idFinished].children[1].material.needsUpdate =true;\r\n                            // removed from geofinished\r\n                            geoFinished.splice(idFinished, 1);\r\n\r\n                        }else{\r\n                            // if fade > become finished\r\n                            // add into geofinished\r\n                            // geoSelected got group\r\n                            meshgroupfb(geoSelected[0], matFinishedArray);\r\n                            //geoSelected[0].children[0].material = matFinished;\r\n                            //geoSelected[0].children[1].material = matFinishedBack;\r\n                            //geoSelected[0].children[0].material.needsUpdate =true;\r\n                            //geoSelected[0].children[1].material.needsUpdate =true;\r\n                            geoFinished.push(geoSelected[0]);\r\n\r\n                            // removed from geoAll\r\n                            for (let i=0;i<geoAll.length;i+=1){\r\n                                if (geoAll[i].name === geoSelected[0].name){\r\n                                   idAll = i;\r\n                                   break;\r\n                                }\r\n                            }\r\n                            geoAll.splice(idAll, 1);\r\n                        }\r\n\r\n                        // step2 : check surrounded and preseverd in geoAll\r\n                        \r\n                        for (let i=0; i<geoAll.length; i+=1){\r\n                            let ac = geoAll[i].children[0].geometry.boundingSphere.center;\r\n\r\n                            for (let j=0; j<geoFinished.length; j+=1){\r\n                                let fc = geoFinished[j].children[0].geometry.boundingSphere.center;\r\n                                let d = fc.distanceTo( ac );\r\n                                if (d<0.65){\r\n                                    geoPossible.push(geoAll[i]);\r\n                                    idPos.push(i);\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        for (let k=0; k<idPos.length;k+=1){\r\n                            meshgroupfb(geoAll[idPos[k]], matPossibleArray);\r\n                            //geoAll[idPos[k]].material = matPossible;\r\n                            //geoAll[idPos[k]].material.needsUpdate =true;\r\n                        }\r\n                            \r\n\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        updateText();\r\n    }\r\n\r\n*/\r\n/*\r\n    function clearModel(){\r\n        var geoSelected; \r\n        removefromScene(geoAll);\r\n        removefromScene(geoFinished);\r\n        removefromScene(geoPossible);\r\n        geoAll=[];\r\n        geoFinished =[];\r\n        geoPossible =[];\r\n    }\r\n*/\r\n\r\n    function checkIntersection() {\r\n        geoSelected =[];\r\n\r\n        raycaster.setFromCamera( mouse, camera );\r\n        var intersects = raycaster.intersectObjects( [ scene ], true );\r\n        //console.log(intersects);\r\n        \r\n        if ( intersects.length > 0 ) {\r\n            var selectedObject = intersects[ 0 ].object; //>> this just one object not group\r\n\r\n            if (selectedObject.name){\r\n                geoSelected.push(selectedObject);\r\n                pieceSelected =true;\r\n            }else{\r\n                pieceSelected =false;\r\n            }\r\n        } else {\r\n            //$('#infoCanvas').text('1');\r\n            pieceSelected =false;\r\n        }\r\n\r\n        // render and show text\r\n        if (outlinePass !== undefined && pieceSelected) {\r\n            outlinePass.selectedObjects = geoSelected;    \r\n            updateText();\r\n        }\r\n    }\r\n    function updateText(){\r\n        // make sure hide\r\n        geoVmap.forEach((v,i)=>{\r\n            v.userData.tag.visible=false;\r\n        })\r\n        \r\n        $(document).ready(()=>{\r\n\r\n            let textFinished = '';\r\n            let nodeText = '';\r\n\r\n\r\n            if (geoSelected.length>0){\r\n                if (geoSelected[0].name){\r\n                    textFinished += geoSelected[0].name+'<br>';\r\n\r\n                    let dstr='';\r\n                    let dtol=0.0;\r\n                    let nsv = new THREE.Vector3();\r\n                    geoSelected[0].userData.nodes.forEach((val,i)=>{\r\n                    if (i%4==0){ textFinished += '<br>'; }\r\n                    textFinished += '<button id=\"node_'+val+'\" class=\"ui mini posstive button\">n'+val+'</button>';\r\n                    //record for dist\r\n                    if (i>0){\r\n                        let v = parseFloat(geoSelected[0].userData.disteach[i-1]);\r\n                        dstr += 'n'+geoSelected[0].userData.nodes[i-1] + ' to n' + \r\n                                    val + ' = ' + v+' mm | '+(dtol+=v).toFixed(3)+' mm<br>';\r\n                            \r\n                    }\r\n                    geoVmap[val].userData.tag.visible=true;\r\n\r\n                        //let vt = geoSelected[0].userData.neodesVec[i];\r\n                        /*\r\n                        let p = geoSelected[0].userData.nodesVec[i].clone();\r\n                        //camera.updateMatrixWorld();\r\n                        \r\n                        let vt = p.project(camera);\r\n                        vt.x = Math.round( (   vt.x + 1 ) * pannelSize.halfwidth);\r\n                        vt.y = Math.round( (   vt.y + 1 ) * pannelSize.halfheight );\r\n                        console.log(vt);\r\n                        //console.log(renderer.context.canvas.width);\r\n                        //sv.project(camera);\r\n                        nodeText+='<div style=\"position:fixed; left: '+vt.x+'px; top: '+vt.y+'px;\">'+val+'</div>';\r\n                        //sv.x = ( sv.x * screenDimensions.halfwidth) + screenDimensions.halfwidth;\r\n                        //sv.y = - ( sv.y * screenDimensions.halfheight) + screenDimensions.halfheight;\r\n                        */\r\n                        //return vector;\r\n                        //geoSelected[0].userData.neodesVec[i].x;\r\n                    });\r\n                    textFinished += '<br><br><div style=\"color:red\">' + dstr+'</div>';\r\n                }else{\r\n                    textFinished += 'Nothing selected...';\r\n                }\r\n            }else{\r\n                textFinished += 'Nothing selected...';\r\n            }\r\n\r\n            $('#infoProgress').html(()=>{\r\n                return textFinished;\r\n            });\r\n            $('#infoCanvas').html(()=>{\r\n                return nodeText;\r\n            });\r\n        });\r\n    }\r\n\r\n/*\r\n    function updateText(){\r\n        //geoSelected =[];\r\n        //var count=0;\r\n        // text attatch\r\n       // $(document).ready(()=>{\r\n            $('#infoProgress').html(()=>{\r\n                textFinished ='Sotck<br>';\r\n\r\n                // geoall part\r\n                if (geoAll !== undefined && geoAll.length>0){\r\n                    for (var i=0;i<geoAll.length;i+=1){\r\n                        //textFinished += ''geoFinished[i].name +',';\r\n                        if (i%5==0){ textFinished += '<br>'; }\r\n                        var idstr = geoAll[i].name;\r\n                        \r\n                        textFinished += '<button id=\"'+idstr+'\" class=\"ui mini inverted button\">'+idstr+'</button>';\r\n                    }\r\n                    //count+=1;\r\n                }\r\n\r\n                // finished part\r\n                textFinished += '<br><br>Finished<br>';\r\n                if (geoFinished !== undefined && geoFinished.length>0){\r\n                    for (var i=0;i<geoFinished.length;i+=1){\r\n                        //textFinished += ''geoFinished[i].name +',';\r\n                        if (i%5==0){ textFinished += '<br>'; }\r\n                        textFinished += '<button id=\"'+geoFinished[i].name+'\" class=\"ui mini posstive button\">'+geoFinished[i].name+'</button>';\r\n\r\n                    }\r\n                    //count+=1;\r\n                } \r\n\r\n                return textFinished;\r\n            });\r\n\r\n            if (geoAll !== undefined){\r\n                $('#infoAll').html(()=>{\r\n                    return 'GoeFinishedNum:'+geoFinished.length;\r\n                });\r\n                // add interactive hover\r\n                \r\n                if (geoAll.length>0){\r\n                    for(let i=0;i<geoAll.length;i+=1){\r\n                        $('#'+geoAll[i].name).hover(()=>{\r\n                            checkButton(geoAll[i]);\r\n                        });  \r\n                    }    \r\n                }\r\n                if (geoFinished.length>0){\r\n                    for(let i=0;i<geoFinished.length;i+=1){\r\n                        $('#'+geoFinished[i].name).hover(()=>{\r\n                            checkButton(geoFinished[i]);\r\n                        });  \r\n                    }    \r\n                }\r\n            }\r\n\r\n            // set pieces\r\n            if (pieceSelected){\r\n                //console.log(geoSelected[0].type);\r\n                if (geoSelected.length>0){\r\n                    $('#'+geoSelected[0].name).addClass(\"red\");\r\n                }\r\n            }\r\n       // });\r\n\r\n    }\r\n*/ \r\n/*\r\n    function checkButton(obj){\r\n        pieceSelected =true;\r\n        geoSelected =[];\r\n        geoSelected.push(obj);\r\n        outlinePass.selectedObjects = geoSelected;\r\n    }   \r\n*/    \r\n    function update() {\r\n        lights.update();\r\n\r\n        var delta = Date.now()*0.0015;\r\n        // postrender\r\n        composer.render();\r\n    }\r\n\r\n    function onWindowResize() {\r\n        const { width, height } = canvas;\r\n        \r\n        screenDimensions.width = width;\r\n        screenDimensions.height = height;\r\n\r\n        camera.aspect = width / height;\r\n        camera.updateProjectionMatrix();\r\n        \r\n        renderer.setSize(width, height);\r\n        composer.setSize(width,  height);\r\n\r\n        pannelSize.width = renderer.context.canvas.width;\r\n        pannelSize.height = renderer.context.canvas.height;\r\n        pannelSize.halfwidth = renderer.context.canvas.width*0.5;\r\n        pannelSize.halfwidth = renderer.context.canvas.height*0.5;\r\n\r\n    }\r\n\r\n    return {\r\n        update,\r\n        onWindowResize\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}