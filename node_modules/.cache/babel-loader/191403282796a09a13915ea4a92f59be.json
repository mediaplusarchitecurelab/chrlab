{"ast":null,"code":"import * as THREE from 'three'; //import alphaTexture from './assets/textures/stripes_gradient.jpg';\n\nexport default (scene => {\n  // =========CONSTANT==========\n  //const group = new THREE.Group();\n  const SEPARATION = 80,\n        AMOUNTX = 60,\n        AMOUNTY = 60;\n  const numParticles = AMOUNTX * AMOUNTY; //const speed = 0.02;\n  //const textureOffsetSpeed = 0.02;\n  // =========PARTICLES MAP==========\n  // =========EXCUTE==========\n\n  var particles,\n      count = 0; // =========EXCUTE==========\n\n  init();\n\n  function init() {\n    // ============ATTRIBUTES MAP================\n    var positions = new Float32Array(numParticles * 3);\n    var colors = new Float32Array(numParticles * 3);\n    var scales = new Float32Array(numParticles); // ============VIRABLE VALUE================\n\n    let color = new THREE.Color();\n    var i = 0,\n        j = 0;\n\n    for (var ix = 0; ix < AMOUNTX; ix++) {\n      for (var iy = 0; iy < AMOUNTY; iy++) {\n        positions[i] = ix * SEPARATION - AMOUNTX * SEPARATION / 2; // x\n\n        positions[i + 1] = 0; // y\n\n        positions[i + 2] = iy * SEPARATION - AMOUNTY * SEPARATION / 2; // z\n\n        scales[j] = 1;\n        color.setHSL(i / numParticles / 2, 1.0, 0.5);\n        colors[i] = color.r; //\n\n        colors[i + 1] = color.g; //\n\n        colors[i + 2] = color.b; // \n\n        i += 3;\n        j++;\n      }\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n    geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n    geometry.addAttribute('scale', new THREE.Float32BufferAttribute(scales, 1));\n    var material = new THREE.ShaderMaterial({\n      uniforms: {\n        // 外部資料放在public底下\n        texture: {\n          value: new THREE.TextureLoader().load(\"./assets/textures/sprites/ball.png\")\n        }\n      },\n      vertexShader: document.getElementById('vertexshader').textContent,\n      fragmentShader: document.getElementById('fragmentshader').textContent,\n      blending: THREE.AdditiveBlending,\n      depthTest: false,\n      transparent: true,\n      vertexColors: true\n    });\n    particles = new THREE.Points(geometry, material);\n    scene.add(particles);\n  }\n  /*    \r\n      function deformGeometry(geometry) {\r\n          for (let i=0; i<geometry.vertices.length; i+=2) {\r\n              const scalar = 1 + Math.random()*0.8;\r\n              geometry.vertices[i].multiplyScalar(scalar)\r\n          }\r\n  \r\n          return geometry;\r\n      }\r\n  */\n\n\n  function update(time) {\n    let positions = particles.geometry.attributes.position.array;\n    let scales = particles.geometry.attributes.scale.array; //let colors = particles.geometry.attributes.color.array;\n    //let color = new THREE.Color();\n\n    let i = 0,\n        j = 0;\n\n    for (var ix = 0; ix < AMOUNTX; ix++) {\n      for (var iy = 0; iy < AMOUNTY; iy++) {\n        // ========================= MOTION Y =========================\n        positions[i + 1] = Math.sin((ix + count) * 0.3) * 100 + Math.sin((iy + count) * 0.5) * 100;\n        scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 7 + (Math.sin((iy + count) * 0.5) + 1) * 7; //color.setHSL( i / numParticles / 2, 1.0, 0.5 );\n        //colors[ i ] = Math.sin(iy + count ); \n\n        i += 3;\n        j++;\n      }\n    }\n\n    particles.geometry.attributes.position.needsUpdate = true;\n    particles.geometry.attributes.scale.needsUpdate = true;\n    particles.geometry.attributes.color.needsUpdate = true;\n    count += 0.05;\n  }\n\n  return {\n    update\n  };\n});","map":{"version":3,"sources":["D:/chrlab/src/component/Canvas/threejs/SceneSubject.js"],"names":["THREE","scene","SEPARATION","AMOUNTX","AMOUNTY","numParticles","particles","count","init","positions","Float32Array","colors","scales","color","Color","i","j","ix","iy","setHSL","r","g","b","geometry","BufferGeometry","addAttribute","Float32BufferAttribute","material","ShaderMaterial","uniforms","texture","value","TextureLoader","load","vertexShader","document","getElementById","textContent","fragmentShader","blending","AdditiveBlending","depthTest","transparent","vertexColors","Points","add","update","time","attributes","position","array","scale","Math","sin","needsUpdate"],"mappings":"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","sourcesContent":["import * as THREE from 'three'\r\n//import alphaTexture from './assets/textures/stripes_gradient.jpg';\r\n\r\nexport default scene => {\r\n    // =========CONSTANT==========\r\n    //const group = new THREE.Group();\r\n    const SEPARATION = 80, AMOUNTX = 60, AMOUNTY = 60;\r\n    const numParticles = AMOUNTX * AMOUNTY;\r\n    //const speed = 0.02;\r\n    //const textureOffsetSpeed = 0.02;\r\n    // =========PARTICLES MAP==========\r\n    \r\n    // =========EXCUTE==========\r\n    var particles, count = 0;\r\n    // =========EXCUTE==========\r\n    init();\r\n\r\n    function init() {\r\n        // ============ATTRIBUTES MAP================\r\n        var positions = new Float32Array( numParticles * 3 );\r\n        var colors = new Float32Array( numParticles * 3 );\r\n        var scales = new Float32Array( numParticles );\r\n\r\n        // ============VIRABLE VALUE================\r\n        let color = new THREE.Color();\r\n\r\n        var i = 0, j = 0;\r\n        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {\r\n            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {\r\n                positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x\r\n                positions[ i + 1 ] = 0; // y\r\n                positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z\r\n                scales[ j ] = 1;\r\n\r\n                color.setHSL( i / numParticles/2, 1.0, 0.5 );\r\n\r\n                colors[ i ] = color.r; //\r\n                colors[ i + 1 ] = color.g; //\r\n                colors[ i + 2 ] = color.b; // \r\n\r\n                i += 3;\r\n                j ++;\r\n            }\r\n         }\r\n        \r\n        var geometry = new THREE.BufferGeometry();\r\n        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\r\n        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\r\n        geometry.addAttribute( 'scale', new THREE.Float32BufferAttribute( scales, 1 ) );\r\n\r\n        var material = new THREE.ShaderMaterial( {\r\n                uniforms: {\r\n                    // 外部資料放在public底下\r\n                    texture: { value: new THREE.TextureLoader().load( \"./assets/textures/sprites/ball.png\" ) }\r\n                },\r\n                vertexShader: document.getElementById( 'vertexshader' ).textContent,\r\n                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,\r\n\r\n                blending: THREE.AdditiveBlending,\r\n                depthTest: false,\r\n                transparent: true,\r\n                vertexColors: true\r\n        } );\r\n\r\n        particles = new THREE.Points( geometry, material );\r\n        scene.add( particles );\r\n    }\r\n/*    \r\n    function deformGeometry(geometry) {\r\n        for (let i=0; i<geometry.vertices.length; i+=2) {\r\n            const scalar = 1 + Math.random()*0.8;\r\n            geometry.vertices[i].multiplyScalar(scalar)\r\n        }\r\n\r\n        return geometry;\r\n    }\r\n*/\r\n    function update(time) {\r\n        let positions = particles.geometry.attributes.position.array;\r\n        let scales = particles.geometry.attributes.scale.array;\r\n        //let colors = particles.geometry.attributes.color.array;\r\n\r\n        //let color = new THREE.Color();\r\n        let i = 0, j = 0;\r\n        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {\r\n            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {\r\n                // ========================= MOTION Y =========================\r\n                positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 100 ) +\r\n                                ( Math.sin( ( iy + count ) * 0.5 ) * 100 );\r\n                scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 7 +\r\n                                ( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 7;\r\n\r\n                //color.setHSL( i / numParticles / 2, 1.0, 0.5 );\r\n\r\n                //colors[ i ] = Math.sin(iy + count ); \r\n\r\n                i += 3;\r\n                j ++;\r\n            }\r\n        }\r\n        particles.geometry.attributes.position.needsUpdate = true;\r\n        particles.geometry.attributes.scale.needsUpdate = true;\r\n        particles.geometry.attributes.color.needsUpdate = true;\r\n        count += 0.05;\r\n    }\r\n\r\n    return {\r\n        update\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}