{"ast":null,"code":"import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n/**\n * @author bhouston / http://clara.io\n */\n\nvar _vector1 = new Vector3();\n\nvar _vector2 = new Vector3();\n\nvar _normalMatrix = new Matrix3();\n\nfunction Plane(normal, constant) {\n  // normal is assumed to be normalized\n  this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);\n  this.constant = constant !== undefined ? constant : 0;\n}\n\nObject.assign(Plane.prototype, {\n  isPlane: true,\n  set: function (normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  },\n  setComponents: function (x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  },\n  setFromNormalAndCoplanarPoint: function (normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  },\n  setFromCoplanarPoints: function (a, b, c) {\n    var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  },\n  clone: function () {\n    return new this.constructor().copy(this);\n  },\n  copy: function (plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  },\n  normalize: function () {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    var inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  },\n  negate: function () {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  },\n  distanceToPoint: function (point) {\n    return this.normal.dot(point) + this.constant;\n  },\n  distanceToSphere: function (sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  },\n  projectPoint: function (point, target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .projectPoint() target is now required');\n      target = new Vector3();\n    }\n\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  },\n  intersectLine: function (line, target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .intersectLine() target is now required');\n      target = new Vector3();\n    }\n\n    var direction = line.delta(_vector1);\n    var denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      } // Unsure if this is the correct method to handle this case.\n\n\n      return undefined;\n    }\n\n    var t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return undefined;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  },\n  intersectsLine: function (line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    var startSign = this.distanceToPoint(line.start);\n    var endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  },\n  intersectsBox: function (box) {\n    return box.intersectsPlane(this);\n  },\n  intersectsSphere: function (sphere) {\n    return sphere.intersectsPlane(this);\n  },\n  coplanarPoint: function (target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .coplanarPoint() target is now required');\n      target = new Vector3();\n    }\n\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  },\n  applyMatrix4: function (matrix, optionalNormalMatrix) {\n    var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    var normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  },\n  translate: function (offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  },\n  equals: function (plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n});\nexport { Plane };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/math/Plane.js"],"names":["Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","normal","constant","undefined","Object","assign","prototype","isPlane","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","clone","constructor","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","console","warn","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals"],"mappings":"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","sourcesContent":["import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\n/**\n * @author bhouston / http://clara.io\n */\n\nvar _vector1 = new Vector3();\nvar _vector2 = new Vector3();\nvar _normalMatrix = new Matrix3();\n\nfunction Plane( normal, constant ) {\n\n\t// normal is assumed to be normalized\n\n\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n}\n\nObject.assign( Plane.prototype, {\n\n\tisPlane: true,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function ( a, b, c ) {\n\n\t\tvar normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t},\n\n\tintersectLine: function ( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tvar direction = line.delta( _vector1 );\n\n\t\tvar denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t},\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\n\n\t\tvar normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tvar referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n} );\n\n\nexport { Plane };\n"]},"metadata":{},"sourceType":"module"}