{"ast":null,"code":"/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector4 } from '../math/Vector4.js';\n\nfunction SkinnedMesh(geometry, material) {\n  if (geometry && geometry.isGeometry) {\n    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n  }\n\n  Mesh.call(this, geometry, material);\n  this.type = 'SkinnedMesh';\n  this.bindMode = 'attached';\n  this.bindMatrix = new Matrix4();\n  this.bindMatrixInverse = new Matrix4();\n}\n\nSkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: SkinnedMesh,\n  isSkinnedMesh: true,\n  bind: function (skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n\n    if (bindMatrix === undefined) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.getInverse(bindMatrix);\n  },\n  pose: function () {\n    this.skeleton.pose();\n  },\n  normalizeSkinWeights: function () {\n    var vector = new Vector4();\n    var skinWeight = this.geometry.attributes.skinWeight;\n\n    for (var i = 0, l = skinWeight.count; i < l; i++) {\n      vector.x = skinWeight.getX(i);\n      vector.y = skinWeight.getY(i);\n      vector.z = skinWeight.getZ(i);\n      vector.w = skinWeight.getW(i);\n      var scale = 1.0 / vector.manhattanLength();\n\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0); // do something reasonable\n      }\n\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  },\n  updateMatrixWorld: function (force) {\n    Mesh.prototype.updateMatrixWorld.call(this, force);\n\n    if (this.bindMode === 'attached') {\n      this.bindMatrixInverse.getInverse(this.matrixWorld);\n    } else if (this.bindMode === 'detached') {\n      this.bindMatrixInverse.getInverse(this.bindMatrix);\n    } else {\n      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n    }\n  },\n  clone: function () {\n    return new this.constructor(this.geometry, this.material).copy(this);\n  }\n});\nexport { SkinnedMesh };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/src/objects/SkinnedMesh.js"],"names":["Mesh","Matrix4","Vector4","SkinnedMesh","geometry","material","isGeometry","console","error","call","type","bindMode","bindMatrix","bindMatrixInverse","prototype","Object","assign","create","constructor","isSkinnedMesh","bind","skeleton","undefined","updateMatrixWorld","calculateInverses","matrixWorld","copy","getInverse","pose","normalizeSkinWeights","vector","skinWeight","attributes","i","l","count","x","getX","y","getY","z","getZ","w","getW","scale","manhattanLength","Infinity","multiplyScalar","set","setXYZW","force","warn","clone"],"mappings":"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","sourcesContent":["/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector4 } from '../math/Vector4.js';\n\nfunction SkinnedMesh( geometry, material ) {\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\tconsole.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t}\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = 'attached';\n\tthis.bindMatrix = new Matrix4();\n\tthis.bindMatrixInverse = new Matrix4();\n\n}\n\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: SkinnedMesh,\n\n\tisSkinnedMesh: true,\n\n\tbind: function ( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tvar vector = new Vector4();\n\n\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( var i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.x = skinWeight.getX( i );\n\t\t\tvector.y = skinWeight.getY( i );\n\t\t\tvector.z = skinWeight.getZ( i );\n\t\t\tvector.w = skinWeight.getW( i );\n\n\t\t\tvar scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n\nexport { SkinnedMesh };\n"]},"metadata":{},"sourceType":"module"}