{"ast":null,"code":"import * as THREE from 'three'; //import SceneSubject from './SceneSubject';\n\nimport GeneralLights from './GeneralLights';\nimport * as dat from 'dat.gui';\nimport { OBJLoader } from '../../threejs/examples/jsm/loaders/OBJLoader.js';\nimport { EffectComposer } from '../../threejs/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from '../../threejs/examples/jsm/postprocessing/RenderPass.js';\nimport { FilmPass } from '../../threejs/examples/jsm/postprocessing/FilmPass.js';\nimport { BloomPass } from '../../threejs/examples/jsm/postprocessing/BloomPass.js';\nimport { ShaderPass } from '../../threejs/examples/jsm/postprocessing/ShaderPass.js';\nimport { SobelOperatorShader } from '../../threejs/examples/jsm/shaders/SobelOperatorShader.js';\nimport { OutlinePass } from '../../threejs/examples/jsm/postprocessing/OutlinePass.js';\nimport { RectAreaLightUniformsLib } from '../../threejs/examples/jsm/lights/RectAreaLightUniformsLib.js';\nimport { RectAreaLightHelper } from '../../threejs/examples/jsm/helpers/RectAreaLightHelper.js';\nimport { RGBELoader } from '../../threejs/examples/jsm/loaders/RGBELoader.js';\nimport { HDRCubeTextureLoader } from '../../threejs/examples/jsm/loaders/HDRCubeTextureLoader.js'; //import { RectAreaLightHelper } from '../../threejs/examples/jsm/helpers/RectAreaLightHelper.js';\n//const glsl = require('glslify');\n\nconst OrbitControls = require('three-orbit-controls')(THREE);\n\nconst modelurl = './assets/curationjs/model/xx.obj';\nexport default (canvas => {\n  /*\r\n  \t\t// =============== DECLEAR ===============\r\n             var model;\r\n  \t\tvar hdrCubeRenderTarget = null;\r\n  \t\tvar pmremGenerator;\r\n  \t\t\t\r\n  \t\tvar ground;\r\n  \t\tvar diffuseColor;\r\n  \t\tvar sceneCube, cubeMesh, sphereMesh;\r\n  \n  \t\tvar textureEquirec, textureCube, textureSphere, textureENV;\r\n  \n  \t\tvar matHDR = new THREE.MeshStandardMaterial({\r\n  \t\t\tcolor: 0xff0000,\r\n  \t\t\troughness: 0.1\r\n         \t\t//emissiveIntensity: .5,\r\n  \t\t});\r\n  \n  \t\tvar matROOM = new THREE.MeshStandardMaterial( {\r\n  \t\t\t\tcolor: 0xffffff,\r\n  \t\t\t\troughness: 0.5\r\n  \t\t\t});\r\n  \t\tvar matGROUND = new THREE.MeshStandardMaterial( {\r\n  \t\t\t\tcolor: 0x555555,\r\n  \t\t\t\troughness: 0.3,\r\n  \t\t\t\treflectivity: 0.5\r\n  \t\t\t});\r\n  \t\t\r\n  \t\t\r\n  \t\t// =============== HACK ===============\r\n  \t\tconst screenDimensions = {\r\n  \t        width: canvas.width,\r\n  \t        height: canvas.height\r\n  \t    }\r\n  \t    // =============== LOAD ROOM ================\r\n  \t    \r\n  \t\tTHREE.Mesh.prototype.clone = function () {\r\n  \n  \t\t\tvar newMaterial = ( this.material.isMaterial ) ? this.material.clone() : this.material.slice();\r\n  \n  \t\t\treturn new this.constructor( this.geometry.clone(), newMaterial ).copy( this );\r\n  \n  \t\t};\r\n  \t\t\r\n  \t\t// =============== LOAD ROOM ================\r\n             var loadRoom = function(renderer, scene){\r\n  \n                 var loader = new OBJLoader(new THREE.LoadingManager(()=>{}));\r\n                 \r\n                 // =================object will install into ./public not in ./src===================\r\n                 loader.load( modelurl , function ( obj ) {\r\n                     // Object\r\n                     obj.children.forEach((child)=>{\r\n  \n                     \tif ( child.isMesh ) {\r\n                     \t\t\r\n                     \t\tvar geo = child;\r\n                     \t\tgeo.material = matROOM;\r\n                     \t\tgeo.material.needsUpdate = true;\r\n                     \t\tgeo.castShadow = true;\r\n                     \t\tgeo.receiveShadow = true;\r\n                             scene.add(geo);\r\n                     \t}\r\n                     });\r\n  \n                     // ground\t\t\t\t\t\r\n                     ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 200, 200 ), matGROUND );\r\n  \t\t\t\tground.rotation.x = -Math.PI/2;\r\n  \t\t\t\tground.castShadow = true;\r\n  \t\t\t\tground.receiveShadow = true;\r\n  \t\t\t\tscene.add( ground );\r\n                     /*\r\n                     obj.traverse( function ( child ) {\r\n                         if ( child.isMesh ) {\r\n                             var geo = child;\r\n                             geo.material = matRoom;                            \r\n                             geo.castShadow = true;\r\n                             scene.add(geo);                  \r\n                         }               \r\n                     });\r\n                     \r\n                 }, onProgress, onError );\r\n             }\r\n             function onProgress( xhr ) {\r\n              if ( xhr.lengthComputable ) {\r\n                  var percentComplete = xhr.loaded / xhr.total * 100;\r\n                  console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );\r\n                  }\r\n     \t\t}\r\n  \n  \t    function onError() {\r\n  \t            console.log( 'error!!' );\r\n  \t    }\r\n  \t\t\t\t\r\n  \t\t//=============== BUILD ================\r\n  \t    const scene = buildScene();\r\n  \t    const renderer = buildRender(screenDimensions);\r\n  \t    const camera = buildCamera(screenDimensions);\r\n  \t    const contorls = buildControls(camera);\r\n  \t\tinit();\r\n  \n  \n  \t\tfunction buildScene() {\r\n  \t        const scene = new THREE.Scene();\r\n  \t        scene.background = new THREE.Color('#000');\r\n  \t        return scene;\r\n  \t    }\r\n  \t    \r\n  \t    function buildRender({ width, height }) {\r\n  \t        const renderer = new THREE.WebGLRenderer( {canvas: canvas, antialias: true } );\r\n  \t        renderer.setPixelRatio( window.devicePixelRatio );\r\n  \t        renderer.setSize( width, height );\r\n  \n  \t        //renderer.shadowMap.enabled = true;\r\n  \t\t\t//renderer.shadowMap.type = THREE.VSMShadowMap;\r\n  \t\t\t//renderer.setClearColor( 0xCCCCCC, 1 );\r\n  \t\t\trenderer.physicallyCorrectLights = true;\r\n  \t\t\trenderer.toneMapping = THREE.LinearToneMapping;\r\n  \n  \t\t\t// HDR\r\n  \n  \t\t\tTHREE.DefaultLoadingManager.onLoad = function ( ) {\r\n  \n  \t\t\t\tpmremGenerator.dispose();\r\n  \n  \t\t\t};\r\n  \t\t\t\r\n  \n  \t        // ================= SET HDRI-MATERIAL ======================\r\n  \t        // Textures\r\n  \t        \r\n  \t\t\tvar hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];\r\n  \t\t\ttextureCube = new HDRCubeTextureLoader()\r\n  \t\t\t\t.setPath( './assets/textures/cube/pisaHDR/' )\r\n  \t\t\t\t.setDataType( THREE.UnsignedByteType )\r\n  \t\t\t\t.load( hdrUrls, function () {\r\n  \n  \t\t\t\t\thdrCubeRenderTarget = pmremGenerator.fromCubemap( textureCube );\r\n  \t\t\t\t\ttextureCube.magFilter = THREE.LinearFilter;\r\n  \t\t\t\t\ttextureCube.needsUpdate = true;\r\n  \n  \t\t\t\t} );\r\n  \n  \t\t\tpmremGenerator = new THREE.PMREMGenerator( renderer );\r\n  \t\t\tpmremGenerator.compileCubemapShader();\r\n  \n  \t\t\t\r\n  \n  \t\t\trenderer.toneMappingExposure = 2;\r\n  \t        return renderer;\r\n  \t    }\r\n  \n  \t    function buildCamera({ width, height }) {\r\n  \n  \t        const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\r\n  \t\t\tcamera.position.x = 6;\r\n  \t\t\tcamera.position.y = 1.5;\r\n  \t\t\tcamera.position.z = 0;\r\n  \t\t\tcamera.lookAt(scene);\r\n  \t        return camera;\r\n  \t    }\r\n  \t    function buildControls(camera){\r\n  \t    \tconst controls = new OrbitControls( camera, renderer.domElement );\r\n  \t        controls.update();\r\n  \t        return controls\r\n  \t    }\r\n  \t    // GENERATE ENV\r\n  \t    function buildENV(){\r\n  \t    \t// create environmet\r\n  \t    \tvar envScene = new THREE.Scene();\r\n  \n  \t    \tvar mainLight = new THREE.PointLight( 0xffffff, 1, 30, 1.6 ); //( color : Integer, intensity : Float, distance : Number, decay : Float )\r\n  \t    \tmainLight.position.set( 0, 3, 0 );\r\n  \t    \t//mainLight.shadow = true;\r\n  \t\t\tenvScene.add( mainLight );\r\n  \n  \t\t\tvar geometry = new THREE.BoxBufferGeometry();\r\n  \t\t\tgeometry.deleteAttribute( 'uv' );\r\n  \t\t\tvar roomMaterial = new THREE.MeshStandardMaterial( { metalness: 0, side: THREE.BackSide } );\r\n  \t\t\tvar room = new THREE.Mesh( geometry, roomMaterial );\r\n  \t\t\troom.scale.setScalar( 10 );\r\n  \t\t\tenvScene.add( room );\r\n  \n  \t\t\tvar lightMaterial = new THREE.MeshLambertMaterial( { color: 0x000000, emissive: 0xffffff, emissiveIntensity: 10 } );\r\n  \n  \t\t\tvar light1 = new THREE.Mesh( geometry, lightMaterial );\r\n  \t\t\tlight1.position.set( - 500, 200, 0 );\r\n  \t\t\tlight1.scale.set( 0.1, 1, 1 );\r\n  \t\t\tenvScene.add( light1 );\r\n  \n  \t\t\tvar light2 = new THREE.Mesh( geometry, lightMaterial );\r\n  \t\t\tlight2.position.set( 0, 500, 0 );\r\n  \t\t\tlight2.scale.set( 1, 0.1, 1 );\r\n  \t\t\tenvScene.add( light2 );\r\n  \n  \t\t\tvar light2 = new THREE.Mesh( geometry, lightMaterial );\r\n  \t\t\tlight2.position.set( 200, 100, 500 );\r\n  \t\t\tlight2.scale.set( 1.5, 2, 0.1 );\r\n  \t\t\tenvScene.add( light2 );\r\n  \n  \t\t\t// upload as teture map\r\n  \t\t\tvar pmremGenerator = new THREE.PMREMGenerator( renderer );\r\n  \t\t\tpmremGenerator.compileCubemapShader();\r\n  \t\t\ttextureENV = pmremGenerator.fromScene( envScene, 0.1 );\r\n  \n  \t\t\tmatHDR.envMap = textureENV.texture;\r\n  \t        \r\n  \t        matROOM.envMap = textureENV.texture;\r\n  \t        matGROUND.envMap = textureENV.texture;\r\n  \n  \t        renderer.outputEncoding = THREE.sRGBEncoding;\r\n  \n  \t\t\treturn envScene;\r\n  \t    }\r\n  \n  \n  \t    function init() {\r\n  \n  \t\t\t\r\n  \n  \t\t\t// room\r\n  \t\t\t\r\n  \t\t\tvar materials = [];\r\n  \t\t\t\r\n  \t\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n  \n  \t\t\t\tmaterials.push( new THREE.MeshBasicMaterial( { color: 0xfaaaaa, side: THREE.BackSide } ) );\r\n  \n  \t\t\t}\r\n  \t\t\tvar geometry = new THREE.BoxBufferGeometry( 3, 3, 3 );\r\n  \t\t\tvar mesh = new THREE.Mesh( geometry, materials );\r\n  \t\t\tscene.add( mesh );\r\n  \t\t\t\r\n  \t\t\t// ================= ROOM ======================\r\n  \t\t\tnew loadRoom( renderer, scene );\r\n  \t\t\tbuildENV();\r\n  \n  \t\t\t//var material = new THREE.MeshBasicMaterial( { vertexColors: true } );\r\n  \t\t\tmodel = new THREE.Mesh( new THREE.TorusKnotBufferGeometry( 0.75, 0.3, 128, 32, 1 ), matHDR );\r\n  \t\t\tmodel.geometry.translate(0,1.5,0);\r\n  \t\t\tscene.add( model );\r\n  \t\t\t//new SimpleGI( renderer, scene );\r\n  \t\t}\r\n  */\n  function onWindowResize() {//const { width, height } = canvas;\t\t        \n    //screenDimensions.width = width;\n    //screenDimensions.height = height;\n    //camera.aspect = width / height;\n    //camera.updateProjectionMatrix();\t\t        \n    //renderer.setSize(width, height);\n  }\n\n  function update() {//requestAnimationFrame( update );\n    //renderer.setRenderTarget( null );\n    //renderer.render( scene, camera );\n  }\n\n  return {\n    update,\n    onWindowResize\n  };\n});","map":{"version":3,"sources":["D:/chrlab/src/component/panelComponent/Canvas/Opencvjs/threejs/SceneManager.js"],"names":["THREE","GeneralLights","dat","OBJLoader","EffectComposer","RenderPass","FilmPass","BloomPass","ShaderPass","SobelOperatorShader","OutlinePass","RectAreaLightUniformsLib","RectAreaLightHelper","RGBELoader","HDRCubeTextureLoader","OrbitControls","require","modelurl","canvas","onWindowResize","update"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB,C,CACA;;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAO,KAAKC,GAAZ,MAAqB,SAArB;AACA,SAASC,SAAT,QAA0B,iDAA1B;AAEA,SAASC,cAAT,QAA+B,6DAA/B;AACA,SAASC,UAAT,QAA2B,yDAA3B;AACA,SAASC,QAAT,QAAyB,uDAAzB;AACA,SAASC,SAAT,QAA0B,wDAA1B;AAEA,SAASC,UAAT,QAA2B,yDAA3B;AACA,SAASC,mBAAT,QAAoC,2DAApC;AACA,SAASC,WAAT,QAA4B,0DAA5B;AAEA,SAASC,wBAAT,QAAyC,+DAAzC;AACA,SAASC,mBAAT,QAAoC,2DAApC;AAEA,SAASC,UAAT,QAA2B,kDAA3B;AAEA,SAASC,oBAAT,QAAqC,4DAArC,C,CACA;AAEA;;AACA,MAAMC,aAAa,GAAGC,OAAO,CAAC,sBAAD,CAAP,CAAgChB,KAAhC,CAAtB;;AACA,MAAMiB,QAAQ,GAAG,kCAAjB;AAEA,gBAAeC,MAAM,IAAI;AACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoPE,WAASC,cAAT,GAA0B,CACnB;AACA;AACA;AACA;AACA;AACA;AACH;;AAEJ,WAASC,MAAT,GAAkB,CAEjB;AACA;AACA;AAEA;;AAEA,SAAO;AACHA,IAAAA,MADG;AAEHD,IAAAA;AAFG,GAAP;AAIH,CA1QD","sourcesContent":["import * as THREE from 'three';\r\n//import SceneSubject from './SceneSubject';\r\nimport GeneralLights from './GeneralLights';\r\nimport * as dat from 'dat.gui';\r\nimport { OBJLoader } from '../../threejs/examples/jsm/loaders/OBJLoader.js';\r\n\r\nimport { EffectComposer } from '../../threejs/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from '../../threejs/examples/jsm/postprocessing/RenderPass.js';\r\nimport { FilmPass } from '../../threejs/examples/jsm/postprocessing/FilmPass.js';\r\nimport { BloomPass } from '../../threejs/examples/jsm/postprocessing/BloomPass.js';\r\n\r\nimport { ShaderPass } from '../../threejs/examples/jsm/postprocessing/ShaderPass.js';\r\nimport { SobelOperatorShader } from '../../threejs/examples/jsm/shaders/SobelOperatorShader.js';\r\nimport { OutlinePass } from '../../threejs/examples/jsm/postprocessing/OutlinePass.js';\r\n\r\nimport { RectAreaLightUniformsLib } from '../../threejs/examples/jsm/lights/RectAreaLightUniformsLib.js';\r\nimport { RectAreaLightHelper } from '../../threejs/examples/jsm/helpers/RectAreaLightHelper.js';\r\n\r\nimport { RGBELoader } from '../../threejs/examples/jsm/loaders/RGBELoader.js';\r\n\r\nimport { HDRCubeTextureLoader } from '../../threejs/examples/jsm/loaders/HDRCubeTextureLoader.js';\r\n//import { RectAreaLightHelper } from '../../threejs/examples/jsm/helpers/RectAreaLightHelper.js';\r\n\r\n//const glsl = require('glslify');\r\nconst OrbitControls = require('three-orbit-controls')(THREE);\r\nconst modelurl = './assets/curationjs/model/xx.obj';\r\n\r\nexport default canvas => {\r\n\t/*\r\n\t\t\t// =============== DECLEAR ===============\r\n            var model;\r\n\t\t\tvar hdrCubeRenderTarget = null;\r\n\t\t\tvar pmremGenerator;\r\n\t\t\t\t\r\n\t\t\tvar ground;\r\n\t\t\tvar diffuseColor;\r\n\t\t\tvar sceneCube, cubeMesh, sphereMesh;\r\n\r\n\t\t\tvar textureEquirec, textureCube, textureSphere, textureENV;\r\n\r\n\t\t\tvar matHDR = new THREE.MeshStandardMaterial({\r\n\t\t\t\tcolor: 0xff0000,\r\n\t\t\t\troughness: 0.1\r\n        \t\t//emissiveIntensity: .5,\r\n\t\t\t});\r\n\r\n\t\t\tvar matROOM = new THREE.MeshStandardMaterial( {\r\n\t\t\t\t\tcolor: 0xffffff,\r\n\t\t\t\t\troughness: 0.5\r\n\t\t\t\t});\r\n\t\t\tvar matGROUND = new THREE.MeshStandardMaterial( {\r\n\t\t\t\t\tcolor: 0x555555,\r\n\t\t\t\t\troughness: 0.3,\r\n\t\t\t\t\treflectivity: 0.5\r\n\t\t\t\t});\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// =============== HACK ===============\r\n\t\t\tconst screenDimensions = {\r\n\t\t        width: canvas.width,\r\n\t\t        height: canvas.height\r\n\t\t    }\r\n\t\t    // =============== LOAD ROOM ================\r\n\t\t    \r\n\t\t\tTHREE.Mesh.prototype.clone = function () {\r\n\r\n\t\t\t\tvar newMaterial = ( this.material.isMaterial ) ? this.material.clone() : this.material.slice();\r\n\r\n\t\t\t\treturn new this.constructor( this.geometry.clone(), newMaterial ).copy( this );\r\n\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// =============== LOAD ROOM ================\r\n            var loadRoom = function(renderer, scene){\r\n\r\n                var loader = new OBJLoader(new THREE.LoadingManager(()=>{}));\r\n                \r\n                // =================object will install into ./public not in ./src===================\r\n                loader.load( modelurl , function ( obj ) {\r\n                    // Object\r\n                    obj.children.forEach((child)=>{\r\n\r\n                    \tif ( child.isMesh ) {\r\n                    \t\t\r\n                    \t\tvar geo = child;\r\n                    \t\tgeo.material = matROOM;\r\n                    \t\tgeo.material.needsUpdate = true;\r\n                    \t\tgeo.castShadow = true;\r\n                    \t\tgeo.receiveShadow = true;\r\n                            scene.add(geo);\r\n                    \t}\r\n                    });\r\n\r\n                    // ground\t\t\t\t\t\r\n                    ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 200, 200 ), matGROUND );\r\n\t\t\t\t\tground.rotation.x = -Math.PI/2;\r\n\t\t\t\t\tground.castShadow = true;\r\n\t\t\t\t\tground.receiveShadow = true;\r\n\t\t\t\t\tscene.add( ground );\r\n                    /*\r\n                    obj.traverse( function ( child ) {\r\n                        if ( child.isMesh ) {\r\n                            var geo = child;\r\n                            geo.material = matRoom;                            \r\n                            geo.castShadow = true;\r\n                            scene.add(geo);                  \r\n                        }               \r\n                    });\r\n                    \r\n                }, onProgress, onError );\r\n            }\r\n            function onProgress( xhr ) {\r\n\t            if ( xhr.lengthComputable ) {\r\n\t                var percentComplete = xhr.loaded / xhr.total * 100;\r\n\t                console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );\r\n\t                }\r\n    \t\t}\r\n\r\n\t\t    function onError() {\r\n\t\t            console.log( 'error!!' );\r\n\t\t    }\r\n\t\t\t\t\t\r\n\t\t\t//=============== BUILD ================\r\n\t\t    const scene = buildScene();\r\n\t\t    const renderer = buildRender(screenDimensions);\r\n\t\t    const camera = buildCamera(screenDimensions);\r\n\t\t    const contorls = buildControls(camera);\r\n\t\t\tinit();\r\n\r\n\r\n\t\t\tfunction buildScene() {\r\n\t\t        const scene = new THREE.Scene();\r\n\t\t        scene.background = new THREE.Color('#000');\r\n\t\t        return scene;\r\n\t\t    }\r\n\t\t    \r\n\t\t    function buildRender({ width, height }) {\r\n\t\t        const renderer = new THREE.WebGLRenderer( {canvas: canvas, antialias: true } );\r\n\t\t        renderer.setPixelRatio( window.devicePixelRatio );\r\n\t\t        renderer.setSize( width, height );\r\n\r\n\t\t        //renderer.shadowMap.enabled = true;\r\n\t\t\t\t//renderer.shadowMap.type = THREE.VSMShadowMap;\r\n\t\t\t\t//renderer.setClearColor( 0xCCCCCC, 1 );\r\n\t\t\t\trenderer.physicallyCorrectLights = true;\r\n\t\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\r\n\r\n\t\t\t\t// HDR\r\n\r\n\t\t\t\tTHREE.DefaultLoadingManager.onLoad = function ( ) {\r\n\r\n\t\t\t\t\tpmremGenerator.dispose();\r\n\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\r\n\t\t        // ================= SET HDRI-MATERIAL ======================\r\n\t\t        // Textures\r\n\t\t        \r\n\t\t\t\tvar hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];\r\n\t\t\t\ttextureCube = new HDRCubeTextureLoader()\r\n\t\t\t\t\t.setPath( './assets/textures/cube/pisaHDR/' )\r\n\t\t\t\t\t.setDataType( THREE.UnsignedByteType )\r\n\t\t\t\t\t.load( hdrUrls, function () {\r\n\r\n\t\t\t\t\t\thdrCubeRenderTarget = pmremGenerator.fromCubemap( textureCube );\r\n\t\t\t\t\t\ttextureCube.magFilter = THREE.LinearFilter;\r\n\t\t\t\t\t\ttextureCube.needsUpdate = true;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\tpmremGenerator = new THREE.PMREMGenerator( renderer );\r\n\t\t\t\tpmremGenerator.compileCubemapShader();\r\n\r\n\t\t\t\t\r\n\r\n\t\t\t\trenderer.toneMappingExposure = 2;\r\n\t\t        return renderer;\r\n\t\t    }\r\n\r\n\t\t    function buildCamera({ width, height }) {\r\n\r\n\t\t        const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );\r\n\t\t\t\tcamera.position.x = 6;\r\n\t\t\t\tcamera.position.y = 1.5;\r\n\t\t\t\tcamera.position.z = 0;\r\n\t\t\t\tcamera.lookAt(scene);\r\n\t\t        return camera;\r\n\t\t    }\r\n\t\t    function buildControls(camera){\r\n\t\t    \tconst controls = new OrbitControls( camera, renderer.domElement );\r\n\t\t        controls.update();\r\n\t\t        return controls\r\n\t\t    }\r\n\t\t    // GENERATE ENV\r\n\t\t    function buildENV(){\r\n\t\t    \t// create environmet\r\n\t\t    \tvar envScene = new THREE.Scene();\r\n\r\n\t\t    \tvar mainLight = new THREE.PointLight( 0xffffff, 1, 30, 1.6 ); //( color : Integer, intensity : Float, distance : Number, decay : Float )\r\n\t\t    \tmainLight.position.set( 0, 3, 0 );\r\n\t\t    \t//mainLight.shadow = true;\r\n\t\t\t\tenvScene.add( mainLight );\r\n\r\n\t\t\t\tvar geometry = new THREE.BoxBufferGeometry();\r\n\t\t\t\tgeometry.deleteAttribute( 'uv' );\r\n\t\t\t\tvar roomMaterial = new THREE.MeshStandardMaterial( { metalness: 0, side: THREE.BackSide } );\r\n\t\t\t\tvar room = new THREE.Mesh( geometry, roomMaterial );\r\n\t\t\t\troom.scale.setScalar( 10 );\r\n\t\t\t\tenvScene.add( room );\r\n\r\n\t\t\t\tvar lightMaterial = new THREE.MeshLambertMaterial( { color: 0x000000, emissive: 0xffffff, emissiveIntensity: 10 } );\r\n\r\n\t\t\t\tvar light1 = new THREE.Mesh( geometry, lightMaterial );\r\n\t\t\t\tlight1.position.set( - 500, 200, 0 );\r\n\t\t\t\tlight1.scale.set( 0.1, 1, 1 );\r\n\t\t\t\tenvScene.add( light1 );\r\n\r\n\t\t\t\tvar light2 = new THREE.Mesh( geometry, lightMaterial );\r\n\t\t\t\tlight2.position.set( 0, 500, 0 );\r\n\t\t\t\tlight2.scale.set( 1, 0.1, 1 );\r\n\t\t\t\tenvScene.add( light2 );\r\n\r\n\t\t\t\tvar light2 = new THREE.Mesh( geometry, lightMaterial );\r\n\t\t\t\tlight2.position.set( 200, 100, 500 );\r\n\t\t\t\tlight2.scale.set( 1.5, 2, 0.1 );\r\n\t\t\t\tenvScene.add( light2 );\r\n\r\n\t\t\t\t// upload as teture map\r\n\t\t\t\tvar pmremGenerator = new THREE.PMREMGenerator( renderer );\r\n\t\t\t\tpmremGenerator.compileCubemapShader();\r\n\t\t\t\ttextureENV = pmremGenerator.fromScene( envScene, 0.1 );\r\n\r\n\t\t\t\tmatHDR.envMap = textureENV.texture;\r\n\t\t        \r\n\t\t        matROOM.envMap = textureENV.texture;\r\n\t\t        matGROUND.envMap = textureENV.texture;\r\n\r\n\t\t        renderer.outputEncoding = THREE.sRGBEncoding;\r\n\r\n\t\t\t\treturn envScene;\r\n\t\t    }\r\n\r\n\r\n\t\t    function init() {\r\n\r\n\t\t\t\t\r\n\r\n\t\t\t\t// room\r\n\t\t\t\t\r\n\t\t\t\tvar materials = [];\r\n\t\t\t\t\r\n\t\t\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\t\t\tmaterials.push( new THREE.MeshBasicMaterial( { color: 0xfaaaaa, side: THREE.BackSide } ) );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tvar geometry = new THREE.BoxBufferGeometry( 3, 3, 3 );\r\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, materials );\r\n\t\t\t\tscene.add( mesh );\r\n\t\t\t\t\r\n\t\t\t\t// ================= ROOM ======================\r\n\t\t\t\tnew loadRoom( renderer, scene );\r\n\t\t\t\tbuildENV();\r\n\r\n\t\t\t\t//var material = new THREE.MeshBasicMaterial( { vertexColors: true } );\r\n\t\t\t\tmodel = new THREE.Mesh( new THREE.TorusKnotBufferGeometry( 0.75, 0.3, 128, 32, 1 ), matHDR );\r\n\t\t\t\tmodel.geometry.translate(0,1.5,0);\r\n\t\t\t\tscene.add( model );\r\n\t\t\t\t//new SimpleGI( renderer, scene );\r\n\t\t\t}\r\n\t*/\r\n\t\t\tfunction onWindowResize() {\r\n\t\t        //const { width, height } = canvas;\t\t        \r\n\t\t        //screenDimensions.width = width;\r\n\t\t        //screenDimensions.height = height;\r\n\t\t        //camera.aspect = width / height;\r\n\t\t        //camera.updateProjectionMatrix();\t\t        \r\n\t\t        //renderer.setSize(width, height);\r\n\t\t    }\r\n\r\n\t\t\tfunction update() {\r\n\r\n\t\t\t\t//requestAnimationFrame( update );\r\n\t\t\t\t//renderer.setRenderTarget( null );\r\n\t\t\t\t//renderer.render( scene, camera );\r\n\r\n\t\t\t}\r\n    \r\n    return {\r\n        update,\r\n        onWindowResize\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}