{"ast":null,"code":"/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\nimport { Vector2 } from \"../../../build/three.module.js\";\nvar ConvolutionShader = {\n  defines: {\n    \"KERNEL_SIZE_FLOAT\": \"25.0\",\n    \"KERNEL_SIZE_INT\": \"25\"\n  },\n  uniforms: {\n    \"tDiffuse\": {\n      value: null\n    },\n    \"uImageIncrement\": {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    \"cKernel\": {\n      value: []\n    }\n  },\n  vertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 imageCoord = vUv;\", \"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"\t\timageCoord += uImageIncrement;\", \"\t}\", \"\tgl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n\n    var i,\n        values,\n        sum,\n        halfWidth,\n        kMaxKernelSize = 25,\n        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    halfWidth = (kernelSize - 1) * 0.5;\n    values = new Array(kernelSize);\n    sum = 0.0;\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n    return values;\n  }\n};\nexport { ConvolutionShader };","map":{"version":3,"sources":["H:/chrlab/src/component/panelComponent/Canvas/threejs/examples/jsm/shaders/ConvolutionShader.js"],"names":["Vector2","ConvolutionShader","defines","uniforms","value","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","Math","exp","i","values","sum","halfWidth","kMaxKernelSize","kernelSize","ceil","Array"],"mappings":"AAAA;;;;;;;AAQA,SACCA,OADD,QAEO,gCAFP;AAIA,IAAIC,iBAAiB,GAAG;AAEvBC,EAAAA,OAAO,EAAE;AAER,yBAAqB,MAFb;AAGR,uBAAmB;AAHX,GAFc;AASvBC,EAAAA,QAAQ,EAAE;AAET,gBAAY;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAFH;AAGT,uBAAmB;AAAEA,MAAAA,KAAK,EAAE,IAAIJ,OAAJ,CAAa,WAAb,EAA0B,GAA1B;AAAT,KAHV;AAIT,eAAW;AAAEI,MAAAA,KAAK,EAAE;AAAT;AAJF,GATa;AAiBvBC,EAAAA,YAAY,EAAE,CAEb,+BAFa,EAIb,mBAJa,EAMb,eANa,EAQb,sEARa,EASb,4EATa,EAWb,GAXa,EAaZC,IAbY,CAaN,IAbM,CAjBS;AAgCvBC,EAAAA,cAAc,EAAE,CAEf,2CAFe,EAIf,6BAJe,EAKf,+BALe,EAOf,mBAPe,EASf,eATe,EAWf,yBAXe,EAYf,yCAZe,EAcf,gDAde,EAgBf,4DAhBe,EAiBf,kCAjBe,EAmBf,IAnBe,EAqBf,sBArBe,EAuBf,GAvBe,EA0BdD,IA1Bc,CA0BR,IA1BQ,CAhCO;AA4DvBE,EAAAA,WAAW,EAAE,UAAWC,KAAX,EAAmB;AAE/B;AAEA,aAASC,KAAT,CAAgBC,CAAhB,EAAmBF,KAAnB,EAA2B;AAE1B,aAAOG,IAAI,CAACC,GAAL,CAAU,EAAIF,CAAC,GAAGA,CAAR,KAAgB,MAAMF,KAAN,GAAcA,KAA9B,CAAV,CAAP;AAEA;;AAED,QAAIK,CAAJ;AAAA,QAAOC,MAAP;AAAA,QAAeC,GAAf;AAAA,QAAoBC,SAApB;AAAA,QAA+BC,cAAc,GAAG,EAAhD;AAAA,QAAoDC,UAAU,GAAG,IAAIP,IAAI,CAACQ,IAAL,CAAWX,KAAK,GAAG,GAAnB,CAAJ,GAA+B,CAAhG;AAEA,QAAKU,UAAU,GAAGD,cAAlB,EAAmCC,UAAU,GAAGD,cAAb;AACnCD,IAAAA,SAAS,GAAG,CAAEE,UAAU,GAAG,CAAf,IAAqB,GAAjC;AAEAJ,IAAAA,MAAM,GAAG,IAAIM,KAAJ,CAAWF,UAAX,CAAT;AACAH,IAAAA,GAAG,GAAG,GAAN;;AACA,SAAMF,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGK,UAAjB,EAA6B,EAAGL,CAAhC,EAAoC;AAEnCC,MAAAA,MAAM,CAAED,CAAF,CAAN,GAAcJ,KAAK,CAAEI,CAAC,GAAGG,SAAN,EAAiBR,KAAjB,CAAnB;AACAO,MAAAA,GAAG,IAAID,MAAM,CAAED,CAAF,CAAb;AAEA,KAtB8B,CAwB/B;;;AAEA,SAAMA,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGK,UAAjB,EAA6B,EAAGL,CAAhC,EAAoCC,MAAM,CAAED,CAAF,CAAN,IAAeE,GAAf;;AAEpC,WAAOD,MAAP;AAEA;AA1FsB,CAAxB;AA8FA,SAASd,iBAAT","sourcesContent":["/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nimport {\n\tVector2\n} from \"../../../build/three.module.js\";\n\nvar ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"uImageIncrement\": { value: new Vector2( 0.001953125, 0.0 ) },\n\t\t\"cKernel\": { value: [] }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 imageCoord = vUv;\",\n\t\t\"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\"\t\timageCoord += uImageIncrement;\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\n\t].join( \"\\n\" ),\n\n\tbuildKernel: function ( sigma ) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss( x, sigma ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t}\n\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\tvalues = new Array( kernelSize );\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\n\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\tsum += values[ i ];\n\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\treturn values;\n\n\t}\n\n};\n\nexport { ConvolutionShader };\n"]},"metadata":{},"sourceType":"module"}