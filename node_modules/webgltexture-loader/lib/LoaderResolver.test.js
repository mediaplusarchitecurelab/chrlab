"use strict";

var _LoaderResolver = _interopRequireDefault(require("./LoaderResolver"));

var _LoadersRegistry = _interopRequireDefault(require("./LoadersRegistry"));

var _WebGLTextureLoaderSyncHashCache = _interopRequireDefault(require("./WebGLTextureLoaderSyncHashCache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

test("an empty LoaderResolver resolves nothing", () => {
  const gl = {};
  const resolver = new _LoaderResolver.default(gl);
  expect(resolver.resolve(null)).toBeUndefined();
  expect(resolver.resolve(42)).toBeUndefined();
  expect(resolver.resolve("foo")).toBeUndefined();
  resolver.dispose();
});
test("LoaderResolver works with one loader", () => {
  const gl = {
    deleteTexture: () => {}
  };
  const registry = new _LoadersRegistry.default();

  class FakeLoader extends _WebGLTextureLoaderSyncHashCache.default {
    canLoad(input) {
      return typeof input === "number";
    }

    inputHash(input) {
      return input;
    }

    getNoCache(input) {
      return {
        texture: {
          id: input
        },
        width: 2,
        height: 2
      };
    }

  }

  registry.add(FakeLoader);
  const resolver = new _LoaderResolver.default(gl, registry);
  expect(resolver.resolve(null)).toBeUndefined();
  expect(resolver.resolve("foo")).toBeUndefined();
  const loader = resolver.resolve(42);
  expect(loader).toBeDefined();
  expect(loader).toBeInstanceOf(FakeLoader);
  resolver.dispose();
});
//# sourceMappingURL=LoaderResolver.test.js.map