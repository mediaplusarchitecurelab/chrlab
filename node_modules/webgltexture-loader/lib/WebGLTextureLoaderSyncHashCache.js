"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _WebGLTextureLoader = _interopRequireDefault(require("./WebGLTextureLoader"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class WebGLTextureLoaderSyncHashCache extends _WebGLTextureLoader.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "results", new Map());

    _defineProperty(this, "promises", new Map());

    _defineProperty(this, "_disposed", false);
  }

  // return a unique representation of the input (typically a hash, or anything that can be used as ref identifier)
  inputHash(input) {
    return "";
  } // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load


  getNoCache(input) {
    throw new Error("getNoCache must be implemented");
  }

  dispose() {
    const {
      gl,
      results,
      promises
    } = this;
    results.forEach(r => {
      this.disposeTexture(r.texture);
    });
    results.clear();
    promises.clear();
    this._disposed = true;
  }

  disposeTexture(texture) {
    this.gl.deleteTexture(texture);
  }

  get(input) {
    const hash = this.inputHash(input);
    const result = this.results.get(hash);
    if (result) return result;
    const freshResult = this.getNoCache(input);
    this.results.set(hash, freshResult);
    return freshResult;
  } // load() implementation is a dumb fallback on get() but still need to save the promise to guarantee idempotent


  load(input) {
    const hash = this.inputHash(input);
    const existing = this.promises.get(hash);
    if (existing) return existing;
    const promise = Promise.resolve(this.get(input));
    this.promises.set(hash, promise);
    return promise;
  }

}

var _default = WebGLTextureLoaderSyncHashCache;
exports.default = _default;
//# sourceMappingURL=WebGLTextureLoaderSyncHashCache.js.map