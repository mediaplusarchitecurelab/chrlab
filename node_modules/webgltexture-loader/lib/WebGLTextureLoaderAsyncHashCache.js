"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _WebGLTextureLoader = _interopRequireDefault(require("./WebGLTextureLoader"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const neverEnding = new Promise(() => {});
/**
 * A cache implementation of WebGLTextureLoader with a input hash function
 */

class WebGLTextureLoaderAsyncHashCache extends _WebGLTextureLoader.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "disposes", new Map());

    _defineProperty(this, "inputs", new Map());

    _defineProperty(this, "promises", new Map());

    _defineProperty(this, "results", new Map());

    _defineProperty(this, "_disposed", false);
  }

  inputHash(input) {
    return "";
  } // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load


  loadNoCache(input) {
    return {
      promise: Promise.reject(new Error("loadNoCache is not implemented")),
      dispose: () => {}
    };
  }

  dispose() {
    const {
      gl,
      promises,
      results,
      inputs,
      disposes
    } = this;
    disposes.forEach(d => d());
    results.forEach(result => {
      this.disposeTexture(result.texture);
    });
    promises.clear();
    results.clear();
    inputs.clear();
    disposes.clear();
    this._disposed = true;
  }

  disposeTexture(texture) {
    this.gl.deleteTexture(texture);
  }

  load(input) {
    const hash = this.inputHash(input);
    const maybePromise = this.promises.get(hash);
    if (maybePromise) return maybePromise;
    const d = this.loadNoCache(input);
    this.disposes.set(hash, d.dispose);
    const promise = d.promise.then(result => {
      if (!this.promises.has(hash)) {
        return neverEnding;
      }

      this.disposes.delete(hash);
      this.results.set(hash, result);
      return result;
    });
    this.promises.set(hash, promise);
    return promise;
  }

  get(input) {
    return this.results.get(this.inputHash(input));
  }

  cancelLoad(input) {
    const hash = this.inputHash(input);
    this.promises.delete(hash);
    const dispose = this.disposes.get(hash);

    if (dispose) {
      dispose();
      this.disposes.delete(hash);
    }
  }

}

var _default = WebGLTextureLoaderAsyncHashCache;
exports.default = _default;
//# sourceMappingURL=WebGLTextureLoaderAsyncHashCache.js.map