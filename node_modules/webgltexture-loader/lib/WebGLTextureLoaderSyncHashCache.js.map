{"version":3,"sources":["../src/WebGLTextureLoaderSyncHashCache.js"],"names":["WebGLTextureLoaderSyncHashCache","WebGLTextureLoader","Map","inputHash","input","getNoCache","Error","dispose","gl","results","promises","forEach","r","disposeTexture","texture","clear","_disposed","deleteTexture","get","hash","result","freshResult","set","load","existing","promise","Promise","resolve"],"mappings":";;;;;;;AACA;;;;;;AAGA,MAAMA,+BAAN,SAAiDC,2BAAjD,CAAuE;AAAA;AAAA;;AAAA,qCAUnC,IAAIC,GAAJ,EAVmC;;AAAA,sCAWzB,IAAIA,GAAJ,EAXyB;;AAAA,uCAazD,KAbyD;AAAA;;AACrE;AACAC,EAAAA,SAAS,CAACC,KAAD,EAAW;AAClB,WAAO,EAAP;AACD,GAJoE,CAKrE;;;AACAC,EAAAA,UAAU,CAACD,KAAD,EAA2B;AACnC,UAAM,IAAIE,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAMDC,EAAAA,OAAO,GAAG;AACR,UAAM;AAAEC,MAAAA,EAAF;AAAMC,MAAAA,OAAN;AAAeC,MAAAA;AAAf,QAA4B,IAAlC;AACAD,IAAAA,OAAO,CAACE,OAAR,CAAgBC,CAAC,IAAI;AACnB,WAAKC,cAAL,CAAoBD,CAAC,CAACE,OAAtB;AACD,KAFD;AAGAL,IAAAA,OAAO,CAACM,KAAR;AACAL,IAAAA,QAAQ,CAACK,KAAT;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACD;;AAEDH,EAAAA,cAAc,CAACC,OAAD,EAAwB;AACpC,SAAKN,EAAL,CAAQS,aAAR,CAAsBH,OAAtB;AACD;;AAEDI,EAAAA,GAAG,CAACd,KAAD,EAAW;AACZ,UAAMe,IAAI,GAAG,KAAKhB,SAAL,CAAeC,KAAf,CAAb;AACA,UAAMgB,MAAM,GAAG,KAAKX,OAAL,CAAaS,GAAb,CAAiBC,IAAjB,CAAf;AACA,QAAIC,MAAJ,EAAY,OAAOA,MAAP;AACZ,UAAMC,WAAW,GAAG,KAAKhB,UAAL,CAAgBD,KAAhB,CAApB;AACA,SAAKK,OAAL,CAAaa,GAAb,CAAiBH,IAAjB,EAAuBE,WAAvB;AACA,WAAOA,WAAP;AACD,GAnCoE,CAqCrE;;;AACAE,EAAAA,IAAI,CAACnB,KAAD,EAAW;AACb,UAAMe,IAAI,GAAG,KAAKhB,SAAL,CAAeC,KAAf,CAAb;AACA,UAAMoB,QAAQ,GAAG,KAAKd,QAAL,CAAcQ,GAAd,CAAkBC,IAAlB,CAAjB;AACA,QAAIK,QAAJ,EAAc,OAAOA,QAAP;AACd,UAAMC,OAAO,GAAGC,OAAO,CAACC,OAAR,CAAgB,KAAKT,GAAL,CAASd,KAAT,CAAhB,CAAhB;AACA,SAAKM,QAAL,CAAcY,GAAd,CAAkBH,IAAlB,EAAwBM,OAAxB;AACA,WAAOA,OAAP;AACD;;AA7CoE;;eAgDxDzB,+B","sourcesContent":["//@flow\nimport WebGLTextureLoader from \"./WebGLTextureLoader\";\nimport type { TextureAndSize } from \"./WebGLTextureLoader\";\n\nclass WebGLTextureLoaderSyncHashCache<T> extends WebGLTextureLoader<T> {\n  // return a unique representation of the input (typically a hash, or anything that can be used as ref identifier)\n  inputHash(input: T) {\n    return \"\";\n  }\n  // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load\n  getNoCache(input: T): TextureAndSize {\n    throw new Error(\"getNoCache must be implemented\");\n  }\n\n  results: Map<*, TextureAndSize> = new Map();\n  promises: Map<*, Promise<TextureAndSize>> = new Map();\n\n  _disposed = false;\n  dispose() {\n    const { gl, results, promises } = this;\n    results.forEach(r => {\n      this.disposeTexture(r.texture);\n    });\n    results.clear();\n    promises.clear();\n    this._disposed = true;\n  }\n\n  disposeTexture(texture: WebGLTexture) {\n    this.gl.deleteTexture(texture);\n  }\n\n  get(input: T) {\n    const hash = this.inputHash(input);\n    const result = this.results.get(hash);\n    if (result) return result;\n    const freshResult = this.getNoCache(input);\n    this.results.set(hash, freshResult);\n    return freshResult;\n  }\n\n  // load() implementation is a dumb fallback on get() but still need to save the promise to guarantee idempotent\n  load(input: T) {\n    const hash = this.inputHash(input);\n    const existing = this.promises.get(hash);\n    if (existing) return existing;\n    const promise = Promise.resolve(this.get(input));\n    this.promises.set(hash, promise);\n    return promise;\n  }\n}\n\nexport default WebGLTextureLoaderSyncHashCache;\n"],"file":"WebGLTextureLoaderSyncHashCache.js"}