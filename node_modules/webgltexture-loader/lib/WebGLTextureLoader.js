"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * a WebGLTextureLoader handle the loading of WebGLTexture for a given input object.
 */
class WebGLTextureLoader {
  /**
   * @property {WebGLRenderingContext} gl - the contextual rendering context
   */

  /**
   *
   */
  constructor(gl) {
    _defineProperty(this, "gl", void 0);

    this.gl = gl;
  }
  /**
   * Cancel and clear everything
   */


  dispose() {}
  /**
   * Check if the loader can handle a given input
   */


  canLoad(input) {
    return false;
  }
  /**
   * Load the resource by its input. returns a promise of {texture,width,height}.
   * idempotent: If load() is called twice with the same input, same promise is returned.
   */


  load(input) {
    return Promise.reject("load() is not implemented");
  }
  /**
   * try to get in sync the texture for a given input. otherwise null/undefined.
   * If null is returned, load() can be called in order to load the resource that will then be available in a future get() call.
   */


  get(input) {
    return null;
  }
  /**
   * sync the webgl texture with a loaded input. for instance for <video>/<canvas> elements this needs to be called recurrently (like in a requestAnimationFrame loop) to get the texture updated.
   * update should only get called IF get(input) was returning a result.
   */


  update(input) {// Default implementation don't do anything which works for all static content like an image
  }

}

exports.default = WebGLTextureLoader;
//# sourceMappingURL=WebGLTextureLoader.js.map